\chapter{Inuitionistic Epistemic Logic}
\label{ch:seqcon}


  \subsection{Summary}

  The subsequent development of this thesis is conceptually based on
  intuitionistic epistemic logic that appeared in the Master's thesis
  of the author.
  We contain the relevant motivations, definitions and results in this chapter.
  However, we omit proofs that
  can be found in the Master's thesis.
  We add the finite model property of sequential consistency logic
  with the full details because that result is not found in the Master's thesis.

  In this chapter, we give a logic called intuitionistic epistemic logic.
  The logic has epistemic modality $K_a$ in addition to ordinary logical connectives
  $(\wedge, \vee, \supset, \bot)$ of propositional logic.
  We explain the meaning of the new modality $K_a$ informally, by extending
  the Brouwer--Heyting--Kolmogorov interpretation (BHK-interpretation) of logical
  connectives, which dates back to 1930's
  (Heyting~\cite{heyting1930formalen, heyting1931intuitionistische}
  are cited by Troelstra et al.~\cite{troelstra1988constructivism}).

  Intuitionistic logic is originally a formalisation of a single mathematician whose
  knowledge
  increases over time.  The logic \iec\, formalises multiple agents who communicate
  asynchronously and whose knowledge increases over time.
  The logic \iec\, has a simple language:
  it has epistemic modality but no temporal modality
  so that it is simpler than many previous logics for communication.
  We do not need temporal modality because
  we regard time as
  the partial order in the semantics of intuitionistic epistemic logic.
  Before defining the deduction system, we first extend the informal intuitionistic
  reading of logical connectives.
  Precisely,
  we extend Brouwer--Heyting--Kolmogorov interpretation of logical connectives
  by adding one clause reagarding the additional epistemic modality~$K_a$.
  After stating the informal meaning for the modality,
  we define a deduction system and a Kripke semantics meeting this intuition.
  Soundness, strong completeness, finite
  model property, disjunction property and decidability are
  shown.
  We also investigate the relationship between \iec\,and classilcal modal logic with multple
  S4 modalities.

  On top of the logic \iec, we give an axiom type that characterises
  sequential consistency for shared memory.
  The advantage of intuitionistic logic over classical logic is shown
  in an example where a set of axioms characterises
  sequential consistency on shared memory.
  The axioms for sequential consistency are
  meaningless in classical logic while
  meaningful in intuitionistic logic.
  The axioms are similar to
  the axiom type for prelinerilty.
  This similarity reflects the analogy
  between sequential consistency for shared memory scheduling
  and linearity for Kripke frames: both require antisymmetry on schedules or models.

  Finally, under sequential consistency, we give soundness and completeness between
  a set of logical formulae called waitfree assertions and a set of models called
  schedule models.
  It has been found that it is undecidable whether a task is waitfreely solvable or not.
  We show that when we only view the communication requirements of tasks,
  it is decidable whether the communication is waitfreely attainable or not.

  There are at least two different ways of reasoning about knowledge.
  In one view of knowledge using Kripke semantics,
  which classical epistemic logic employs,
  knowledge is defined as proposition valid in all possible worlds
  that is possible to an agent.
  On the other hand, knowledge can be seen as something agents can send and receive.
  We unify these two notions of knowledge into the semantics of the logic we present.
  We define the semantics formally in the style of Kripke semantics.
  At the same time,
  an extension to BHK-interpretation reveals that asynchronous
  communication is implicit in the formal definition.

  \subsection{The Reason for Another Logic}

    \paragraph{Motivation: reasoning about concurrent systems}
    We give a formal deduction system for reasoning about
    asynchronous communication.
    The motivation for doing it is
    the fact that creating a concurrently
    working system with asynchronous communication
    and especially testing and debugging it is
    notoriously difficult
    because of nondeterministic scheduling.
    When the cost of testing and debugging is high,
    it is reasonable to
    spend more cost on ensuring correctness of the system
    at earlier stages like designing phase or implementation phase, not testing and debugging.
    In order to ensure correctness at an earlier stage,
    it is crucially important to reason about the system correctly because
    at such an early stage, knowledge about the system can only be obtained by reasoning,
    not by testing.

    \paragraph{Method: giving a formal deduction system}
    A formal deduction system mathematically defines
    available form of reasoning.
    In order to define reasoning mathematically,
    a formal deduction system uses languages defined mathematically.
    The main advantage of the reasoning on a formal deduction system over
    reasoning in a natural language
    is the former is independent of most implicit assumptions
    on which the latter is dependent so that
    the validity of the former formal reasoning can be checked more rigorously
    than the latter informal reasoning.

    We seek to have a formal
    deduction system as simple and learnable as possible to reason about asynchronous
    communication.
    We choose to give an epistemic logic, i.e., a logic with an operator expressing an agent's
    knowledge because mentioning agents' knowledge appeals to
    human intuition.
    For example, as Halpern and Zuck~\cite{halpern1992little}
    point out, Bochmann and Gecsei's paper~\cite{bochmann} written in 1977 already uses
    the notion of knowledge when reasoning about protocols:
    \begin{quotation}
     \noindent
     Verification \ldots will correspond
     \ldots to finding out whether and in
     which circumstances the sender \ldots
     can ``know'' that all data \ldots have been delivered correctly%
     \footnote{The dots \ldots and a period by the author.}.
    \end{quotation}

  \subsection{Intuitionistic Epistemic Logic}

  The main contribution of this thesis is giving definition of
  intuitionistic epistemic logic (\iec\, for short) and investigating it.

    \paragraph{Original intuitionistic meaning of knowledge}
    Agents in asynchronous systems can
    obtain knowledge about other agents only by receiving some constructions from them,
    not by waiting for a fixed length of time.
    This specific style of knowledge, where
    obtaining knowledge requires obtaining physical constructions,
    is the same as the style of knowledge of intuitionistic, constructive reasoners.
    That is the reason why we deliberately choose intuitionistic not classical meanings for
    the basic logical connectives, especially $\supset$ and $\vee$, although classical logic
    is more popularly used among computer scientists and mathematicians.
    The abstract Kripke model for asynchronous communication
    can be seen as a description of agents passing around constructions that ensure
    propositions.

    We extend the language of intuitionistic propositional logic with a unary operator $K_a$,
    whose meaning can be expressed as:
    a proof of $K_a\varphi$ is a construction that witnesses agent~$a$'s
    acknowledgement of a proof of $\varphi$ and also contains the acknowledged
    proof.  This formulation of knowledge is original.
    This meaning is different from that of classical epistemic logic where
    the meaning of $K_a$ can be expressed as:
    $K_a\varphi$ is valid if and only if $\varphi$ is valid in all possible worlds
    that agent~$a$ thinks possible.

    One advantage of our meaning of $K_a$ over that of classical meaning is that
    it can express communication without the help of another modality.
    Namely, in our meaning,
    a proof of $K_bK_a P$ is a construction that is passed from agent $a$ to agent
    $b$.
    On the other hand, in classical meaning, the same formula expresses nothing about
    communication:
    $K_b K_a P$ is valid when $P$ is valid in all possible worlds that agent~$b$ in any
    possible world that agent~$a$ thinks possible thinks possible.

    Intuitionistic logic can be seen as a logic describing an agent whose knowledge increases over
    time.
    The logic \iec\,  can be seen as a logic describing multiple agents
    that asynchronously communicate with each other and increase their knowledge.
    Although \iec\, deals with communication, the logic has only epistemic modalities so that it
    has simpler syntax than many other logics for communication.

    We give a deduction system and show
    soundness (Theorem~\ref{soundness}), disjunction property (Theorem~\ref{disjunction-property}),
    strong completeness
    (Theorem~\ref{strong-completeness}), finite model property
    (Theorem~\ref{thm:fmp}) and decidability (Theorem~\ref{decidability}).

  \subsection{Application to Waitfree Communication}

    \paragraph{Sequential consistency}
    The topological characterisation by Herlihy and Shavit~\cite{herlihy1999topological}
    implicitly assumes sequential consistency~\cite{lamport1979make} of shared memory.
    This motivated us to characterise sequential consistency with the axiom type
    $(K_\memory \varphi\supset K_\memory \psi)\vee (K_\memory
       \psi\supset K_\memory \varphi)$
       in the logic \iec\, for asynchronous computation.
       Technically, we defined a class of models called sequential models
       and proved soundness
       (Lemma~\ref{sc-sound}) and completeness
       (Theorem~\ref{sc-comp}) of the axiom type with respect to the sequential models.

    \paragraph{Waitfree communication}
    A waitfree protocol over shared memory~\cite{herlihy1991wait}
    assigns a program to each process so that no process waits for another process.
    Some tasks can be solved by a~well-chosen waitfree protocol while the others cannot.

    For example,
    it is waitfreely impossible for both of two processes to attain the input value of the other
    process.
    On the other hand, it is waitfreely possible for
    either one of two processes to attain the input value of the other process.
    A waitfree protocol that solves this task is:
    \begin{itemize}
     \item process $a$ tells the memory $\memory$ that $\varphi$ holds, and then $\memory$ replies back to $a$,
     \item process $b$ tells the memory $\memory$ that $\psi$    holds, and then $\memory$ replies back to $b$.
    \end{itemize}
    After this protocol finishes,
    either $\varphi$ has been communicated from~$a$ to~$b$
    or $\psi$ has
    been communicated from~$b$ to~$a$.

    In the
    logic \iec, this fact is represented by a judgement $K_aK_\memory{}K_a\varphi,
    K_bK_\memory{}K_b\psi\vdashsc K_aK_b\psi\vee K_bK_a\varphi$,
    which is deducible in \iec\, with
    sequential consistency axioms~(Figure~\ref{hoge}).

    Herlihy and Shavit~\cite{herlihy1999topological} characterised waitfree computation using
    simplicial topology.
    Using their characterisation,
    Gafni and Koutsoupias~\cite{gafni1999three}
    showed that it is undecidable whether a task is waitfreely solvable
    or not.
    When tasks are restricted to communication defined by
    a class of logical formulae that we call waitfree assertions,
    we can characterise waitfreely available communication logically (Theorem~\ref{sc-comp})
    and
    it is decidable whether a task is waitfreely solvable or not (Theorem~\ref{wf-dec}).



  \subsection{Formulae}

  We fix a countably infinite set of propositional symbols
  $\pvar$ and a finite set of agents $A$.
  Let $P, Q, \ldots$ run over the propositional symbols.

  \begin{definition}
   \label{formula}
   We define a \textit{formula} $\varphi$ by the BNF:
   \[
   \varphi ::= \bot\mid P\mid
   (K_a\varphi)\mid(\varphi\vee\varphi)\mid(\varphi\land\varphi)\mid
   (\varphi\supset\varphi)
   \]
   where $a\in A$ stands for an agent.
  \end{definition}
  We sometimes omit the parenthesis when no confusion occurs. We use $=$ for syntactic
  equality of formulae.
  \noindent The unary operators connect more strongly than the binary operators.
  We sometimes omit the parentheses when no confusion occurs. We use $=$ for syntactic
  equality of formulae.  The notation $(\neg \varphi)$ stands for $(\varphi\supset \bot)$.
  The notation~$\top$ stands for $(\bot\supset\bot)$.
  For a sequence of formulae $\Gamma = (\varphi_i)_{i\in I}$ or a set of formulae~$\Gamma$,
  the notation $K_a \Gamma$ stands for the sequence $(K_a \varphi_i)_{i\in I}$ or the set
  $\{K_a\varphi\mid \varphi\in \Gamma\}$ respectively.

  \subsection{Informal Explanation by BHK-Interpretation}
  \label{bhk}

  Intuitionistic meanings for logical connectives
  can be presented as
  following sentences called BHK-interpretation\footnote{
  Taken from Troelstra and van Dalen's textbook~\cite[Ch.~1]{troelstra1988constructivism}:
  author made notational modification of logical formulae and omission of
  quantifiers $\forall$ and $\exists$.
  }:
  \begin{quotation}
   \noindent
   \begin{description}
    \item[(H1)] A proof of $\varphi\land \psi$ is given by presenting a proof of $\varphi$
	 and a proof of $\psi$.
    \item[(H2)] A proof of $\varphi\vee\psi$ is given by presenting either a proof of
	 $\varphi$ or a proof of $\psi$ (plus the stipulation that we want to regard
	 the proof presented as evidence for $\varphi\vee\psi$\footnote{In fact, the
	 author considers this as not enough. A proof $\varphi\vee\varphi$ must contain
	 the choice of the left $\varphi$ or the right $\varphi$.  This
	 allows us to encode a Boolean value as a proof of $(\top\lor\top)$}).
    \item[(H3)] A proof of $\varphi\supset\psi$ is a construction which permits us to
	 transform any proof of $\varphi$ into a proof of $\psi$.
    \item[(H4)] Absurdity $\bot$ (contradiction) has no proof; a proof of $\neg \varphi$ is a
	 construction which transforms any hypothetical proof of $\varphi$ into a proof
	 of a contradiction.
   \end{description}
  \end{quotation}
  In this paper, we consider extending BHK-interpretation with another stipulation for
  epistemic modality:
  \begin{description}
   \item[(HK)] A proof of $K_a\varphi$ is a construction that witnesses agent~$a$'s
	acknowledgement of a proof of $\varphi$ and also contains the acknowledged
	proof.
  \end{description}
  We choose to regard knowledge as acknowledgement of proofs so that the modality $K_a$ informally
  describes knowledge of agent~$a$.
  The formalisation of knowledge is different from that in classical epistemic logic, where
  knowledge is described as a limitation on the ability to distinguish possible worlds.

  \subsection{Deduction System}

  \begin{figure*}
   \begin{center}
    \AxiomC{}
    \LeftLabel{(ax)}
    \UnaryInfC{$\varphi \vdash \varphi$}
    \DisplayProof
    \hfill
    \AxiomC{$\Gamma\vdash\varphi$}
    \LeftLabel{(w)}
    \UnaryInfC{$\psi,\,\Gamma\vdash\varphi$}
    \DisplayProof
    \hfill
    \AxiomC{$ \varphi,\,\varphi,\,\Gamma\vdash\varphi'$}
    \LeftLabel{(c)}
    \UnaryInfC{$\varphi,\,\Gamma\vdash\varphi'$}
    \DisplayProof
    \hfill
    \AxiomC{$\Gamma, \varphi,\psi,\, \Gamma'\vdash\varphi'$}
    \LeftLabel{(e)}
    \UnaryInfC{$\Gamma,\,\psi,\varphi,\,\Gamma'\vdash\varphi'$}
    \DisplayProof
    \vskip 5mm
    \AxiomC{$\Gamma\vdash \varphi\land\psi$}
    \LeftLabel{($\wedge$-E$_0$)}
    \UnaryInfC{$\Gamma\vdash \varphi$}
    \DisplayProof
    \hfill
    \AxiomC{$\Gamma\vdash\varphi$}
    \AxiomC{$\Gamma'\vdash\psi$}
    \LeftLabel{($\wedge$-I)}
    \BinaryInfC{$\Gamma,\Gamma'\vdash \varphi\land\psi$}
    \DisplayProof
    \hfill
    \AxiomC{$\Gamma\vdash \varphi\land\psi$}
    \LeftLabel{($\wedge$-E$_1$)}
    \UnaryInfC{$\Gamma\vdash \psi$}
    \DisplayProof
    \vskip 5mm
    \AxiomC{$\Gamma\vdash \varphi$}
    \LeftLabel{($\vee$-I$_0$)}
    \UnaryInfC{$\Gamma\vdash \varphi\vee\psi$}
    \DisplayProof
    \hfill
    \AxiomC{$\Gamma\vdash \varphi$}
    \LeftLabel{($\vee$-I$_1$)}
    \UnaryInfC{$\Gamma\vdash \psi\vee\varphi$}
    \DisplayProof
    \vskip 5mm
    \AxiomC{$\Gamma\vdash \psi_0\vee\psi_1$}
    \AxiomC{$\Gamma,\,\psi_0\vdash \varphi$}
    \AxiomC{$\Gamma,\,\psi_1\vdash \varphi$}
    \LeftLabel{($\vee$-E)}
    \TrinaryInfC{$\Gamma\vdash \varphi$}
    \DisplayProof
    \vskip 5mm
    \AxiomC{$\varphi,\,\Gamma\vdash\psi$}
    \LeftLabel{($\supset$-I)}
    \UnaryInfC{$\Gamma\vdash \varphi\supset\psi$}
    \DisplayProof
    \hfill
    \AxiomC{$\Gamma\vdash\psi_0\supset\psi_1$}
    \AxiomC{$\Gamma\vdash \psi_0$}
    \LeftLabel{($\supset$-E)}
    \BinaryInfC{$\Gamma\vdash \psi_1$}
    \DisplayProof
    \hfill
    \AxiomC{$\Gamma\vdash\bot$}
    \LeftLabel{($\bot$-E)}
    \UnaryInfC{$\Gamma\vdash\varphi$}
    \DisplayProof
    \hfill
    \AxiomC{$\Gamma\vdash K_a\varphi$}
    \LeftLabel{(T)}
    \UnaryInfC{$\Gamma\vdash \varphi$}
    \DisplayProof
    \vskip 5mm
    \AxiomC{$\Gamma \vdash K_a\varphi$}
    \LeftLabel{(ispec)}
    \UnaryInfC{$\Gamma\vdash K_a K_a \varphi$}
    \DisplayProof
    \hfill
    \AxiomC{$\Gamma\vdash\varphi$}
    \LeftLabel{(nec)}
    \UnaryInfC{$K_a\Gamma\vdash K_a\varphi$}
    \DisplayProof
    \hfill
    \AxiomC{$\Gamma\vdash K_a(\varphi\vee\psi)$}
    \LeftLabel{($\vee K$)}
    \UnaryInfC{$\Gamma\vdash K_a \varphi\vee K_a\psi$}
    \DisplayProof
   \end{center}
   \caption[Deduction rules of \iec.]
   {Deduction rules of \iec.  (ax) stands for axiom, (w) for weakening, (c) for
   contraction, (e) for exchange, (ispec) for introspection and (nec) for necessitation.
   ($\diamondsuit$-I) denotes the introduction rule for connective~$\diamondsuit$.
   ($\diamondsuit$-E) denotes the elimination rule for connective~$\diamondsuit$.}
   \label{fig}
  \end{figure*}

  We give a proof system of \iec\, in the natural deduction~\citep{gentzen, prawitz1971ideas}.
  All the rules that do not mention modalities are common with
  intuitionistic propositional logic while the other rules are added
  to define the meaning of the $K_a$ modality.
  \begin{definition}
   We define the proof system of \iec\, by Figure~\ref{fig}.
   The system is presented in the form of usual schemata.
   A proof diagram is a finite tree of deduction rules with one bottom node with the
   following property: when a node has a judgement
   above the line, there is a node immediately above it and the above node
   has the same judgement below the line.
  \end{definition}

    \paragraph{Rationales for the rules on modalities}

    While the rules (T), (ispec) and (nec) are admissible in classical S5 epistemic logic,
    we have an additional rule ($\vee K$) which needs explanation.
    In this paragraph, we are going to give a rationale for the rule ($\vee K$) with the help
    of BHK-interpretation given in Subsection~\ref{bhk}.
    A proof for the premise of the rule ($\vee K$) is a construction that witnesses agent~$a$'s
    acknowledgement of a proof of $\varphi\vee\psi$.
    Since a proof of $\varphi\vee\psi$ is either a proof of $\varphi$ or a proof of $\psi$,
    agent~$a$'s acknowledge of a proof of $\varphi\vee\psi$ implies either agent~$a$'s
    acknowledgement of a proof of $\varphi$ or agent~$a$'s acknowledgement of a proof of $\psi$.

    Also,
    we are informally
    assuming logical omniscience of the agents by rule (nec),
    that is, we assume agents have complete
    command on intuitionistic epistemic logic so that they acknowledge every formulae
    deducible from the set of formulae they acknowledge.

    \paragraph{Notational conventions}
    For a set of formulae~$\Gamma$ and a~formula~$\varphi$, $\Gamma\vdash
    \varphi$ denotes a~relation where
    there is such a~finite sequence~$\Gamma_0$ that
    $\Gamma_0\vdash
    \varphi$ is deducible and that $\Gamma_0$ is contained in $\Gamma$.

  \subsection{Semantics}
  We define validity of a~formula on a~state in a~model.
  A~model is a~Kripke model for propositional intuitionistic logic
  equipped with an additional
  mapping $f_a: W\rightarrow W$ for each agent $a\in A$ where $W$ is the
  set of possible states.
  Informally\footnote{This account is informal in that we do not attempt to
  define the terms ``view'' and ``current state.''},
  the function $f_a$ represents the view of agent
  $a$.
  When the current state is $w\in W$\kern -2pt, agent $a$ sees that the current state is
  $f_a(w)\in W$, in other words, agent $a$ knows everything valid in $f_a(w)$.
  As a special consequence, agent $a$ knows that agent $b$ sees that the current state
  is
  $f_b(f_a(w))\in W$\kern -2pt.

  \newcommand{\model}[1]{\tuple{W#1, \preceq#1, (f_a#1)_{a\in A}, \rho#1}}
  \begin{definition}
   \label{model}
   A \textit{model} $\tuple{W,\preceq, (f_a)_{a\in A}, \rho}$ is a tuple with following properties:
   \begin{enumerate}
    \item $\tuple{W,\preceq}$ is a partial order,
    \item $f_a\colon W\rightarrow W$ is a~function satisfying
	  \begin{enumerate}
	   \item (decreasing) $f_a(w) \preceq w$,
	   \item (idempotency) $f_a(f_a(w)) = f_a(w)$, and
	   \item (monotonicity) $w\preceq v$ implies $f_a(w)\preceq f_a(v)$
	  \end{enumerate}
	  for all $v,w\in W$, and
    \item $\rho\colon \pvar\rightarrow \powerset W$ is a function such that each $\rho(P)$ is
	  upward-closed with respect to $\preceq$, i.e., $w'\succeq w\in\rho(P)$ implies
	  $w'\in\rho(P)$.
   \end{enumerate}
  \end{definition}
  \noindent With the informal account in mind, the conditions on $f_a$ have rationales:
  decreasing condition says an agent~$a$ recognises only truth,
  idempotency says an agent $a$ recognises that
       $a$ recognises something whenever the agent~$a$ recognises that thing,
       and monotonicity says an agent~$a$ does not forget things recognised.
       Differently from classical epistemic logic,
       there is no distinction between global states and local states.

       The valuation~$\rho$ for propositional variables in $\pvar$ is extended into validity
       relation~$\models$ for all formulae in $\fml$.
       \begin{definition}
	We define the \textit{satisfaction relation} $\models$ of a~model
	$\tuple{W,\preceq,(f_a)_{a\in A},\rho}$, a~state~$w\in W$ of the model and a
	formula~$\varphi$.
	Let us fix a model $M=\tuple{W,\preceq,(f_a)_{a\in A},\rho}$.
	\newcommand{\m}{M}
	The definition of $M,w\models\varphi$ is inductive on the structure of $\varphi$.
	\begin{description}
	 \item[(Case $\varphi=\bot$)] $\m, w\models \bot$ never holds.
	 \item[(Case $\varphi= P$)] $\m, w\models P$ if and only if
	      $w \in
	      \rho(P)$.
	 \item[(Case $\varphi = K_a \psi$)]
	      $\m, w\models K_a \psi$ if and only if
	      $\m, f_a(w)\models \psi$.
	 \item[(Case $\varphi = \psi_0\land\psi_1$)]
	      $\m, w\models \psi_0\land\psi_1$ if and only if both
	      $\m, w\models \psi_0$ and $\m,w\models \psi_1$ hold.
	 \item[(Case $\varphi = \psi_0\vee\psi_1$)]
	      $\m, w\models \psi_0\vee\psi_1$ if and only if at least
	      one of
	      $\m, w\models \psi_0$ or $\m,w\models \psi_1$ holds.
	 \item[(Case $\varphi = \psi_0\supset \psi_1$)]
	      $\m, w\models \psi_0\supset\psi_1$ if and only if
	      for any $w'\in W$ with $w'\succeq w$, the satisfaction $M,w'\models \psi_0$ implies
	      the satisfaction $M, w'\models
	      \psi_1$.
	\end{description}
       \end{definition}

       Next, we show that the monotonicity condition on the valuation~$\rho$ of
       propositional variables is preserved by the extension
       to satisfaction~$\models$ of formulae. Informally, this theorem presents the limitation of the logic \iec:
       it can only deal with propositions whose satisfaction is preserved by progress with respect to
       the partial order $\preceq$.
       \begin{theorem}[Kripke monotonicity]
	\label{kripke}
	$M,w\models \varphi$ and $w\preceq v$ imply
	$M,v\models \varphi$.
       \end{theorem}
       \begin{proof}
	Straightforward using the monotonicity of $f_a$.
       \end{proof}

    \paragraph{Semantics of judgements}

    We introduce some notations which look similar to the judgements appearing in the
    deduction
    system.
    Being aware of the different definitions of $\vdash$ and $\models$, we are going to
    compare the two relations $\vdash$ and $\models$ in the next subsections.

    \begin{notation}
     For a~model~$M$ and a~state~$w$ of the model,
     we write $M,w\models \Gamma$ when the validity
     $M,w\models\varphi$ holds for any formula $\varphi$ in $\Gamma$.
    \end{notation}

    \begin{notation}
     $\Gamma\models\varphi$ stands for the relation of formula
     sequences $\Gamma$ and a~formula
     $\varphi$ that holds if and only if for any model $M$
     and $w\in M$, $M,w\models \Gamma$ implies
     $M,w\models \varphi$.
    \end{notation}

    \begin{definition}
     $\Gamma\models\varphi$ stands for the relation of a set of a formulae
     $\Gamma$ and a formula~$\varphi$ where $M,w\models \Gamma$ implies
     $M,w\models \varphi$ for any model~$M$
     and a~state~$w\in M$.
    \end{definition}
    For a~sequence of formulae $\Gamma$, we let $u(\Gamma)$ denote the set of formulae
    appearing in $\Gamma$.  We abbreviate $u(\Gamma)\models\varphi$ into
    $\Gamma\models\varphi$. We will write $\Gamma$ instead of $u(\Gamma)$ for the
    sake of brevity.

    \begin{definition}
     A set of formulae $\Gamma$ is consistent if and only if $\Gamma\not\models \bot$.
    \end{definition}

  \subsection{Soundness}

  A deduction system is called sound when existence of a proof of
  a sequent implies the corresponding semantic implication.
  Soundness is the most important feature of a formal deductive system because the
  main reason for using a formal deductive system is it ensures correct reasoning.
  We regard the defined semantics as a standard for correct reasoning and show that the
  deduction systems of \iec\, meets that standard.
  Soundness ensures a formula provable in \iec\, is valid in any state of any model.
  At the same time, we show a stronger notion:
  a formula provable under a set of assumptions is always valid whenever the assumptions are
  valid.

  \begin{theorem}[Soundness]
   \label{soundness}
   $\Gamma\vdash\varphi$ implies $\Gamma\models\varphi$.
  \end{theorem}
  Proof found in the author's Master's thesis.

  \subsection{Disjunction Property}

  Troelstra and van Dalen's
  textbook~\cite[3.5]{troelstra1988constructivism} says
  disjunction property is the test for constrictive logics.
  \fix{really they say so?}

   \begin{theorem}[Disjunction property]
    \label{disjunction-property}
    If $\vdash\varphi\vee\psi$ holds, either $\vdash\varphi$ or $\vdash\psi$ holds.
   \end{theorem}
   Proof to be found in the author's Master's thesis.

  \subsection{Strong Completeness and Finite Model Property}

  In this subsection, we show strong completeness and finite model property.
  Since both proofs contain model construction,
  most parts of both proofs can be written in the same lemmas.
  This utilisation of similarity of finite model property and strong completeness
  is originally the idea of
  Sato~\cite{sato13study}.

  \fix{remove '}
  \begin{definition}
   We define $f'_a$ as:
   \[
   f'_a(\Gamma) = g_a(\Gamma) \cup K_ag_a(\Gamma).
   \]
  \end{definition}

  For some pages, we argue about a
  set of formula $\Omega$. Later, when we show
  strong completeness, we take $\Omega$ to be the whole set of well formed formulae.  Also,
  when we show finite model property, we take $\Omega$ to be the set of the subformulae of a
  certain formula.  This model construction is inspired by
  Sato's paper~\cite{sato13study}
  and Troelstra and van Dalen's textbook~\cite{troelstra1988constructivism}.
  However, the notion of $f'$-subformula-closed sets is new and original.

  \begin{definition}
   \label{saturated-set}
   For a set of formulae $\Omega$,
   a set of formulae $\Gamma\subseteq\Omega$ is \textit{$\Omega$-saturated} if and only if
   \begin{enumerate}
    \item $\Gamma$ is $\Omega$-deductively closed, i.e., $\Gamma\vdash\varphi\in
	  \Omega\Rightarrow
	  \varphi\in\Gamma$,
    \item $\Gamma\vdash\varphi\vee\psi \Rightarrow \Gamma\vdash\varphi$ or $\Gamma\vdash\psi$
	  if $\varphi,\psi\in\Omega$,
    \item $\Gamma\not\vdash\bot$.
   \end{enumerate}
  \end{definition}

  \begin{definition}
   A hereditary $f'$-subformula-closed set $\Gamma$ is coinductively defined as:
   $\Gamma$ is a hereditary $f'$-subformula-closed set if and only
   if $f'_a(\Gamma)$ is hereditary $f'$-closed, $\Gamma$ is closed for taking subformulae and
   $f'_a(\Gamma)\subseteq \Gamma$.
  \end{definition}

  \begin{definition}
   We define $s_a(\varphi)$ inductively on $\varphi$:
   \[
   s_a(\varphi) = \begin{cases}
		   s_a(K_a\psi) & \text{(if $\varphi = K_aK_a\psi$)},\\
		   \varphi & \text{(otherwise)}.
		  \end{cases}
   \]
  \end{definition}
  \noindent The function $s_a$ replaces every $K_aK_a$ with $K_a$ repeatedly so that there are no
  $K_aK_a$ occurrences left.

  \begin{lemma}
   \label{fpreserve}
   For a hereditary $f'$-subformula-closed set $\Omega$,
   if $\Gamma$ is an $\Omega$-saturated set,
   $f_a(\Gamma)$ is an $f'_a(\Omega)$-saturated set.
  \end{lemma}
  \begin{proof}
   We first make sure that $f_a(\Gamma)$ is a subset of $f'_a(\Omega)$.
   By definition of $f_a$, $f_a(\Gamma) = g_a(\Gamma)\cup
   K_ag_a(\Gamma)\cup\{\bot\in\fml\mid \Gamma\vdash\bot\}$.
   Since $\Gamma$ is an $\Omega$-saturated set, $\Gamma\not\vdash\bot$ so that
   $f_a(\Gamma) = g_a(\Gamma)\cup K_ag_a(\Gamma)$.
   On the other hand, $f'_a(\Omega) = g_a(\Omega)\cup K_ag_a(\Omega)$.
   Since $g_a(\Gamma)\subseteq g_a(\Omega)$
   by Proposition~\ref{g_mono}, $f_a(\Gamma)\subseteq f'_a(\Omega)$ holds.

   We check each condition of Definition~\ref{saturated-set} to make sure
   that $f_a(\Gamma)$ is
   actually an~$f'_a(\Omega)$-saturated set.
   \begin{enumerate}
    \item Assume $f_a(\Gamma)\vdash\varphi$ and $\varphi\in f'_a(\Omega)$.
	  $\varphi\in g_a(\Omega)\cup K_ag_a(\Omega)$ holds.
	  \begin{description}
	   \item[ (Case $\varphi\in g_a(\Omega)$)]
		Note that $\varphi$ does not begin with $K_a$.
		By definition of $g_a$,
		$(K_a)^+\varphi\in\Omega$.
		Since $\Omega$ is subformula-closed,
		$K_a\varphi\in\Omega$ holds.
		By $\Gamma\vdash K_a\varphi$, since $\Gamma$ is $\Omega$-saturated,
		$K_a\varphi\in \Gamma$.
		Thus, $\varphi\in f_a(\Gamma)$.
	   \item[ (Case $\varphi\in K_ag_a(\Omega)$)]
		$\varphi = K_a\varphi'$ and $\varphi'\in g_a(\Omega)$ hold.
		Note that $\varphi'$ does not begin with $K_a$.
		By definition of $g_a$,
		$(K_a)^+\varphi'\in\Omega$.
		This implies $K_a\varphi'\in\Omega$.
		Since $\Gamma\vdash K_aK_a\varphi'$,
		$\Gamma\vdash K_a\varphi'$ holds.
		Thus, since $\Gamma$ is $\Omega$-saturated,
		$K_a\varphi'\in \Gamma$ holds.
		This means $\varphi = K_a\varphi' \in f_a(\Gamma)$.
	  \end{description}
    \item Assume $f_a(\Gamma)\vdash\varphi\vee\psi$ and
	  $\varphi,\psi\in f'_a(\Omega)$.
	  By rule~(nec), $K_af_a(\Gamma)\vdash K_a(\varphi\vee\psi)$ holds.
	  By~Proposition~\ref{wakame},
	  the formulae in $K_af_a(\Gamma)$ are deducible from $\Gamma$.
	  Thus, $\Gamma\vdash K_a(\varphi\vee\psi)$ holds.
	  By rule ($\vee K$) and the fact that $\Gamma$ is saturated,
	  either $K_as_a(\varphi)\in\Gamma$ or $K_as_a(\psi)\in\Gamma$ holds.
	  We can assume $K_as_a(\varphi)\in\Gamma$ without loss of generality.
	  This implies $f_a(\Gamma)\vdash\varphi$ and then
	  $\varphi\in f_a(\Gamma)$.
    \item Seeking contradiction, assume $f_a(\Gamma)\vdash\bot$.
	  Since $\Gamma\vdash K_a\bot$, the deducibility
	  $\Gamma\vdash\bot$ holds, which contradicts the fact that
	  $\Gamma$ is an $\Omega$-saturated set.
   \end{enumerate}
  \end{proof}

  \newcommand{\natpls}{{\mathbb N}^{+}}

  \fix{add strong completeness and finite model property}

  \section{Axiom Type for Sequential Consistency}
 \label{sc}

 A schedule determines temporal partial order of events such as
 message sending and receiving.
 A correct program must behave correctly under every schedule.
 Shared memory consistency is a restriction on schedules.
 When a stronger memory consistency is posed, it is easier for programs to behave
 correctly.  This is analogous to the fact
 that when a stronger condition
 is posed upon models, more formulae become valid.

 In this subsection, we characterise sequential consistency with a set of axioms.
 Sequential consistency defined by Lamport~\cite{lamport1979make} is essentially a condition requiring the states of memory lined up
 in a total order.
 We define a deduction system $\vdash_{SC}$ by adding an axiom type to \iec\, and
 characterise sequential consistency.

 Henceforth, we assume $A = \{\memory\}\cup P\quad (\memory\notin P)$, where $P$ is the
 set of processes and $\memory$ represents the shared memory.

  \subsection{Definitions}

  Sequential consistency requires
  the memory states to line up in a total order.
  A straightforward way to model sequential consistency might be
  choosing the set of memory states in the model
  and then asserting the memory states are lined up in a total order.
  Actually, we can identify a memory state as a state~$w$ with
  $f_\memory(w) = w$ because this Equation asserts that
  the memory's state seen from the state~$w$ is the state~$w$ itself.
  This straightforward modelling of sequential consistency turns out to be
  in appropriate logically because there is no formula which holds exactly
  in the models defined in that naive way.
  Even when there are memory states $v$ and $w$ without
  temporal relation between them,
  if the whole model is consists of a part containing $v$ and another disjoint,
  unrelated part
  containing $w$,
  no formula on no state can recognise the break of sequential consistency.
  Considering this pitfall, we can model sequential consistency as a class of models defined below.
  \begin{definition}
   A sequential model is a model where for any states $w, w'$ and $x$,
   $x\preceq w$, $x\preceq w'$, $f_\memory(w) = w$ and $f_\memory(w') = w'$ imply
   $w\preceq w'$ or $w'\preceq w$.
  \end{definition}

  \begin{definition}
   We let $SC$ be the set of formula of the form
   $(K_\memory \varphi\supset K_\memory \psi)\vee (K_\memory
   \psi\supset K_\memory \varphi)$.

   We add a rule (SC) to the previous calculus $\vdash$:
   \AxiomC{}
   \LeftLabel{(SC)}
   \UnaryInfC{$\vdash \varphi$}
   \DisplayProof ($\varphi \in SC$)

   We define $\Gamma\vdash_{SC}\varphi$ in the same way as $\Gamma\vdash\varphi$.
  \end{definition}
  \noindent Note that all axioms in the set $SC$ are classical tautologies so that adding these axioms
  to classical logic is meaningless.
  This is the merit of using intuitionistic logic rather than classical logic.

  \subsection{Soundness}
  \begin{lemma}
   \label{sc-sound}
   $\vdash_{SC} \varphi \Rightarrow M\models\varphi$ for any sequential model~$M$.
  \end{lemma}
  Proof to be found in the author's Master's thesis.)

  \subsection{Strong Completeness}
  \begin{theorem}[Strong completeness for sequential consistency]
   \label{sc-comp}
   $\Gamma\vdashsc\varphi$ holds if $M\models \Gamma$ implies $M\models\varphi$ for every
   sequential model~$M$.
  \end{theorem}
  Proof to be found in the author's Master's thesis.)

    \paragraph{Example Theorem}

    In Introduction, we gave an example of deducible judgements of $\vdashsc$:\\
    $K_aK_\memory{}K_a\varphi,
    K_bK\memory{}K_b\psi\vdashsc K_aK_b\psi\vee K_bK_a\varphi$.
    We give a proof for this judgement in Figure~\ref{hoge}.
    \begin{sidewaysfigure}
     {\tiny
     \textsf{Part A}\\
     \AxiomC{}
     \LeftLabel{(ax)}
     \UnaryInfC{$K_bK_a(K_\memory K_a\varphi\supset K_\memory K_b\psi)\vdashsc
     K_bK_a(K_\memory K_a\varphi\supset K_\memory K_b\psi)$}
     \LeftLabel{(T)}
     \UnaryInfC{$K_b K_a(K_\memory K_a\varphi\supset K_\memory K_b\psi)\vdash K_a(K_\memory
     K_a \varphi \supset K_\memory K_b\psi)$}
     \AxiomC{}
     \LeftLabel{(ax)}
     \UnaryInfC{$K_\memory K_a\varphi\vdashsc K_\memory K_a\varphi$}
     \AxiomC{}
     \LeftLabel{(ax)}
     \UnaryInfC{$K_\memory K_a\varphi\supset K_\memory K_b\psi\vdashsc K_\memory
     K_a\varphi\supset K_\memory K_b \psi$}
     \LeftLabel{($\supset$-E)}
     \BinaryInfC{$K_\memory K_a\varphi, K_\memory K_a\varphi\supset K_\memory K_b\psi\vdashsc
     K_\memory K_b\psi$}
     \LeftLabel{(nec)}
     \UnaryInfC{$K_a K_\memory K_a\varphi, K_a(K_\memory K_a\varphi\supset K_\memory
     K_b\psi)\vdashsc K_a K_\memory K_b\psi$}
     \LeftLabel{($\supset$-I)}
     \UnaryInfC{$K_aK_\memory K_a\varphi\vdashsc K_a(K_\memory K_a\varphi\supset K_\memory
     K_b\psi) \supset K_a K_\memory K_b\psi$}
     \LeftLabel{($\supset$-E)}
     \BinaryInfC{$K_b K_a(K_\memory K_a\varphi\supset K_\memory K_b\psi), K_aK_\memory
     K_a\varphi\vdashsc K_a K_\memory K_b\psi$}
     \LeftLabel{($\supset$-I)}
     \UnaryInfC{$K_b K_a(K_\memory K_a\varphi\supset K_\memory K_b\psi)\vdashsc
     K_aK_\memory K_a\varphi\supset K_aK_\memory K_b\psi$}
     \LeftLabel{($\vee$-I)}
     \UnaryInfC{$
     K_b K_a(K_\memory K_a\varphi\supset K_\memory K_b\psi)\vdashsc
     (K_\memory K_a\varphi\supset K_\memory K_b\psi)
     \vee
     (K_\memory K_b\psi\supset K_\memory K_a\varphi)
     $}
     \DisplayProof
     \vskip 7mm

     \textsf{Part B}\\
     \vskip 2mm
     \AxiomC{}
     \LeftLabel{(SC)}
     \UnaryInfC{$\vdashsc (K_\memory K_a\varphi\supset K_\memory K_b\psi)
     \vee
     (K_\memory K_b\psi\supset K_\memory K_a\varphi)$}
     \LeftLabel{(nec)}
     \UnaryInfC{$\vdashsc K_a\left((K_\memory K_a\varphi\supset K_\memory K_b\psi)
     \vee
     (K_\memory K_b\psi\supset K_\memory K_a\varphi)\right)$}
     \LeftLabel{($\vee K$)}
     \UnaryInfC{$\vdashsc K_a(K_\memory K_a\varphi\supset K_\memory K_b\psi)
     \vee
     K_a(K_\memory K_b\psi\supset K_\memory K_a\varphi)$}
     \LeftLabel{(nec)}
     \UnaryInfC{$\vdashsc K_b\left(K_a(K_\memory K_a\varphi\supset K_\memory K_b\psi)
     \vee
     K_a(K_\memory K_b\psi\supset K_\memory K_a\varphi)\right)$}
     \LeftLabel{($\vee K$)}
     \UnaryInfC{$\vdashsc K_b K_a(K_\memory K_a\varphi\supset K_\memory K_b\psi)
     \vee
     K_b K_a(K_\memory K_b\psi\supset K_\memory K_a\varphi)$}
     \AxiomC{$\vdots$ \textsf{Part A}}
     \AxiomC{$\vdots$ (same as left, swap $(a,b)$ and $(\varphi, \psi)$)}
     \LeftLabel{($\vee$E)}
     \TrinaryInfC{$\vdashsc
     (K_aK_\memory K_a\varphi\supset K_aK_\memory K_b\psi)\vee
     (K_bK_\memory K_b\psi\supset K_bK_\memory K_a\varphi)
     $}
     \DisplayProof
     \vskip 7mm

     \textsf{Part C}\\
     \AxiomC{}
     \LeftLabel{(ax)}
     \UnaryInfC{$K_aK_\memory K_a\varphi\vdashsc K_a K_\memory K_a\varphi$}
     \AxiomC{}
     \LeftLabel{(ax)}
     \UnaryInfC{$K_aK_\memory K_a\varphi\supset K_aK_\memory K_b\psi\vdashsc
     K_aK_\memory K_a\varphi\supset K_aK_\memory K_b\psi$}
     \LeftLabel{($\supset$-E)}
     \BinaryInfC{$K_aK_\memory K_a\varphi\supset K_aK_\memory K_b\psi, K_aK_\memory
     K_a\varphi\vdashsc K_aK_\memory K_b\psi$}
     \AxiomC{}
     \LeftLabel{(ax)}
     \UnaryInfC{$K_\memory K_b\psi \vdashsc K_\memory K_b\psi$}
     \LeftLabel{(T)}
     \UnaryInfC{$K_\memory K_b\psi\vdashsc K_b\psi$}
     \LeftLabel{(nec)}
     \UnaryInfC{$K_a K_\memory K_b\psi\vdashsc K_a K_b\psi$}
     \LeftLabel{($\supset$-I)}
     \UnaryInfC{$\vdashsc K_a K_\memory K_b \psi\supset K_aK_b\psi$}
     \LeftLabel{($\supset$-E)}
     \BinaryInfC{$K_aK_\memory K_a\varphi\supset K_aK_\memory K_a\psi, K_aK_\memory
     K_a\varphi\vdashsc K_a K_b \psi$}
     \DisplayProof
     \vskip 7mm

     \textsf{Main Part}\\
     \AxiomC{$\vdots$ \textsf{Part B}}
     \UnaryInfC{
     $(K_aK_\memory K_a\varphi\supset K_aK_\memory K_b\psi)\vee
     (K_bK_\memory K_b\psi\supset K_bK_\memory K_a\varphi)
     $
     }
     \AxiomC{$\vdots$ \textsf{Part C}}
     \UnaryInfC{$K_\memory{}K_a\varphi\supset K_\memory{}K_b\psi,\, K_aK_\memory{}K_a\varphi\vdashsc K_aK_b \psi$}
     \UnaryInfC{$K_\memory{}K_a\varphi\supset K_\memory{}K_b\psi,\,
     K_aK_\memory{}K_a\varphi\vdashsc K_a K_b \psi \vee K_b K_a \varphi$}
     \AxiomC{$\vdots$ (same as left, swap $(a,b)$ and $(\varphi, \psi)$)}
     \LeftLabel{$\vee$E}
     \TrinaryInfC{$K_aK_\memory{}K_a\varphi, K_bK_\memory{}K_b\psi\vdashsc K_aK_b\psi\vee K_bK_a\varphi$}
     \DisplayProof
     }
     \caption{A proof diagram for an example theorem in $\vdashsc$.}
     \label{hoge}
    \end{sidewaysfigure}


 \section{Waitfree Communication}
 \label{wf}

  \subsection{Problem Domain}

  A distributed program assigns a program to each process.
  When we execute a distributed program,
  processes obtain execution steps in the order determined by the scheduler.

  A distributed program is waitfree when there exists such a fixed number $k$ that
  under any schedule,
  any process finishes before using $k$~steps.
  The informal meaning of this condition is forbidding a process to wait for another
  process.
  Assuming a process~$p$ waits for another process~$q$ to do something,
  under an unfriendly schedule, the condition for waitfreedom is broken.
  Actually, under
  a schedule giving the first $k$~steps exclusively to the process~$p$
  the process~$q$ cannot do anything in those first $k$~steps while the process~$p$ waits
  for the process~$q$ to do that something, thus breaking the waitfree condition.

  Some tasks can be solved by a waitfree distributed program while others cannot.
  In this section, we consider the problem of
  distinguishing the waitfreely solvables task and the waitfreely unsolvable ones.
  Although this problem is undecidable in general~\cite{gafni1999three},
  we find an approximation problem that is decidable.

  \subsection{Logical Representation of the Problem}

  While sequential consistency is a restriction on schedules,
  waitfreedom is a restriction on distributed programs.
  The behaviour of distributed programs depend on the schedule%
  \footnote{A motivation for introducing formal reasoning into the area of distributed
  computation is in this fact, which makes testing harder.}.
  The a correct distributed program can be described as
  a distributed program which gives correct behaviour under any schedule.
  This form of definition is similar to that of validity of logical a formula:
  a valid logical formula is a formula which is satisfied by any model.
  We consider the schedule v.s. distributed program relation is similar to
  the formula v.s. model relation.
  In section~\ref{sc},
  in this section, we express waitfreedom as a class of formulae.

  A distributed program specifies
  from which process, to which process, and in what order
  signals are transmitted.
  We consider the signal transimission in a logical formula.
  In short, a modality over a modality like $K_a K_b P$ describes communication.
  We regard processes as agents.
  A propositional variable $I_a$ informally denotes the fact that the process~$a$ has
  started.
  A logical formula $K_b K_a I_a$ informally states
  ``the process~$a$ was aware of the fact that the process~$a$ had started,
  and then told the fact to the process~$b$.''
  Similarly, another formula $K_a K_b K_a I_a$ informally states
  ``the process~$a$ was aware of the fact that the process~$a$ had started,
  and then told the fact to the process~$b$. The process~$b$ in turn told back to the
  process~$p$ that the process~$q$ had received the fact from~$a$.''
  The latter communication pattern can be obtained by programs described in the following lines:
  \begin{enumerate}
   \item When process~$a$ starts, it sends a signal to the process~$b$, then waits for a
	 reply from~$b$ and then terminates.
   \item When process~$b$ starts, it waits for a signal from the process~$a$,
	 replies back to $a$, and then terminates.
  \end{enumerate}
  Unfortunately,
  since this distributed program is not waitfree,
  we cannot include the formula
  $K_a K_b K_a I_a$
  in the class of formulae representing waitfreedom.
  We will define the class of formulae and call them waitfree protocol descriptions.

  Actually, although a process running a waitfree program is forbidden to wait for another process,
  it is allowed to wait for the shared memory\footnote{Otherwise, any communication
  whatsoever would be impossible.}.
  For example, after a process
  makes a read request to the shared memory,
  it is allowed to wait for a value from the shared memory.
  Also, after a process makes a write request to the shared memory,
  it is allowed to wait for an acknowledgement from the shared memory.
  That is why we introduced a special agent $\memory\in A$ representing the shared memory.
  We call other agents in $A$ processes so that
  $A=\{\memory\}\cup P\quad (\memory\notin P)$ holds.

  After these observations, we can obtain the class of
  formulae representing a waitfree distributed program.
  When we are interested in a fixed waitfree distributed program,
  for any process, there is a~constant~$k$ and the process can interact with the memory for
  up to $k$ times.
  Moreover, since a process is only allowed to interact with the shared memory not with the
  process.
  Thus, a waitfree distributed program can only make sure the property described as
  $K_aK_\memory K_a\cdots K_\memory K_a P$ where $K_\memory$ and $K_a$ appear
  alternatively.
  We call such a logical formula a waitfree program description.

  Finally, as well the class of schedules and the class of waitfree programs,
  we describe specifications for waitfree programs in a logical formula.
  We forcifully decide that we only specify the posession of knowledge at finish of the
  program so that we only consider positive logical formulae as waitfree specifications.

  We define a class of formulae called waitfree assertions combining the waitfree protocol
  description and the waitfree specifications.
  Waitfree assertions have a special finite model property:
  if a waitfree assertion is consistent%
  \footnote{A formula $\varphi$ is consistent if and only if $\bot$ cannot be proved even if
  $\varphi$ is added as an axiom.}, there is a finite model of a special shape
  where the assertion is valid.
  The special shape mimics the scheduling of shared memory
  defined by Saks and Zaharoglou~\cite{saks2000wait}.

  \begin{definition}
   Assume there is a vector of atomic formulae $(I_a)_{a\in P}$.
   A~\textit{waitfree protocol description} $\varphi$ is a formula of the form
   \[
   \varphi = \bigwedge_{a\in P} K_a K_\memory K_a \cdots K_a I_a
   \]
   where $K_a$ and $K_\memory$ appear alternatively in ``$\cdots$''.
   A~\textit{waitfree task specification} $\psi$ is defined with the BNF:
   \[
   \psi ::= K_a\psi\mid \psi\land\psi\mid \psi\vee\psi\mid I_a
   \]
   where $a$ stands for a process in $P$.
   A~\textit{waitfree assertion} is a formula~$\varphi\supset\psi$ where $\varphi$ is a
   waitfree protocol description and $\psi$ is a waitfree task specification.
  \end{definition}

  \subsection{Representation of Schedules as Models}

  \begin{definition}
   A partial schedule $(\sigma_i)_{i\in I}$ is a finite sequence of
   subsets of $P$.
  \end{definition}

  \begin{definition}
   For a process $a\in P$ and a partial schedule $\sigma$, $count_a(\sigma)$ is the cardinality
   $\left|\{i\in I\mid a\in \sigma_i\}\right|$.

   For a waitfree protocol description $\varphi = \bigwedge_{a\in P}K_a K_\memory \cdots K_a I_a$,
   $count_a(\varphi)$ is the number of $K_\memory$ occurrences in $K_aK_\memory \cdots
   K_a I_a$.

   A partial schedule $\sigma$ is \textit{compatible} to a waitfree
   protocol description $\varphi$ if
   $count_a(\varphi) = count_a(\sigma)$ for any process $a\in P$.
  \end{definition}

  We introduce a special thing $o$ called an external observer with $o \notin A$.
  \begin{definition}
   For a waitfree protocol description $\varphi$ and
   a compatible partial schedule $(\sigma_i)_{i\in I}$, we define
   a waitfree schedule model $R(\varphi, \sigma) = \tuple{W, \preceq, (f_x)_{x\in A}, \rho}$ as:
   \begin{itemize}
    \item $
	  W = \{(a,i) \in P\times \mathbb N \mid p\in \sigma_i\} \cup
	  \{(a,i)' \in P\times \mathbb N \mid p\in \sigma_i\}
	  \cup \{(\memory,i)\mid i\in I\} \cup \{(o,i) \mid i\in I\}\cup
	  \{\bot\}
	  $,
    \item $(a,i) \preceq (m, i)\preceq (a, i)'$,
    \item $(x,j)\preceq (o,i)$ if and only if $j\le i$,
    \item $\bot\preceq w$ for all $w \in W$,
    \item $(x,j)'\preceq (o,i)$ if and only if $j \le i$,
    \item
	 $
	 f_a(w) =
	 \left\{
	 \begin{array}{l}
	  \mbox{the least $(a,j)$ with $(a,j)\preceq w$ (if there exists such $(a,j)$)} \\
	  \mbox{(the definition of $\preceq$ assures there is the least such $(a,j)$)},\\
	  \mbox{$\bot$ (if such $(a,j)$ does not exist)}.
	 \end{array}
	 \right.
	 $
    \item $\rho(I_a) = \{w\in W\mid (a,0)\preceq w\}$.
   \end{itemize}
  \end{definition}

  An example of a model induced by a partial schedule is shown in
  Figure~\ref{schedulemodel}.
  \begin{figure}
   \begin{center}
    \includegraphics[scale=0.3]{schedulemodel.eps}
   \end{center}
   \caption[A model $R(\cdot, \sigma)$.]{A model $R(\cdot, \sigma)$
   induced by the partial schedule $\sigma = \left(\{a,b\}, \{a\}, \{b\}\right)$.
   A solid arrow pointing to $(x,n)$ shows an $f_x$ mapping.  Dotted arrows show $\preceq$ relations.
   We omit implied arrows and the valuation.}
   \label{schedulemodel}
  \end{figure}

  We can state the logical characterisation of waitfree communication.
  \begin{theorem}[Completeness for waitfree communication]
   \label{wf:sc-comp}
   Assume $\varphi\supset \psi$ is a waitfree assertion.
   The relation $\vdash_{SC} \varphi\supset\psi$ holds if the relation $R(\varphi, \sigma),
   (o,n) \models \psi$ holds for any compatible partial schedule $\sigma$ where the state~$(o,n)$
   is the last state of the waitfree model $R(\varphi, \sigma)$.
  \end{theorem}
  To prove completeness, we only use special models called singleton
  models induced by a permutation of processes.

  \begin{definition}
   For a set of processes $P$, we define $\mathsf S(P)$ to be the set of the permutations of $P$.
  \end{definition}

  \begin{definition}
   For $\pi\in \mathsf S(P)$ and $0\le k\le |P|$, we define
   $SC(\pi,k)$ to be the set $\{K_\memory K_a I_a\supset K_\memory K_b I_b\mid b\le a\mbox{ in }\pi_0,\ldots \pi_k\}$.
  \end{definition}

  \begin{lemma}
   \label{perm}
   $\vdashsc \bigvee_{\pi\in \mathsf S(A)} SC(\pi, |P|)$ holds.
  \end{lemma}
  \begin{proof}
   It suffices to use rule (SC) many times.
  \end{proof}

  \begin{definition}
   For a permutation $\pi$ of $P$ and a waitfree protocol description $\varphi$, we
   define a partial schedule $\sigma(\varphi, \pi)$ as
   \[
   \sigma(\varphi, \pi) =
   \overbrace{\pi_0, \cdots, \pi_0}^{count_{\pi_0}(\varphi)},
   \overbrace{\pi_1, \cdots, \pi_1}^{count_{\pi_1}(\varphi)},
   \cdots \cdots
   \cdots,
   \overbrace{\pi_n,\cdots, \pi_n}^{count_{\pi_n}(\varphi)}.
   \]
  \end{definition}

  \begin{definition}
   A singleton model is a model of the form $R(\varphi, \sigma(\varphi,
   \pi))$. We abbreviate this to $R(\varphi, \pi)$.

   For a singleton model and an index $k\in I$, $w_k$ denotes the minimum external
   observer state above all $\pi_j$~states for $j< k$.
  \end{definition}

  \begin{definition}
   For a waitfree protocol description $\varphi = \bigwedge_{a\in A}
   \overbrace{K_a K_\memory K_a \cdots K_a}^{n_a}
   I_a$, we define the restriction \\
   $\varphi\restriction_{p,k} =
   \bigwedge_{a\in A\restriction_{p,k}} \overbrace{K_a K_\memory K_a \cdots K_a}^{n_a} I_a$,
   where $A\restriction_{p,k} = \{a\mid p_j = a \mbox{ for some
   } j<
   k\}$.
  \end{definition}

  \begin{lemma}
   \label{stronger}
   $R(\varphi, \pi), (o,k)\models \psi\Longrightarrow SC(\pi, k)\vdash
   \varphi\restriction_{\pi,k}\supset\psi$.
  \end{lemma}
  Proof to be found in the author's Master's thesis.

  Any models induced by a partial schedule is finite.  For a waitfree assertion $\varphi$,
  it is decidable whether $\vdashsc \varphi$ holds or not.


  \subsection{Decidability of Solvability of Waitfree Task Specification}

  \begin{definition}
   A waitfree task specification $\psi$ is solvable if there is such a
   waitfree protocol description $\varphi$ that the relation
   $R(\varphi,\sigma), (o,n)\models\psi$ holds for any compatible partial
   schedule $\sigma$ where the state $(o,n)$ is the last state of the
   model $R(\varphi,\sigma)$.
  \end{definition}

  \noindent \textbf{Fact.} The set of solvable waitfree task specifications are
  recursively enumerable because the relation $\vdashsc$ is axiomatised.

  \noindent \textbf{Fact.} The set of unsolvable waitfree task
  specifications are recursively enumerable because partial schedule-induced
  models are recursively enumerable.

  \begin{theorem}
   \label{wf-dec}
   It is decidable whether a waitfree task
   specification is solvable or not.
  \end{theorem}
  \begin{proof}
   These two facts imply that it is decidable whether a waitfree task
   specification is solvable or not.
  \end{proof}

  This does not contradict to the undecidability
  of waitfreely solvable tasks by Gafni and
  Koutsoupias~\cite{gafni1999three}
  because the undecidability proof
  utilises tasks that cannot be expressed by waitfree task specifications.
  They use tasks involving consensus:
  the tasks involving making agreements among processes, where
  whether an output value is allowed or not depends on other processes'
  output values.  Waitfree task specifications cannot describe such tasks.

 \section{Finite Model Property for Sequential Consistency Logic}


 We proved finite model property for sequential consistency logic
 using analytic tableaux.
 The target logic have Kripke frames where modalities are interpreted as
 functions over the frame.  Moreover, each logic is parametrized by a
 set of restrictions.  Each restriction is a disjunction of some
 inequalities posing restrictions on the shape of the frame.

 The target class of intermediate modal logics is a generalization of
 intuitionistic epistemic logic proposed by Hirai~\cite{hirailpar}.
 He used intuitionistic epistemic logic in order to model shared memory
 consistencies, which are criteria that guarantees levels of
 synchronization among different processes.
 Both shared memory consistencies and some intermediate modal logics
 can be characterized as a restriction on
 partially-ordered structure:
 Kripke frames for intermediate modal logics
 and executions for shared memory
 consistencies~\cite{steinke2004unified}.
 He regarded Kripke frames as executions in order to translate
 an intermediate modal logic into a shared memory
 consistency.

 However, he did not show finite model property for those
 intermediate modal logics.  When software engineers talk about shared
 memory consistencies, they assume an execution is finite.
 When we think of Kripke models as executions, we are obliged to show
 that the model is finite.
 Especially when we want to construct a specific counterexample execution,
 we have to build a \textit{finite} Kripke model.

 For example,
 under \textit{sequential consistency logic}, which is intuitionistic epistemic
 logic along with the axioms of the form
 $(K_m\varphi\supset K_m\psi) \vee (K_m\psi\supset K_m\varphi)$,
 the formula $K_aK_mK_aI \supset K_bK_mK_bJ\supset K_bI$ is not a
 theorem.
 In terms of shared memory consistency, this means that even when a
 process~$a$ has put information~$I$ on the shared memory and got a
 successful acknowledgement from the shared memory and the other
 process~$b$ does the same with information~$J$, it is not always the
 case that process~$b$ has obtained information~$I$\kern -2pt.
 In other words, there are executions without this property.
 This can be confirmed via
 finite model property for sequential consistency logic.
 We show this property in a generalized form.

  \subsection{The Target Logics}
  \label{logic}

  The class of logics that we consider is a generalization of
  intuitionistic propositional logic.
  The class of logics also contains G\"{o}del--Dummett logic~\cite{dummett59}
  and the intuitionistic epistemic logic proposed by
  Hirai~\cite{hirailpar}.
  Let us assume that
  there are a countably infinite set~$\pvar$ of \textit{propositional variables} and a
  finite set~$\agents$ of \textit{agents}.

  \begin{definition}
   We define the set~$\fml$ of formulae by BNF:
   \[
   \varphi,\psi ::= \bot\mid I\mid K_a\varphi\mid (\varphi\vee\psi)\mid
   (\varphi\land\psi)\mid (\varphi\supset\psi)
   \]
   where $a$ is an agent in $\agents$
   and $I$ is a propositional variable in~$\pvar$.
  \end{definition}

  For a set of formulae $\Gamma\!$, notation $K_a\Gamma$ denotes the set
  $\{K_a\varphi\mid\varphi\in\Gamma\}$\enspace.

  \begin{definition}[Kripke frame]
   A \textit{frame} $\tuple{W,\preceq,(f_a)_{a\in \agents}}$ is a tuple where
   \begin{itemize}
    \item $\tuple{W,\preceq}$ is a partially ordered set, and
    \item each $f_a\colon W\rightarrow W$ is a monotonic function with
	  respect to~$\preceq$.
   \end{itemize}
  \end{definition}

  \begin{definition}[Kripke model]
   A \textit{model} $\tuple{W,\preceq, (f_a)_{a\in \agents},\rho}$ is a tuple where
   \begin{itemize}
    \item $\tuple{W,\preceq,(f_a)_{a\in \agents}}$ is a frame, and
    \item $\rho\colon \pvar\rightarrow 2^W$ is a function that maps every
	  propositional variable to a upward-closed subset of $W\!$.
   \end{itemize}
  \end{definition}

  We are going to prove finite model property for a class of
  intermediate modal logics.  The logics are parametrized with
  world restriction sets,  which we are going to define.
  We assume that there is a countably infinite set of \textit{world
  variables}~$\wvar$.
  We use $\mathsf v, \mathsf w,\ldots$ to denote world variables.
  We define \textit{world terms} using BNF:
  \[
  \mathsf s::=\mathsf v\mid \mathsf s.a
  \]
  where $a$ is an agent.
  Every world term can be written as $\mathsf v.s$ where $s$ is a fintie sequence
  of agents (a postfix).
  A \textit{world inequality} is an inEquation of the form $\mathsf s\le
  \mathsf t$ where $\mathsf s$ and $\mathsf t$ are world terms.
  \begin{definition}
   A world restriction is a sequence of world inequalities jointed
   by~$\wor$ formed like
   $\mathsf v_0.s_0\le\mathsf v_1.t_1\wor\cdots\wor
   \mathsf v_{n-1}.s_{n-1}\le\mathsf v_n.t_n\wor \mathsf v_n.s_n\le\mathsf
   v_0.t_0$ that satisfies either
   \begin{itemize}
    \item (single clause) $n=0$, or
    \item (single postfix) $s_i = t_i = s_j = t_{j}$ for $0\le i,j\le n$.
   \end{itemize}
  \end{definition}
  A \textit{world restriction set} is a finite set of world restrictions.

  A \textit{world valuation} maps a world variable into a world of a frame.
  We extend a world valuation on world variables
  $\delta\colon\mathcal V_W\rightarrow W$ to that on world terms
  inductively as $\delta(\mathsf s.a)=f_a(\delta(\mathsf s))$.
  A frame $\tuple{W,\preceq, 1,(f_a)_{a\in\agents}}$ satisfies a world inequality
  $\mathsf s\le\mathsf t$ iff $\delta(\mathsf s)\preceq \delta(\mathsf t)$
  for all $\delta\colon\mathcal V_W\rightarrow W$.
  A frame~$F$ satisfies a world restriction $\mathsf r$
  iff $M$ satisfies $\delta(\mathsf r)$ for any world valuation~$\delta$.
  For example, a frame satisfies $\mathsf v\le \mathsf w\wor\mathsf
  w\le\mathsf v$ iff the frame is totally ordered.
  An $\mathsf R$-frame is a frame that
  satisfies all world restrictions in~$\mathsf R$.
  An $\mathsf R$-model is a model with an $\mathsf R$-frame.


  \begin{definition}
   We define the \textit{validity relation} $M,w\models\varphi$ over a model
   $M = \tuple{W,\preceq,(f_a)_{a\in \agents},\rho}$, a state~$w\in W$ and a
   formula~$\varphi$ inductively on $\varphi$.
   In this definition, let
   us abbreviate $M,w\models \varphi$ into $w\models \varphi$\enspace.
   \newcommand{\m}{}
   \begin{itemize}
    \item $w\models \bot$ never holds.
    \item $w\models I$ iff
	  $w \in
	  \rho(I)$.
    \item	    $w\models K_a \psi$ iff
		    $f_a(w)\models \psi$.
    \item $w\models \psi_0\land\psi_1$ iff both
	  $w\models \psi_0$ and $w\models \psi_1$ hold.
    \item
	 $ w\models \psi_0\vee\psi_1$ iff either
	 $ w\models \psi_0$ or $w\models \psi_1$ holds.
    \item
	 $w\models \psi_0\supset\psi_1$ iff
	 $w'\succeq w$ and $w'\models \psi_0$ imply
	 $w'\models\psi_1$ for any $w'\in W$\enspace.
   \end{itemize}
  \end{definition}
  A model~$M$ \textit{satisfies} $\varphi$ iff $M,w\models\varphi$ holds for any
  state~$w$ of~$M$.
  A formula~$\varphi$ is \textit{valid under} $\mathsf R$ iff
  every $\mathsf R$-model~$M$ satisfies $M\models \varphi$.
  For this, we write $\modelsR \varphi$\enspace.

  \begin{lemma}[Kripke monotonicity]
   \label{monot}
   $M,w\models\varphi$ and $w\preceq v$ imply
   $M,v\models\varphi$.
  \end{lemma}
  \begin{proof}
   Induction on~$\varphi$.
   We use monotonicity of $f_a$ here.
  \end{proof}

    \paragraph{The proof system.}
    Since both $\pvar$ and $\wvar$ are countably infinite,
    there is an injection that maps a world variable to a propositional
    variable.
    We fix one such injection
    $\mathsf w\mapsto I_{\mathsf w}$.
    Inductively on the construction of world terms,
    we assign a formula~$[\mathsf t]$ to every world term~$\mathsf t$:
    \begin{itemize}
     \item for a world term $\mathsf w\in \wvar$, we define $[\mathsf w]$ to be
	   $I_{\mathsf w}$,
     \item for a world term $\mathsf{s.a}$, we construct
	   a formula $[\mathsf{s.a}]$ by
	   replacing every propositional variable~$P$ with $K_aP$ in $[\mathsf s]$.
    \end{itemize}
    Note that the sequence $\mathsf{.a.b.c}$ is translated into the same
    order $K_a K_b K_c$ although a postfix is translated into a prefix.
    We define $K_s\varphi$ as $[\mathsf w.s][\varphi/I_{\mathsf w}]$.
    Also, we define $f_b\circ f_a$ as $f_{ab}$.  This ensures $M, w\models
    K_s\varphi\Leftrightarrow M,f_s(w)\models\varphi$.

    This translation of world terms into formulae
    enables us to translate world inequalities and world restrictions
    into formulae:
    \begin{itemize}
     \item $[\mathsf s\le \mathsf t] := [\mathsf s]\supset [\mathsf t]$, and
     \item $[\mathsf{s_0}\le \mathsf{t_0}\wor \cdots\wor \mathsf{s_n}\le \mathsf{t_n}] := [\mathsf{s_0}\le \mathsf{t_0}]\vee
	   \cdots \vee [\mathsf{s_n}\le \mathsf{t_n}]$ \enspace.
    \end{itemize}

    We define $\mathbf{Ax}(\mathsf R)$ to be the substitution closure of
    $\{[\mathsf r]\mid \mathsf r\in \mathsf R\}$.
    The substitution closure of a set~$S$ of formulae is defined as
    $\{\varphi[\psi/P]\}$ where $\psi$ run freely on~$\fml$ and $P$ on~$\pvar$.

    \begin{figure}[t]
     \begin{center}
      \def\fCenter{\vdashR}
      \AxiomC{}
      \LeftLabel{(axiom)}
      \UnaryInf$\varphi \fCenter \varphi$
      \DisplayProof
      \hfill
      \Axiom$\Gamma\fCenter\varphi$
      \LeftLabel{(weakening)}
      \UnaryInf$\psi,\,\Gamma\fCenter\varphi$
      \DisplayProof
      \hfill
      \Axiom$ \varphi,\,\varphi,\,\Gamma\fCenter\psi$
      \LeftLabel{(contraction)}
      \UnaryInf$\varphi,\,\Gamma\fCenter\psi$
      \DisplayProof
      \ruleskip
      \Axiom$\Gamma, \varphi,\psi,\, \Gamma'\fCenter\theta$
      \LeftLabel{(exchange)}
      \UnaryInf$\Gamma,\,\psi,\varphi,\,\Gamma'\fCenter\theta$
      \DisplayProof
      \hfill
      \Axiom$\Gamma\fCenter\varphi$
      \Axiom$\Gamma'\fCenter\psi$
      \LeftLabel{($\wedge$-I)}
      \BinaryInf$\Gamma,\Gamma'\fCenter \varphi\land\psi$
      \DisplayProof
      \hfill
      \Axiom$\Gamma\fCenter \varphi$
      \LeftLabel{($\vee$-I$_0$)}
      \UnaryInf$\Gamma\fCenter \varphi\vee\psi$
      \DisplayProof
      \ruleskip
      \Axiom$\Gamma\fCenter \varphi$
      \LeftLabel{($\vee$-I$_1$)}
      \UnaryInf$\Gamma\fCenter \psi\vee\varphi$
      \DisplayProof
      \hfill
      \Axiom$\Gamma \fCenter\varphi\land\psi$
      \LeftLabel{($\wedge$-E$_0$)}
      \UnaryInf$\Gamma\fCenter \varphi$
      \DisplayProof
      \hfill
      \Axiom$\Gamma\fCenter \varphi\land\psi$
      \LeftLabel{($\wedge$-E$_1$)}
      \UnaryInf$\Gamma\fCenter \psi$
      \DisplayProof
      \ruleskip
      \Axiom$\Gamma\fCenter \psi_0\vee\psi_1$
      \Axiom$\Gamma,\,\psi_0\fCenter \varphi$
      \Axiom$\Gamma,\,\psi_1\fCenter \varphi$
      \LeftLabel{($\vee$-E)}
      \TrinaryInf$\Gamma\fCenter \varphi$
      \DisplayProof
      \vskip 5mm
      \Axiom$\varphi,\,\Gamma\fCenter\psi$
      \LeftLabel{($\supset$-I)}
      \UnaryInf$\Gamma\fCenter \varphi\supset\psi$
      \DisplayProof
      \hfill
      \Axiom$\Gamma\fCenter\psi_0\supset\psi_1$
      \Axiom$\Gamma\fCenter \psi_0$
      \LeftLabel{($\supset$-E)}
      \BinaryInf$\Gamma\fCenter \psi_1$
      \DisplayProof
      \hfill
      \Axiom$\Gamma\fCenter\bot$
      \LeftLabel{($\bot$-E)}
      \UnaryInf$\Gamma\fCenter\varphi$
      \DisplayProof
      \ruleskip
      \AxiomC{}
      \LeftLabel{($\vee K$)}
      \UnaryInf$K_a(\varphi\vee\psi)\fCenter (K_a \varphi)\vee K_a\psi$
      \DisplayProof
      \hfill
      \AxiomC{}
      \LeftLabel{($\varphi\in \mathbf{Ax}(\mathsf R)$)}
      \UnaryInf$\fCenter\varphi$
      \DisplayProof
      \ruleskip
      \Axiom$\Gamma\fCenter\varphi$
      \LeftLabel{(necessitation)}
      \UnaryInf$K_a\Gamma\fCenter K_a\varphi$
      \DisplayProof
     \end{center}
     \caption{Deduction rules of $\vdashR$.}
     \label{figR}
    \end{figure}

    \begin{definition}
     We define the proof system $\vdashR$ by Fig.~\ref{figR}.
    \end{definition}

    \begin{theorem}
     \label{sound-comp-nat-kripke}
     $\Gamma\vdashR\varphi\Longleftrightarrow\Gamma\modelsR \varphi$\enspace.
    \end{theorem}
    \begin{lemma}[Soundness]
     $\Gamma\modelsR\varphi\Longleftarrow\Gamma\vdashR\varphi$
    \end{lemma}
    \begin{proof}
     We show $\Gamma\modelsR\varphi$ inductively
     on the definition of $\Gamma\vdashR\varphi$.
     \begin{description}
      \item[(Case {Ax})]
	   Suppose $\varphi\in \mathsf{Ax}(R)$.
	   For an $\mathsf{R}$-model~$M$ and a state~$w$ of~$M$,
	   we are going to show $M,w\models\varphi$.
	   Seeking contradiction,
	   we assume $M,w\not\models\varphi$.
	   Since $\varphi\in\mathsf{Ax}(R)$, there exists a world
	   restriction $\mathsf r\in\mathsf R$ with
	   $\varphi=[\mathsf r]\theta$,
	   where $\theta$ is a substitution.
	   Let $\mathsf r$ be
	   $\mathsf v_0.s_0\le\mathsf v_1.t_1\wor\cdots\wor
	   \mathsf v_{n-1}.s_{n-1}\le\mathsf v_n.t_n\wor\mathsf
	   v_n.s_n\le\mathsf v_0.t_0$.
	   Then,
	   $\varphi = (K_{s_0}\varphi_0\supset
	   K_{t_1}\varphi_1)\vee\cdots\vee
	   (K_{s_{n-1}}\varphi_{n-1}\supset K_{t_n}\varphi_n)
	   \vee (K_{s_n}\varphi_n\supset K_{t_0}\varphi_0)$
	   for some $(\varphi_i)_{0\le i\le n}$.
	   We define $\varphi_{n+1}$ to be $\varphi_0$ and
	   $\varphi_{-1}$ to be $\varphi_n$.
	   By assumption, $M,w\not\models K_{s_i}\varphi_i\supset
	   K_{t_{i+1}}\varphi_{i+1}$ for any $0\le i\le n$.
	   This implies existence of a sequence
	   $(v_i)_{0\le i\le n}$ of states with $w\preceq v_i$ and
	   $M,v_i\models K_{s_i}\varphi_i$ but $M,v_i\not\models
	   K_{t_{i+1}}\varphi_{i+1}$.
	   By the semantics of modalities, we have
	   $M,f_{s_i}(v_i)\models \varphi_i$ but $M,
	   f_{t_{i+1}}(v_i)\not\models\varphi_{i+1}$
	   for any $0\le i\le n$.
	   When $\mathsf r$ is single clause,
	   $\mathsf r = \mathsf v.s\le\mathsf v.t$.
	   Let $\delta(\mathsf v)$ be $v_0$.
	   Since $M$ is an $\mathsf R$-model,
	   $f_s(v_0)\preceq f_t(v_0)$ holds.
	   Since $n=0$,
	   we have $M,v_0\models K_s\varphi_0$ but $M,v_0\not\models
	   K_t\varphi_0$.
	   This contradicts Kripke monotonicity.
	   Otherwise, when $\mathsf r$ is single postfix,
	   $\mathsf r = \mathsf v_0.s\le\mathsf
	   v_1.s\wor\cdots\wor\mathsf v_{n-1}.s\le\mathsf
	   v_n.s\wor\mathsf v_n.s\le\mathsf v_0.s$.
	   Let $\delta(\mathsf v_i)$ be $v_{n-i}$.
	   Since $M$ is an $\mathsf R$-model,
	   for some $0\le i\le n$,
	   we have $\delta(\mathsf v_i.s)\preceq \delta(\mathsf
	   v_{i+1}.s)$.
	   This is equivalent to $f_s(v_{n-1})\preceq f_s(v_{n-i-1})$.
	   The way we took $(v_i)_{0\le i\le n}$ ensures
	   $M,v_{n-1}\models K_s\varphi_{n-i}$.
	   In other words, $M,f_s(v_{n-1})\models \varphi_{n-i}$.
	   By Kripke monotonicity, $M,f_s(v_{n-i-1})\models
	   \varphi_{n-i}$.
	   This contradicts $M,f_s(v_{n-i-1})\not\models\varphi_{n-1}$.
      \item[(Other rules)]
	   Straightforward.
     \end{description}
    \end{proof}

   \subsubsection{Examples}

    \paragraph{Classical logic.}
    When
    $\mathsf R = \{\mathsf v\le\mathsf w\wor\mathsf w\le\mathsf x\wor\mathsf x\le\mathsf
    v\}$,
    the corresponding axioms can be obtained as follows:
    \begin{align*}
     [ \mathsf v\le \mathsf w\wor \mathsf w\le\mathsf x\wor \mathsf x\le\mathsf v ] &=
     (I_{\mathsf v}\supset I_{\mathsf w})\vee (I_{\mathsf w}\supset
     I_{\mathsf x})\vee (I_{\mathsf x}\supset I_{\mathsf v})
     \\
     \mathbf{Ax}(\mathsf R) = \mathbf{Ax}(\{\mathsf v\le\mathsf w\wor \mathsf
     w\le \mathsf x \wor \mathsf x\le\mathsf v\}) &= \{(\varphi\supset\psi)\vee(\psi\supset\chi)\vee(\chi\supset\varphi)\}.
    \end{align*}
    $\mathbf{Ax}(\mathsf R)$ is equivalent to the excluded middle so $\mathsf R$ defines
    classical logic.

    \paragraph{G\"{o}del--Dummett logic.}
    When $\mathsf R=\{\mathsf v\le\mathsf w\wor\mathsf w\le\mathsf v\}$,
    the corresponding axioms can be obtained as follows:
    \begin{align*}
     [\mathsf v\le \mathsf w\wor \mathsf w\le\mathsf v] &=
     (I_{\mathsf v}\supset I_{\mathsf w})\vee (I_{\mathsf w}\supset
     I_{\mathsf v})\\
     \mathbf{Ax}(\mathsf R) = \mathbf{Ax}(\{\mathsf v\le\mathsf w\wor \mathsf
     w\le \mathsf v\}) &= \{(\varphi\supset\psi)\vee(\psi\supset\varphi)\mid
     \varphi,\psi\colon\mbox{formula}\}.
    \end{align*}
    $\mathbf{Ax}(\mathsf R)$ coincides with the axioms of
    G\"{o}del--Dummett logic~\cite{dummett59}.

    \paragraph{Sequential consistency logic.}
    When $\mathsf R=\{\mathsf v.\mathsf m\le\mathsf w.\mathsf m\wor \mathsf
    w.\mathsf m\le \mathsf v.\mathsf m\}$,
    the corresponding set of axioms
    $\mathbf{Ax}(\mathsf R) = \{(K_{\mathsf m}\varphi\supset K_{\mathsf
    m}\psi)\vee(K_{\mathsf m}\psi\supset K_{\mathsf m}\varphi)\mid \varphi,
    \psi\colon\mbox{formula}\}$
    axiomatizes sequential consistency logic,
    which is proposed by Hirai~\cite{hirailpar} for modeling a shared memory consistency called sequential consistency.


  \subsection{Finite Model Property}
  \label{fmp-proof}

  This is our main result.
  \begin{theorem}
   \label{thm:fmp}
   $\vdashR\varphi$ holds iff $M\models \varphi$ holds
   for all finite {\sf R}-model $M$.
  \end{theorem}

  We use another deduction system\,\LB\,in order to obtain finite model
  property.
  The outline of the proof is these circular implications:
  \begin{align*}
   \vdashRLB\varphi &\Longrightarrow \quad \models_{\mathsf R}\varphi\quad
   &(\mbox{by Lemma~\ref{sound}})\\
   &\Longrightarrow \quad \vdash_{\mathsf R}\varphi &(\mbox{by
   Thm.~\ref{sound-comp-nat-kripke}}) \\
   &\Longrightarrow\quad \modelsR\varphi &\mbox{(by Thm.~\ref{sound-comp-nat-kripke})}\\
   &\Longrightarrow\quad M\models\varphi \mbox{ for any finite $\mathsf
   R$-model }M\\
   &\Longrightarrow\quad \vdashRLB\varphi & (\mbox{by
   Lemma~\ref{R-fmp}})\enspace .
  \end{align*}
  This method extends Waaler
  and Wallen's method for intuitionistic logic~\cite{waaler1999tableaux}.

   \subsubsection{\LB}

   The deduction system\,\LB\,uses \textit{prefixed formulae}.  A
   prefixed formula is shaped like $\mathsf s::\varphi$ where $\mathsf s $
   is a world term and $\varphi$ is a formula.
   Informally, this prefixed formula means that the formula~$\varphi$ is
   satisfied in a state referenced by~$\mathsf s$.
   A \textit{sequent} is shaped like
   $\Theta\parallel \Gamma\longrightarrow \Delta$ where
   $\Theta$ is a finite set of world inequalities and both
   $\Gamma$ and $\Delta$ are finite sets of prefixed formulae.
   In a sequent, world inequality
   $\mathsf s\le \mathsf s$ must be in $\Theta$
   for any world term $\mathsf s$ occurring in $\Delta$ or $\Gamma$.

   A set~$\Theta$ of world inequalities
   \textit{conforms to} world restriction set~$\mathsf R$ when all of the
   following hold:
   \begin{itemize}
    \item $\mathsf s\le \mathsf t, \mathsf t\le \mathsf u\in
	  \Theta\Longrightarrow
	  \mathsf s\le \mathsf u\in\Theta$,
    \item If $\mathsf{s_0}\le \mathsf{t_0} \wor \mathsf{s_1}\le \mathsf
	  {t_1}\wor
	  \cdots\wor \mathsf{s_n}\le
	  \mathsf{t_n}\in \bar{\mathsf R}$ and all of
	  $\mathsf{s_0},\mathsf{s_1},\ldots,\mathsf{s_n},
	  \mathsf{t_0},\mathsf{t_1},\ldots, \mathsf{t_n}$ appear in~$\Theta$, then,
	  $\mathsf{s_i}\le \mathsf{t_i}\in\Theta$ for at least
	  one~$\mathsf{i}$, where $\bar {\mathsf R}$ is the substitution
	  closure of~$\mathsf R$,
    \item If $\mathsf s\le\mathsf t\in\Theta$ and both $\mathsf s.a$ and
	  $\mathsf t.a$ appear in~$\Theta$, then $\mathsf s.a\le\mathsf
	  t.a\in \Theta$.
   \end{itemize}
   We define $\mathsf R(\Theta)$ to be the set of the minimal
   supersets of~$\Theta$ conforming to~$\mathsf R$.
   For example, when $\mathsf R=\{\mathsf w\le \mathsf v\wor\mathsf v\le \mathsf
   w\}$,
   $\mathsf R(\{\mathsf w\le \mathsf w, \mathsf v\le \mathsf v\}) =
   \{\{\mathsf w\le \mathsf v, \mathsf w\le \mathsf w, \mathsf v \le
   \mathsf v\}, \{\mathsf v \le
   \mathsf w, \mathsf w\le \mathsf w, \mathsf v\le \mathsf v\}\}$\enspace.
   When $\Theta$ is finite, so is $\mathsf R(\Theta)$ because $\mathsf
   R(\Theta)\subseteq \{\mathsf s\le\mathsf
   t\mid\mathsf s,\mathsf t\mbox{ appears in }\Theta\}$.

   \begin{definition}
    The calculus\,\LB\,for a world restriction set~$\mathsf R$ is defined in Fig.~\ref{LB}.
    When $\mathsf w\le \mathsf w\parallel \rightarrow \mathsf
    w::\varphi$ is provable in \LB\,for~$\mathsf R$,
    we write $\vdashRLB\varphi$.
   \end{definition}

   \begin{figure}[t]
    \def\fCenter{\longrightarrow}
    \small
    \begin{center}
     \ruleskip
     \Axiom$\Theta\parallel \Gamma\fCenter \mathsf s::\varphi,\Delta$
     \Axiom$\Theta\parallel \Gamma, \mathsf t::\psi \fCenter \Delta$
     \RightLabel{L$\supset$}
     \BinaryInf$\Theta, \mathsf s\le \mathsf t\parallel \Gamma, \mathsf t::\varphi\supset\psi
     \fCenter \Delta$
     \DisplayProof
     \ruleskip
     \Axiom$\Theta'\parallel \Gamma, \mathsf w::\varphi\fCenter
     \mathsf w::\psi,\Delta\quad\mbox{ for every }\Theta'\in \mathsf
     R(\Theta\cup\{\mathsf s\le \mathsf w\})$
     \RightLabel{R$\supset$}
     \UnaryInf$\Theta\parallel \Gamma \fCenter \mathsf s::\varphi\supset\psi, \Delta$
     \DisplayProof\\ ($\mathsf w$ does not appear in the conclusion)
     \ruleskip
     \Axiom$\Theta'\parallel \Gamma, \mathsf s.a::\varphi\fCenter\Delta$
     \RightLabel{L$a$}
     \UnaryInf$\Theta\parallel \Gamma, \mathsf s::K_a\varphi\fCenter\Delta$
     \DisplayProof
     \hfill
     \Axiom$\Theta\parallel \Gamma\fCenter\Delta, \mathsf s.a::\varphi$
     \RightLabel{R$a$}
     \UnaryInf$\Theta\parallel\Gamma\fCenter\Delta, \mathsf s :: K_a\varphi$
     \DisplayProof
    \end{center}
    \caption[The inference rules of \LB.]
    {The inference rules of \LB. Modification of Fig.~3 of
    Waaler and Wallen~\cite{waaler1999tableaux}.
    Since $\mathsf R(\Theta\cup\{\mathsf s\le\mathsf w\})$ is finite,
    R$\supset$
    is finitely branching.}
    \label{LB}
   \end{figure}

   \begin{figure}[ht]
    \def\fCenter{\longrightarrow}
    \Axiom$\Theta,\mathsf v\le\mathsf x\parallel\mathsf v::\varphi,\mathsf
    x::\psi\fCenter\mathsf v::\psi,\mathsf x::\varphi$
    \Axiom$\Theta,\mathsf x\le\mathsf v\parallel\mathsf v::\varphi,\mathsf
    x::\psi\fCenter\mathsf v::\psi,\mathsf x::\varphi$
    \RightLabel{R$\supset$}
    \BinaryInf$\mathsf w\le\mathsf w,\mathsf w\le\mathsf v,\mathsf
    v\le\mathsf v\parallel\mathsf v::\varphi\fCenter\mathsf v::\psi,\mathsf
    w::\psi\supset\varphi$
    \RightLabel{R$\supset$}
    \UnaryInf$\mathsf w\le\mathsf w\parallel\fCenter\mathsf
    w::\varphi\supset\psi,\mathsf w::\psi\supset\varphi$
    \RightLabel{R$\vee$}
    \UnaryInf$\mathsf w\le\mathsf w\parallel\fCenter\mathsf
    w::(\varphi\supset\psi)\vee(\psi\supset\varphi)$
    \DisplayProof

    \caption[A derivation for
    $\vdashRLB(\varphi\supset\psi)\vee(\psi\supset\varphi)$.]
    {A derivation for
    $\vdashRLB(\varphi\supset\psi)\vee(\psi\supset\varphi)$ where
    $\mathsf R=\{\mathsf v\le\mathsf w,\mathsf w\le\mathsf v\}$.
    In the figure, $\Theta$ stands for $\{\mathsf w\le\mathsf w,\mathsf
    w\le \mathsf v, \mathsf v\le\mathsf v, \mathsf w\le \mathsf x, \mathsf
    x \le \mathsf x\}$. }
    \label{gdlb}
   \end{figure}

  \subsection{Soundness of LB}

  For a world valuation $\delta:\mathcal V_W\longrightarrow M$,
  we let $\delta(\Theta)$ denote a condition on
  model~$M$ stating $\delta(\mathsf s)\preceq \delta(\mathsf t)$ for any
  $\mathsf s\le \mathsf t\in\Theta$.
  Likewise, $\delta(\mathsf s::\varphi)$ is a condition stating
  $M,\delta(\mathsf s)\models\varphi$.  For a sequence~$\Gamma =
  (t_i::\varphi_i)_{i\in I}$ of
  prefixed formulae, $\delta(\Gamma)$ denotes the conjunction
  of $\delta(t_i::\varphi_i)$ taken over $i\in I$.
   We say a pair
   $\tuple{M,\delta}$ \textit{satisfies}
   $\Theta\parallel\Gamma\longrightarrow\Delta$ when $\delta(\Theta)$ and
   $\delta(\Gamma)$ implies $\delta(\varphi)$ for some $\varphi$
   in~$\Delta$.

   \begin{proposition}
    \label{exp-sound}
    If an $\mathsf R$-model satisfies $\delta(\Theta)$,
    the model satisfies $\delta(\Theta')$ for
    at least one element~$\Theta'$ of $\mathsf R(\Theta)$.
   \end{proposition}
   \begin{proof}
    Let $\Theta_M$ be the set of world inequalities
    $\{\mathsf s\le \mathsf t\mid M\mbox{
    satisfies }\delta(\mathsf s\le \mathsf t)\}$.
    The set $\Theta_M$ is clearly conforms to $\mathsf R$.
    By definition of $\mathsf R(\Theta)$, there exists at least one $\Theta'\in
    \mathsf R(\Theta)$ with $\Theta'\subseteq \Theta_M$.
    Since $M$ satisfies $\delta(\Theta_M)$, it satisfies $\delta(\Theta')$.
   \end{proof}

   \begin{lemma}
    \label{sound}
    If a sequent $\Theta\parallel \Gamma\longrightarrow \Delta$ is
    provable,
    then, for any $\mathsf R$-model $M$ and world valuation $\delta$,
    the pair~$\tuple{M,\delta}$ satisfies the sequent $\Theta\parallel
    \Gamma\rightarrow\Delta$.
   \end{lemma}
   \begin{proof}
    Induction on derivation trees.
    The case of R$\supset$ is tricky.
    Assume an $\mathsf R$-model~$M$ satisfies all elements of
    $\delta(\Theta)$ and $\delta(\Gamma)$ but no elements of $\delta(\Delta)$.
    In order to prove $M,\delta(\mathsf s)\models\varphi\supset\psi$, we
    arbitrarily take $w\in M$ with $ w\succeq \delta(\mathsf s)$ and assume $M,
    w\models\varphi$.
    Showing $M,w\models\psi$ is enough.
    Let $\mathsf w$ be a world variable which does not occur in~$\Theta$.
    We extend $\delta$ with $\mathsf{w}\mapsto w$ and call the extension~$\epsilon$.
    Since $M$ is an~$\mathsf R$-model,
    it satisfies $\delta(\Theta')$ for some $\Theta'\in \mathsf R(\Theta\cup
    \{\mathsf s\le \mathsf w\})$ by Prop.~\ref{exp-sound}.
    By induction hypothesis, $M$ satisfies some elements of $\epsilon(\Delta)$ or
    $\epsilon(\mathsf w::\psi)$. Since $\Delta$ does not contain~$\mathsf w$,
    $\epsilon(\Delta)$ is equivalent to $\delta(\Delta)$, of which no elements are
    satisfied by~$M$.
    Thus, $M$ satisfies $\epsilon(\mathsf w::\psi)$.
    Since $\epsilon(\mathsf w) = w$, this means $M,  w\models\psi$.
   \end{proof}

  \subsection{Finite Model Property of LB}
  \label{fmplb}

  \begin{figure}[t]
   \small
   \begin{center}
    \def\fCenter{\longrightarrow}
    \Axiom$\Theta\parallel\Gamma\fCenter\mathsf t::\varphi,\quad \Delta$
    \RightLabel{R$\wedge_0$}
    \UnaryInf$\Theta\parallel\Gamma\fCenter \mathsf
    t::\varphi\land \psi,\quad \Delta$
    \DisplayProof
    \hfill
    \Axiom$\Theta\parallel\Gamma\fCenter \mathsf t:: \psi,\quad \Delta$
    \RightLabel{R$\wedge_1$}
    \UnaryInf$\Theta\parallel\Gamma\fCenter \mathsf
    t::\varphi\land\psi,\quad\Delta$
    \DisplayProof
    \ruleskip
    \Axiom$\Theta\parallel\Gamma,\quad \mathsf t::\varphi\fCenter\Delta$
    \RightLabel{L$\vee_0$}
    \UnaryInf$\Theta\parallel\Gamma,\quad \mathsf
    t::\varphi\vee\psi\fCenter \Delta$
    \DisplayProof
    \hfill
    \Axiom$\Theta\parallel\Gamma,\quad \mathsf t::\psi\fCenter\Delta$
    \RightLabel{L$\vee_1$}
    \UnaryInf$\Theta\parallel\Gamma,\quad \mathsf
    t::\varphi\vee\psi\fCenter\Delta$
    \DisplayProof
    \ruleskip
    \Axiom$\Theta\parallel\Gamma\fCenter\mathsf
    t::\varphi, \quad\mathsf t::\psi,\quad \Delta$
    \RightLabel{R$\vee$}
    \UnaryInf$\Theta\parallel\Gamma\fCenter\mathsf
    t::\varphi\vee\psi,\quad \Delta$
    \DisplayProof
    \hfill
    \Axiom$\mathsf s\ge \mathsf t,
    \Theta \parallel \Gamma, \quad\mathsf t:: \varphi\supset\psi
    \fCenter\mathsf s:: \varphi, \quad \Delta$
    \RightLabel{LC$\supset_0$}
    \UnaryInf$\mathsf s\ge \mathsf t,\Theta \parallel \Gamma, \quad
    \mathsf t::\varphi\supset\psi\fCenter \Delta$
    \DisplayProof
    \ruleskip
    \Axiom$\Theta\parallel\Gamma,\quad \mathsf
    t::\varphi,\quad \mathsf t::\psi\fCenter\Delta$
    \RightLabel{L$\wedge$}
    \UnaryInf$\Theta\parallel\Gamma,\quad \mathsf t::
    \varphi\land \psi\fCenter \Delta$
    \DisplayProof
    \hfill
    \Axiom$\Theta\parallel\Gamma,\quad\mathsf t::\psi\fCenter \Delta$
    \RightLabel{L$\supset_1$}
    \UnaryInf$\Theta\parallel\Gamma,\quad\mathsf
    t::\varphi\supset\psi\fCenter\Delta$
    \DisplayProof
    \ruleskip
    \Axiom$\Theta'\parallel\Gamma,\quad \mathsf w::\varphi\fCenter
    \mathsf w::\psi,\quad \Delta$
    \RightLabel{R$\supset$}
    \UnaryInf$\Theta\parallel\Gamma\fCenter \mathsf t::\varphi\supset\psi,\quad
    \Delta$
    \DisplayProof\\
    ($\Theta'\in \mathsf R(\Theta\cup \{\mathsf t\le
    \mathsf w\})$ and $\mathsf w$ does not appear in the conclusion)
    \ruleskip
    \Axiom$\Theta'\parallel \Gamma,\quad \mathsf s.a::\varphi\fCenter\Delta$
    \RightLabel{L$a$}
    \UnaryInf$\Theta\parallel \Gamma,\quad \mathsf s::K_a\varphi\fCenter
    \Delta$
    \DisplayProof
    \hfill
    \Axiom$\Theta'\parallel \Gamma\fCenter\Delta,\quad \mathsf s.a::\varphi$
    \RightLabel{R$a$}
    \UnaryInf$\Theta\parallel \Gamma\fCenter\Delta,\quad \mathsf s::K_a \varphi$
    \DisplayProof
    \\
    (in L$a$ and R$a$, $\Theta'\in \mathsf R(\Theta\cup \{\mathsf s.a\le\mathsf s.a\})$)
    \ruleskip
    \Axiom$\Theta\parallel\Gamma
    \fCenter \Delta$
    \RightLabel{LT}
    \UnaryInf$\Theta\parallel\Gamma,\quad
    \mathsf t::\varphi
    \fCenter\Delta$
    \DisplayProof
    \caption[The rules for refutation ladders.]
    {The rules for refutation ladders. A modified version of Fig.~6 of Waaler and
    Wallen~\cite{waaler1999tableaux} with additional world inequality sidenotes and
    prefixes.  The top of a refutation ladder can be any sequent.
    No rule is branching.  Comma separated notation $\Gamma,\quad \mathsf
    s::\varphi$ denotes the disjoint union $\Gamma\uplus \{\mathsf
    s::\varphi\}$ in this figure.
    }
    \label{refladder}
   \end{center}
  \end{figure}

  We are going to use yet another derivation called the refutation
  ladder in order to construct a finite model from an unprovable sequent.
  Refutation ladders have rules in Fig.~\ref{refladder}.
  If the assumption of a rule is unprovable, so is the conclusion of the rule.
  A refutation ladder is not branching.

  Not all ladders made of the rules in Fig.~\ref{refladder} are
  refutation ladders.
  There are some restrictions on the ladders.
  In order to describe the restrictions,
  we use a relation~$\prec$ between sequent occurrences in a ladder.
  Relation $T\prec S$ holds iff
  $S$ is above $T$, and
  at least one interleaving \textrm{R$\supset$} rule between $S$ and $T$
  has its left formula not introduced by thinning~(LT).
  \begin{definition}
   A \textit{refutation ladder} is a ladder made of the rules in
   Fig.~\ref{refladder} that satisfies
   \begin{description}
    \item[ (R1)] Thinning \textrm{(LT)} occurs only immediately above \textrm{R$\supset$} for the
	 left side formula of the \textrm{R$\supset$} occurrence.
    \item[ (R2)]
	 On the other hand, if an \textrm{R$\supset$} occurrence
	 for a formula
	 $\mathsf s::\varphi\supset\psi$ has $\mathsf t\le \mathsf s$
	 in the sidenote of the assumption and
	 $\mathsf t::\varphi$ in the left hand side of the assumption,
	 then,
	 there is a thinning just above the R$\supset$ introducing
	 $\mathsf w::\varphi$ where $\mathsf w$ is the world variable
	 introduced by the \textrm{R$\supset$} occurrence.
    \item[ (R3)]
	 If there are two \textrm{LC$\supset_0$} occurrences one above the
	 other.
	 Let $S$ be former occurrence's conclusion and $T$ be latter occurrence's
	 conclusion.
	 Then, $T\prec S$ holds.
    \item[ (R4)]
	 The conclusion of \textrm{R$\supset$} must not be a
	 possible conclusion of any other rule.
	 In other words, when building up a refutation ladder from
	 bottom to up, avoid using R$\supset$ whenever some other
	 rules are applicable.
    \item[ (R5)]
	 For every sequent $\Theta\parallel \Gamma\rightarrow\Delta$
	 in the ladder, $\Theta$ conforms to~$\mathsf R$.
   \end{description}
  \end{definition}
  A \textit{refutation ladder of a sequent}~$S$ is a refutation ladder
  with
  $S$ at the bottom.
  The conditions \textbf{(R2)} and \textbf{(R3)} ensure that every
  refutation ladder is finite~(Prop.~\ref{refladder-finite}).
  Some other conditions \textbf{(R1)} and \textbf{(R4)} ensure
  that thinning is not applied to non-atomic formulae.


  \begin{proposition}
   \label{refladder-finite}
   Every refutation ladder is finite.
  \end{proposition}
  \begin{proof}
   If a refutation ladder is infinite,
   it must contain infinitely many $\supset$LC$_0$ occurrences.
   By \textbf{(R3)}, there must also be infinitely many R$\supset$ rule
   occurrences.
   Moreover, by the definition of~$\prec$,
   those occurrences have left-side formula not
   introduced by thinning.
   The number of such formulae is not more than the number of subformulae
   in the endsequent because thinning occurs whenever it is possible as
   \textbf{(R2)} states.
  \end{proof}

  \begin{definition}
   A \textit{complete refutation ladder} of~$S$ is a refutation ladder which is
   \begin{itemize}
    \item maximal: not a proper sub-ladder of any
	  refutation ladder of~$S$
    \item open:
	  for any sequent~$\Theta\parallel \Gamma\longrightarrow \Delta$,
	  the prefixed formula~$\mathsf t::\bot$ is not contained in~$\Gamma$.
	  Either
	  $\mathsf t::\varphi\notin \Gamma$ or
	  $\mathsf s::\varphi\notin\Delta$ or $\mathsf t\le \mathsf s\notin
	  \Theta$.
   \end{itemize}
  \end{definition}

  We are going to show that
  if a sequent $S$ is not provable in\,\LB, then there is a complete
  refutation ladder of $S$, and then there is a finite counter model.

   \subsubsection{Existence of a Complete Refutation Ladder}

   \begin{lemma}\label{chooser}
    If a sequent~$S$ does not form a maximal refutation ladder by itself and
    every applicable rule to $S$ yields a provable
    sequent in \LB, then $S$ is provable in \LB.
   \end{lemma}
   \begin{proof}
    At least one rule is applicable to $S$ because the sequent does
    not form a maximal refutation ladder by itself. We split cases by the
    applicable rule.
    \begin{description}
     \item[ (Case L$\wedge$ R$\vee$ L$a$ R$a$)]
	  If the above is provable, then so is the below.
     \item[ (Case R$\wedge_0$)]
	  R$\wedge_1$ is also applicable.
     \item[ (Case R$\wedge_1$)]
	  In this case, we use the fact that R$\wedge_0$ is also
	  applicable.
	  Since $\Theta\parallel\Gamma\longrightarrow \mathsf t::\varphi, \Delta$ and
	  $\Theta\parallel\Gamma\longrightarrow \mathsf t::\psi,
	  \Delta$ are both provable in \LB,
	  $\Theta\parallel\Gamma\longrightarrow \mathsf
	  t::\varphi\land\psi$ is also provable in \LB.
     \item[ (Case L$\vee_0$ L$\vee_1$)]
	  Similar to the R$\wedge$ cases.
     \item[ (Case L$\supset_1$ Split)] Immediate.
     \item[ (Case LC$\supset_0$)]
	  L$\supset_1$ is also applicable.
     \item[ (Case R$\supset$)]
	  The rule is also applicable with any $\Theta'\in
	  \mathsf R(\Theta\cup\{\mathsf s\le \mathsf w\})$. Since every one of these is
	  provable in \LB,
	  the endsequent is also provable in \LB.
    \end{description}
   \end{proof}

   For a refutation ladder~$L$, we define a sequent $\cup L$ as
   the sequent $\left(\bigcup_i \Theta_i\right)\parallel \left(\bigcup_i \Gamma_i\right)\longrightarrow
   \left(\bigcup_i\Delta_i\right)$ where $i$ runs over
   each sequent $\Theta_i\parallel \Gamma_i\longrightarrow\Delta_i$
   occurring in~$L$.
   We say $L$ is \textit{unprovable} when $\cup L$ is.

   \begin{lemma}
    \label{comprefl}
    An unprovable sequent has a complete refutation ladder.
   \end{lemma}
   \begin{proof}
    Assume the sequent
    $S = \Theta\parallel \Gamma\longrightarrow\Delta$
    is unprovable.
    Let $L$ be the set of refutation ladders of~$S$ and
    let $\bar L$ be the set of maximal such refutation ladders.
    We collect unprovable refutation ladders in~$L$ and call them~$L_u$.
    Again, $\bar L_u$ denotes the maximal elements of~$L_u$.
    The ladder consisting of only~$S$ is an element of~$L_u$
    so that $L_u$ is not empty.
    Moreover, every refutation ladder in~$L_u$ is finite.
    These combined implies existence of maximal elements in $L_u$ so that $\bar L_u$ is not empty.
    By the contraposition of Lemma~\ref{chooser}, the set $\bar L_u$ is included in $\bar L$.
    Thus, there is an unprovable ladder~$l$ in~$\bar L$.
    Since $l$ is unprovable, $l$ is open.
    We can conclude that $l$ is a complete refutation ladder.
   \end{proof}


   \subsubsection{Constructing a Model from a Complete Refutation Ladder}

   \begin{definition}[Hintikka Sequent]
    A sequent $\Theta\parallel \Gamma\longrightarrow\Delta$ is $\mathsf R$-Hintikka
    iff
    \begin{enumerate}
     \item $\Theta$ conforms to $\mathsf R$.
     \item $\Gamma$ does not contain $\mathsf s::\bot$ for any world
	   term~$\mathsf s$.
     \item If $\mathsf s::P\in \Gamma$ and $\mathsf t::P\in\Delta$ for
	   some~$P\in\pvar$\!, then
	   $\Theta$ does not contain~$\mathsf s\le \mathsf t$.
     \item $\mathsf s::\varphi\land\psi\in\Gamma\Longrightarrow
	   \mathsf s::\varphi,\mathsf s::\psi\in\Gamma$
     \item $\mathsf s::\varphi\vee\psi\in\Gamma
	   \Longrightarrow \mathsf s::\varphi\in\Gamma$ or
	   $\mathsf s::\psi\in\Gamma$.
     \item If $\mathsf t::\varphi\supset\psi
	   \in\Gamma$ and $\mathsf s\ge t\in \Theta$,
	   then
	   either
	   $\mathsf t::\varphi\in\Gamma$ or
	   $\mathsf s::\psi\in\Delta$ hold.
     \item $\mathsf s::K_a\varphi\in\Gamma
	   \Longrightarrow \mathsf s.a::\varphi\in\Gamma$
     \item $\mathsf s::\varphi\land\psi
	   \in\Delta\Longrightarrow \mathsf
	   s::\varphi\in\Delta$
	   or $\mathsf s::\psi\in\Delta$.
     \item $\mathsf s::\varphi\vee\psi\in\Delta
	   \Longrightarrow \mathsf s::\varphi, \mathsf s::\psi\in
	   \Delta$.
     \item If $\mathsf s::\varphi\supset\psi\in\Delta\Longrightarrow$, then
	   there exists a world term $\mathsf t$ with $\mathsf
	   s\le \mathsf t\in\Theta$ such that
	   $\mathsf t::\varphi\in\Gamma$, $\mathsf t::\psi\in\Delta$.
     \item $\mathsf s:: K_a\varphi\in\Delta\Longrightarrow
	   \mathsf s.a::\varphi\in\Delta$.
    \end{enumerate}
   \end{definition}

   \begin{proposition}
    \label{Hsat}
    A $\mathsf R$-Hintikka sequent is satisfiable in a finite $\mathsf R$-model.
   \end{proposition}
   \begin{proof}
    \newcommand{\W}{WT(\Theta)}
    Let $\Theta\parallel \Gamma\longrightarrow\Delta$ be a Hintikka sequent.
    To construct a satisfying model, we use $\W$,
    which is the set of world
    terms occurring in~$\Theta$.
    We define a frame $\tuple{\W, \preceq, (f_a)_{a\in\agents}}$ with
    $\preceq$ being the relation $\{\tuple{\mathsf s,\mathsf t}\in
    \W\times \W\mid
    \mathsf s\le
    \mathsf t\in\Theta\}$ and
    $f_a(\mathsf s) = \mathsf s.a$ for $\mathsf s\in\W$\enspace.
    Since $\Theta$ conforms to $\mathsf R$,
    the tuple is actually an $\mathsf R$-frame.
    We define $\rho$ to be $\rho(P) =
    \{\mathsf s\in \W\mid
    \mbox{there exists a world term } \mathsf t \in \W \mbox{ such that }
    \mathsf t\le
    \mathsf s \in \Theta\mbox{
    and }\mathsf t::P\in \Gamma\}$.
    The tuple $\tuple{\W,\preceq,(f_a)_{a\in \agents},\rho}$ forms
    an $\mathsf R$-model because $\Theta$ conforms to $\mathsf R$.
    Moreover, by induction on $\varphi$, we can show both
    $\mathsf s::\varphi\in\Gamma\Longrightarrow M,\mathsf s\models\varphi$
    and
    $\mathsf s::\varphi\in\Delta\Longrightarrow M,\mathsf s\not\models\varphi$.
    Thus, the sequent $\Theta\parallel \Gamma\longrightarrow\Delta$ is satisfiable.
   \end{proof}

   \begin{proposition}
    \label{completehintikka}
    For a complete refutation ladder~$L$,
    $\cup L$ is a Hintikka sequent.
   \end{proposition}
   \begin{proof}
    By openness, maximality and rules \textbf{(R3)}, \textbf{(R4)}.
   \end{proof}

   \begin{lemma}
    \label{R-fmp}
    If $\vdashR\varphi$  does not hold, there exists a finite $\mathsf
    R$-model~$M$ with $M\not\models\varphi$.
   \end{lemma}
   \begin{proof}
    Assume $\not\vdashR\varphi$.
    By soundness of \LB,
    the sequent $\mathsf w\le\mathsf w\parallel \longrightarrow\varphi$ is not
    provable in \LB.
    By Lemma~\ref{comprefl},
    there is a complete refutation ladder~$L$ for the sequent.
    By Prop.~\ref{completehintikka},
    $\cup L = L$  forms a Hintikka
    sequent.
    Moreover,
    the union $\bigcup_i\Theta_i$ conforms to~$\mathsf
    R$.
    Thus, when we construct a model from $\cup L$ with the method described in
    the proof of Prop.~\ref{Hsat},
    we obtain a finite $\mathsf R$-model.
    Moreover, the state $\mathsf w$ of the model does not satisfy~$\varphi$.
   \end{proof}
   Now we can carry out the proof strategy for Thm.~\ref{thm:fmp} described
   at the beginning of Sect.~\ref{fmp-proof}.

  \subsection{Application to Sequential Consistency Logic}

  Sequential consistency logic can be defined with the following world
  restrictions:
  \begin{itemize}
   \item $\mathsf v.a\le\mathsf v.a.a$ for all $a\in\agents$,
   \item $\mathsf v.a\le\mathsf v$ for all $a\in\agents$,
   \item $\mathsf v.m\le\mathsf w.m$ where $m\in\agents$ is a special
	 agent called shared memory.
  \end{itemize}

  Let us consider a formula $K_a K_m K_a P\supset K_a K_m K_b Q\supset
  (K_a Q\wedge K_b P)$.
  Informally, this formula means that whenever processes $a$ and $b$ have
  made a round-trip communication with the shared memory, each process is
  guaranteed to have received the other process's initial knowledge (with
  an assumption a message carries all of sender's knowledge).
  We can build a countermodel for this formula by the method described in
  this paper, by building
  a complete refutation ladder for the formula~(Fig.~\ref{compex})
  \begin{figure}
   \tiny
   \def\fCenter{\longrightarrow}
   \begin{center}
    \Axiom$cl(\Theta_2, \mathsf x.b.m.b\le\mathsf x.b.m, \mathsf
    x.a\le\mathsf x)\parallel\mathsf v.a.m.a::P, \mathsf
    x.b.m.b::Q\fCenter \mathsf x.a::Q$
    \RightLabel{R$a$}
    \UnaryInf$cl(\Theta_2,\mathsf x.b.m.b\le\mathsf x.b.m)\parallel\mathsf
    v.a.m.a::P, \mathsf x.b.m.b::Q\fCenter\mathsf x::K_a Q$
    \RightLabel{R$\wedge_0$}
    \UnaryInf$cl(\Theta_2, \mathsf x.b.m.b\le\mathsf
    x.b.m)\parallel\mathsf v.a.m.a::P, \mathsf x.b.m.b::Q\fCenter\mathsf
    x::K_a Q\wedge K_a P$
    \RightLabel{L$b$}
    \UnaryInf$\Theta_2=cl(\Theta_1,\mathsf x.b\le\mathsf x,\mathsf
    x.b.m\le\mathsf x.b,\mathsf v.a.m\le\mathsf x.b.m)\parallel\mathsf
    v.a.m.a::P, \mathsf x.b.m::K_b Q\fCenter \mathsf x::K_a Q\wedge K_b P$
    \RightLabel{L$b$}
    \UnaryInf$cl(\Theta_1, \mathsf x.b\le\mathsf x)\parallel
    \mathsf v.a.m.a::P, \mathsf x.b::K_m K_b Q\fCenter x::K_a Q\wedge K_b
    P$
    \RightLabel{L$b$}
    \UnaryInf$\Theta_1=cl(\Theta_0,\mathsf v\le\mathsf x, \mathsf
    v.a.m.a\le \mathsf v.a.m)\parallel\mathsf v.a.m.a::P, \mathsf x::K_b
    K_m K_b Q\fCenter x::K_a Q\land K_b P$
    \RightLabel{R$\supset$}
    \UnaryInf$cl(\Theta_0,\mathsf v.a.m.a\le\mathsf v.a.m)\parallel
    \mathsf v.a.m.a::P\fCenter \mathsf v:: K_b K_m K_b Q\supset (K_a
    Q\land K_b P)$
    \RightLabel{L$a$}
    \UnaryInf$\Theta_0=cl(\mathsf w\le\mathsf v, \mathsf v.a\le\mathsf v,
    \mathsf v.a.m\le\mathsf v.a)\parallel\mathsf v.a.m::K_a P\fCenter
    \mathsf v::K_b K_m K_b Q\supset (K_a Q\land K_b P)$
    \RightLabel{L$a$}
    \UnaryInf$cl(\mathsf w\le\mathsf v, \mathsf v.a\le\mathsf
    v)\parallel\mathsf v.a::K_m K_a P\fCenter \mathsf v::K_b K_m K_b
    Q\supset (K_a Q\land K_b P)$
    \RightLabel{L$a$}
    \UnaryInf$cl(\mathsf w\le\mathsf v)\parallel \mathsf v:: K_a K_m K_a P
    \fCenter \mathsf v:: K_b K_m K_b Q\supset (K_a Q\land K_b P)$
    \RightLabel{R$\supset$}
    \UnaryInf$\mathsf w\le \mathsf w\parallel\fCenter \mathsf w:: K_a K_m K_a
    P\supset K_b K_m K_b Q\supset (K_a Q\land K_b P)$
    \DisplayProof
   \end{center}
   \caption[A complete refutation ladder for the \fix{which} considered formula.]
   {A complete refutation ladder for the considered formula.
   $cl(\Theta)$ denotes the reflexive transitive closure of~$\Theta$.}
   \label{compex}
  \end{figure}


 \section{Related Work}

    \paragraph{Work on intuitionistic modal logics.}

    Amati and Pirri~\cite{amati94} presented a uniform tableau method for a number of
    intuitionistic modal logics whose language contains two modalities
    $\square$ and $\lozenge$.
    However, they did not consider the functional modality where the two
    modalities coincide.  Nor did they consider the multimodal case.
    Their uniform tableau method uses boxes around some sequents of the
    tableaux.  This boxing method does not trivially encode our tableaux since our
    tableau method utilizes sequents whose different formulae are prefixed
    with different world terms.

    Baldoni, Giordano and Martelli~\cite{baldoni98} presented a tableau
    calculus for a class of multimodal logics called grammar logics.
    Their method is similar to our method in that worlds are denoted by
    variables and the relationship between the worlds are kept as a
    sidenote.
    However, their method does not parametrize logics with conditions involving
    disjunction while our method parametrizes logics with conditions
    involving $\wor$.

    \paragraph{Work on intermediate logics.}

    Sonobe~\cite{sonobe} gave a Gentzen-style formulation of some
    intermediate logics, the simplest of which is G\"{o}del--Dummett logic.
    He wrote his result ``was first obtained by way of tableau method.''
    Thus both Sonobe's and our method contain a tableau formalization for
    G\"{o}del--Dummett logic.  However, there are some differences even when
    we compare Sonobe's formalization of G\"odel--Dummett logic and our
    specialized method for G\"odel--Dummett logic.
    In our formalization\,\LB, branches are for different shapes of Kripke
    frames.  In Sonobe's formalization, branches are made for different
    states in a Kripke model.

    Avron~\cite{avron2000} presented a tableau system of G\"odel--Dummett logic
    based on a hypersequent calculus.
    As he points out, the system has an advantage of not using a rule with
    arbitrary number of
    premises.  Our tableau system does not have this advantage.
    Larchey-Wendling~\cite{countermodelsearch} proposes an efficient parallel
    countermodel searching method for G\"odel--Dummett logic.
    It would be interesting to try to extend their methods to the
    class of logics considered in this paper.

 \section{Conclusion}

 We have extended Waaler and Wallen's tableau method~\cite{waaler1999tableaux} for intuitionistic
 logic in two ways: adding functional modalities, and adding restrictions on the Kripke frames.
 This resulted in the finite model property of sequential consistency
 logic~\cite{hirailpar} and a class of intermediate logics with
 functional modalities.

  \subsection{Completeness}
  We prove completeness via
  adaptation of the standard saturated set construction (see Troelstra
  and van Dalen~\cite[Ch.~2]{troelstra1988constructivism}).
  Hirai~\cite{hirailpar} contains a similar proof for a special case of
  sequential consistency logic.

  \begin{definition}
   A set~$\Gamma$ of formulae is
   $\mathsf R$-saturated iff all of these conditions hold:
   \begin{enumerate}
    \item $\Gamma$ does not contain $\bot$;
    \item $\Gamma$ is closed under $\mathsf R$-deduction, i.e.,
	  $\Gamma\vdashR\varphi\Rightarrow\varphi\in\Gamma$;
    \item $\varphi\vee\psi\in\Gamma\Rightarrow\varphi\in\Gamma$ or $\psi\in\Gamma$.
   \end{enumerate}
  \end{definition}

  \begin{lemma}
   \label{hoe:saturation}
   For a set~$\Gamma$ of formulae with $\Gamma\not\vdashR\varphi$,
   there exists a
   saturated set $\Gamma^{\omega}$ of formulae with
   $\Gamma^{\omega}\not\vdashR\varphi$ and
   $\Gamma\subseteq \Gamma^{\omega}$.
  \end{lemma}
  \begin{proof}
   Exactly the same as Lemma~2.10 in Hirai~\cite{hirailpar}.
  \end{proof}


  \begin{definition}[Canonical model candidate]
   We define a tuple
   $\R M = \tuple{\R W, \R\preceq, (\R{f_a})_{a\in \agents}, \R\rho}$
   where
   \begin{itemize}
    \item $\R W$ is the set of $\mathsf R$-saturated sets of formulae;
    \item $\Gamma\R\preceq \Delta$ iff $\Gamma\subseteq\Delta$;
    \item $\R{f_a}(\Gamma) = \{\varphi\mid K_a\varphi\in\Gamma\}$;
    \item $\R\rho(P)=\{\Gamma\mid P\in \Gamma\}$.
   \end{itemize}
  \end{definition}

  \begin{lemma}
   The tuple $\R M$ is a model.
  \end{lemma}
  \begin{proof}
   Exactly the same as Lemma~2.11 in Hirai~\cite{hirailpar}.
  \end{proof}

  \begin{proposition}
   \label{X}
   For a saturated set~$\Gamma$ of formulae and the canonical model~$\R
   M$,
   $\varphi\in\Gamma\Leftrightarrow \R M,\Gamma\models\varphi$ holds.
  \end{proposition}
  \begin{proof}
   Exactly the same as Lemma~2.13 in Hirai~\cite{hirailpar}.
  \end{proof}

  \begin{definition}
   A frame~$F = \tuple{W,\preceq, (f_a)_{a\in\agents}}$
   is a pseudo $\mathsf R$-frame iff $F$ satisfies
   $\delta(\mathsf R)$ for all world valuation
   $\delta$ and $w\in W$ s.t.
   every world variable~$\mathsf v$ satisfies
   $w\preceq \delta(\mathsf v)$.
  \end{definition}
  A pseudo $\mathsf R$-model is a model with a pseudo $\mathsf R$-frame.

  \begin{lemma}
   \label{pseudo-real}
   For a pseudo $\mathsf R$-model~$M$ and a state $w$ of $M$ with
   $M,w\models\varphi$,
   there exists an $\mathsf R$-model $\bar M$ and a state $\bar w$
   with $\bar M,\bar w\models\varphi$.
  \end{lemma}
  \begin{proof}
   A deep postfix is a postfix~$s$ that contains any sequence of agents
   encountered during parsing~$\varphi$ in the top-down direction.
   Let $s$ be a deep postfix for~$\varphi$. Let $M$ be
   $\tuple{W,\preceq,(f_a)_{a\in\agents},\rho}$.
   We define $\bar M$ to be $\tuple{\bar W,\bar\preceq,
   (\bar f_a)_{a\in\agents},\bar \rho}$ where
   $\bar W=\{v\in W\mid v\succeq f_s(w)\}$,$\bar\preceq =
   \preceq\cap (\bar W\times\bar W)$,
   $\bar f_a(w)= \begin{cases}
		  f_a(w)&(\mbox{if }f_a(w)\in\bar W)\\
		  w&(\mbox{otherwise})\enspace,
		 \end{cases}$
   and $\bar \rho(P) =\rho(P)\cap\bar W$.
   We define $\bar w$ to be $w$.
   The new model~$\bar M$ simulates the original model~$M$ well enough
   to make $\bar M,\bar w\models\varphi$ hold.
   Since $\bar M$ is a restriction of $M$, $\bar M$ is a pseudo
   $\mathsf R$-model.
   Moreover, since $\bar M$ has the minimum state, $\bar M$ is an
   $\mathsf R$-model.
  \end{proof}

  \begin{lemma}
   $\R M$ is a pseudo $\mathsf R$-model.
  \end{lemma}
  \begin{proof}
   Seeking contradiction,
   assume the frame $\R F = \tuple{\R W, \R\preceq, (\R
   {f_a})_{a\in\agents}}$
   does not satisfy $\delta(\mathsf R)$ for
   a world valuation~$\delta$ with
   $\Delta\R\preceq\delta(\mathsf v)$ for all $\Delta\in\R W$.
   There exists a world restriction
   $\mathsf r\in\mathsf R$.
   Let $\mathsf r$ be $\mathsf v_0.s\le\mathsf v_1.s\wor\cdots \wor\mathsf
   v_{n-1}.s\le\mathsf v_n.s\wor\mathsf v_n.s\le\mathsf v_0.s$.
   Since $\R F$ does not satisfy $\delta(\mathsf r)$,
   $f_s(\delta(\mathsf v_i))\not{\R \preceq}f_s(\delta(\mathsf v_{i+1}))$
   for
   all $0\le i\le n$ (we define $\mathsf v_{n+1} = \mathsf v_0$).
   Since $\R\preceq = \subseteq$, there exists
   a formula $\psi_i\in f_s(\delta(\mathsf v_{i+1}))\setminus
   f_s(\delta(\mathsf v_i))$ for every $0\le i\le n$.
   In other words, $K_s\psi_i\in\delta(\mathsf v_{i+1})$
   but $K_s\psi_i\notin\delta(\mathsf v_i)$.
   By Prop.~\ref{X},
   $\R M,\delta(\mathsf v_{i+1})\models K_s\psi_i$ but
   $\R M,\delta(\mathsf v_{i})\not\models K_s\psi_i$.
   On the other hand, $\mathbf{Ax}(\mathsf R)$ contains
   $\bigvee_{0\le i\le n}\left(K_s\psi_i\supset K_s\psi_{i+1}\right)$.
   So, for some $0\le i\le n$,
   $K_s\psi_i\supset K_s\psi_{i+1}\in\Delta$.
   This means, by Prop.~\ref{X},
   $\R M,\Delta\models K_s\psi_i\supset K_s\psi_{i+1}$.
   Since $\Delta\R\preceq\delta(\mathsf v_i)$,
   by Kripke monotonicity (Lemma~\ref{monot}),
   $\R M,\delta(\mathsf v_{i+1})\models K_s\psi_i\supset K_s\psi{i+1}$.
   This contradicts $\R M,\delta(\mathsf v_{i+1})\models K_s\psi_i$ and
   $\R M,\delta(\mathsf v_i)\not\models K_s\psi_i$.
  \end{proof}

  \begin{lemma}[Completeness]
   $\modelsR\varphi\Longrightarrow\vdashR\varphi$
  \end{lemma}
  \begin{proof}
   We show the contraposition.
   Assume $\not\vdashR \varphi$. By
   Lemma~\ref{hoe:saturation}, there exists
   a saturated set~$\Gamma^\omega$ with $\Gamma^\omega\not\vdashR\varphi$.
   By Lemma~\ref{X}, $\R M, \Gamma^\omega\not\models\varphi$.
   By Lemma~\ref{pseudo-real}, there exists an
   $\mathsf R$-model $\bar M$ and a state~$\bar w$ of $\bar M$
   with $\bar M,\bar w\not\models \varphi$.
   This witnesses $\not\modelsR\varphi$.
  \end{proof}


 \section{Related Work}
 \label{first:related}

 Van Benthem~\cite{van2009information} investigates the connection between
 intuitionistic logic and information dynamics.  He speculates:
 \begin{quotation}
  It might be
  that intuitionistic logic points the way towards a grand synthesis of information analysis
  in the standard model-theoretic style with the dynamic view of logic as embodied
  in proof and games.
 \end{quotation}
 This paper replies his speculation by defining knowledge in terms of BHK-interpretation
 and defining a proof system \iec\,embodying the interpretation.

 Ondrej Majer's
 Epistemic Logic with Relevant Agents~\cite{majer-epistemic}
 is similar to \iec\, in that both logics have epistemic modalities and that both logics are
 not classical.
 However, the logic given in~\cite{majer-epistemic}
 contains only one modality $K$ for knowledge.
 This implicitly assumes that there is a single agent, not multiple agents so that it is
 impossible for their logic to treat communication between multiple agents.

 Many logics have both temporal and epistemic modalities~\cite{sato13study, wozna2005logic}.
 Ewald~\cite{1986} proposes an intuitionistic logic with temporal modality.
 We unify the intuitionistic semantics and temporal semantics so that the logic
 \iec\,lacks temporal modality yet represents some temporal notions.
 Adding a temporal modality like Ewald~\cite{1986} would increase the expressivity of the
 logic, but it would complicate the syntax and semantics.
 We would like to investigate the simple logic \iec\,first
 and then expand \iec\,with
 additional constructs.

 In Kobayashi and Yonezawa's logic~\cite{kobayashi1995asynchronous}, processes
 appear in formulae but time does not appear in formulae
 because time is implicit in the system of logic programming.
 This logic is different from \iec\, in that this logic is based on linear logic and that their
 usage is logic programming.

 Belnap and Harper's ``seeing to it that'' (stit) logical operator
 aims at describing interaction between agents.
 The semantics for the operator involves both agency and temporal notion, which is more
 complicated than the meaning of $K_a$ operator in \iec.
 A fundamental difference of the stit operator and the epistemic operator in \iec\,
 is whether the modalities mention the future or tha past.
 The stit operator mentions the future while the epistemic operator mentions the past.

 Dynamic epistemic logic is a logic that aims at reasoning about communication.
 However the semantics of the logic involves
 instantaneous change of models.
 We argue such instantaneous change of the whole world it is
 not a natural description of asynchronous communication.


 \section{Conclusion}
 \label{conclusion}


 On the logic~\iec, we analysed the concept of sequential consistency and waitfree
 communication.
 The depth of our anlaysis is represented in a deep proof tree (Figure~\ref{hoge}) for a
 property of a relatively simple and small waitfree protol involving two processes.
 Distributed programming over shared memory can be seen as a game involving the scheduler
 and the program.
 Logic can be seen as a game involving the models and the formulae.
 We modelled schedules as a model of logic and programs as formulae.
 Since sequential consistency is a restriction on schedules,
 we modeled sequential consistency as a restriction on models.
 The restriction on the models representing sequential consistency could actually
 axiomatized using an axiom type that is similar to the axiom type for prelinerity defining
 a famous intermediate logic.
 Since waitfreedom is a restriction on programs,
 we modelled waitfree programs as a set of formulae called waitfree protocol description.
 We also modelled specification for waitfree programs as a set of formulae called waitfree
 task specification.
 We used a waitfree assertion, which is
 an implication formula consisting of a waitfree protocol description and a
 waitfree task specification,
 to represent
 an assertion that a waitfree protocol meets a specification.
