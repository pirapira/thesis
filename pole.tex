\chapter{Prelinear Realizability}

	% packages
% \usepackage{setspace}
% \doublespacing

% \usepackage{bussproofs}
% \usepackage{graphicx}
% \usepackage{amssymb}

% % title, author, etc
% \title{Some Disjunctive Tautologies as\\
%  Asynchronous Communication Schemes}
% \author{Yoichi Hirai}

% \usepackage{amsmath}	% required for `\align*' (yatex added)
% \begin{document}

% \maketitle

\renewcommand{\vec}{\overrightarrow}
\newcommand{\sche}{\sqsubseteq}


\newcommand{\sequent}[2]{{#1}\tr{#2}}
\newcommand{\aseq}[2]{\AxiomC{$\sequent{#1}{#2}$}}
\newcommand{\useq}[2]{\UnaryInfC{$\sequent{#1}{#2}$}}
\newcommand{\bseq}[2]{\BinaryInfC{$\sequent{#1}{#2}$}}
\newcommand{\tseq}[2]{\TrinaryInfC{$\sequent{#1}{#2}$}}

\newcommand{\limp}{\multimap}


\subsection{Summary}
%%% abstract
This work is a refinement of
Danos and Krivine's ``Disjunctive Tautologies as
Synchronisation Schemes''~\cite{danos-krivine}.
We show that some autologies,
namely the therems of G\"odel--Dummett logic,
can be viewed as asynchronous communication schemes.
We call these asynchronous because the operational semantics
of the communicating terms does not allow a term to wait for another
term.
In contrast to Danos and Krivine's formulation~\cite{danos-krivine},
where computation can wait for another,
our calculus is weaker and resides in a particular class of
distributed computation called waitfreedom.
This work is a reformulation of Hirai~\cite{hiraiflops2012} in the setting of
second-order logic.
This allowed parametricity argument.
Also, differently from Hirai's \fix{cite} hypersequent formulation,
we succceed in describing the computational behaviour of the Dummett
(a.k.a symmetric excluded middle) in the implicational form: this
difference is to be discussed in Sect. \fix{?}.

%%% 1. introduction

% 1a operational semantics for GD case

% 1b difference from Danos--Krivine

%%% 2. terms types and _models_?
\section{Synchronous Semantics}

% 2a terms -- unchanged -- remove pi or anything

\newcommand{\conc}{\parallel}
\newcommand{\comod}[2]{\ast^{\rightarrow {#2}}_{\leftarrow{#1}}}
\newcommand{\reader}[1]{\ast_{\leftarrow{#1}}}

We consider a programming language, which is a modification of
Danos and Krivine's.
We assume a set~$\pvar$ of propositional variables whose cardinality is
countably infinite.
For a set~$S$,
the set $\form(S)$ denotes the set of formulas:
\[
\phi::= s \mid X \mid \phi\limp\phi\mid \phi\oplus\phi\mid
\forall X \phi
\]
where $s\in S$ and $X\in \pvar$.
The connective $\forall$ connects stronger than $\oplus$, which is
stronger than $\limp$.
Recurring $\limp$,
$\phi_0\limp\phi_1\limp\cdots\limp\phi_n$ is defined inductively on~$n$
as
$\phi_0\limp(\phi_1\limp\cdots\limp\phi_n)$.
A type is an element of $\form(\emptyset)$.
Channels have involution $c\mapsto\co c$ with
$c\neq \co c$ and
$\co{\co c} = c$.
A \textit{term}~$t$ is defined by BNF:
\[
 t::= x
 \mid (t)t
 \mid \lambda x.t
 \mid \ast_t
 \mid \comod c c
 \mid (t\conc t)
 \mid \mat t x t x t
\]
where $x$ is a variable and $c$ is a channel.
A \textit{stack}~$\pi$ is defined by BNF:
\[
 \pi ::= \epsilon
 \mid t\cdot \pi
 \mid \mats x t \pi x t \pi
 \enspace.
\]
We write the set of terms as $\Lambda$ and stacks~$\Pi$.
An \textit{executable}~$e$ is a multiset on $\Lambda\times\Pi$.

% 2a' reduction
\newcommand{\red}{\succ}
A schedule~$\sche$ is a total order on channels.
The reduction relation~$\red$ on executables
is defined to be the smallest preorder
that satisfies:
\begin{description}
 \item[(cong)] if
      $e_0         \red e_1$
      then
      $(e_0 \conc e) \red (e_1\conc e)$\enspace;
 \item[(push)]
	    $[(t)u,\pi]      \red [t,u\cdot\pi]$      \enspace;
 \item[(store)]
	    $[\lambda x.t,u\cdot\pi]
	     \red
	     [t[\ast_u/x],      \pi]$\enspace;
 \item[(load)]
	    $[\ast_u,\pi]\red [u,\pi]$\enspace;
 \item[(dist)]
           $[(t\conc u),\pi]  \red [t,\pi\conc u,\pi]$ \enspace;
 \item[(ask)]
      $[\mat t x u y v,\pi]\red [t,\mats x u \pi y v \pi]$\enspace;
 \item[(ansL)]
           $[\inl{v}, \mats xt\pi yu\sigma] \red [t[v/x],\pi] $ \enspace;
 \item[(ansR)]
           $[\inr{w}, \mats xt\pi yu\sigma] \red [u[w/y],\sigma] $ \enspace;
 \item[(com0)]
	    $[\comod c{\co c}, t\cdot\pi\conc \comod{\co c}c,
	    u\cdot\sigma] \red
	    [u,\pi]$\enspace(if $\co c\sche c$); and
 \item[(com1)]
	    $[\comod c{\co c}, t\cdot\pi\conc \comod{\co c}c,
	    u\cdot\sigma] \red
	    [t,\sigma]$\enspace(if $c\sche \co c$).
\end{description}
The operational semantics for the additive constructs comes from Curien \fix{cite}.
Below, we omit the outermost parentheses (e.g. [ and ]) for multisets.

% I want to write these rules are non-blocking here.
% but, actually, Danos and Krivines rules are also non-blocking.
% they just busy-wait.
% In order to remove busy-waiting, we need types.

% 2b type system -- remove pierce -- add com'

\fix{describe a sequent; we do not allow multiple occurrences of the
same variable}
\fix{say, up to external exchange, we identify}

The derivation rules follow.\\ \noindent

\AxiomC{}
\LL  {Ax}
\useq{\xphi}{\xphi}
\DisplayProof
\ruleskip
%
\aseq{\xphi,\G}{\tj t\psi}
\LL{$\limp$I}
\useq{\G}{\tj{\lambda x.t}{\phi\limp\psi}}
\DisplayProof
\ruleskip
%
\aseq{\G}{\tj t{\phi\limp\psi}}
\aseq{\D}{\tj u\phi}
\LL   {$\limp$E}
\bseq{\G,\D}{\tj{(t)u}\psi}
\DisplayProof
\ruleskip
%
\aseq{\G}{\tj{t}{\phi}}
\LL  {$\oplus$I}
\useq{\G}{\tj{\inl{t}}{\phi\oplus\psi}}
\DisplayProof
\ruleskip
%
\aseq{\G}{\tj{t}{\psi}}
\LL  {$\oplus$I}
\useq{\G}{\tj{\inr{t}}{\phi\oplus\psi}}
\DisplayProof
\ruleskip
%
\aseq{\G}{\tj{t}{\phi\oplus\psi}}
\aseq{\D,\xphi}{\tj{u_0}{\theta}}
\aseq{\D,\ypsi}{\tj{u_1}{\theta}}
\LL  {$\oplus$E}
\tseq{\G,\D}{\tj{\mat{t}{x}{u_0}{y}{u_1}}{\theta}}
\DisplayProof
\ruleskip
%
\aseq\G{\tj t\phi}
\LL   {$\forall$I}
\useq\G{\tj t{\forall X\phi}}
\DisplayProof ($\G$ does not contain $X$ freely)
\ruleskip
%
\aseq{\G}{\tj{t}{\forall X\phi}}
\LL   {$\forall$E}
\useq{\G}{\tj{t}{\phi[\psi/X]}}
\DisplayProof
\ruleskip
%
\newcommand{\comodL}{\comod c{\co c}}
\newcommand{\comodR}{\comod{\co c}c}
\aseq{\tj{x}{\phi\limp\psi},\G}{\tj t\theta}
\aseq{\tj{y}{\psi\limp\phi},\G}{\tj u\theta}
\LL{Com}
\bseq{\G}{\tj{(t[\comodL/x]\conc u[\comodR/y])}{\theta}}
\DisplayProof

\fix{and exchange rules}


\section{Specification Using Poles}

% 2C truth values and models. make them disjunctive!
%    so that the empty set does not count as successful.
%    Also, make it closed for ``for all''
A \textit{pole}~$\bbot$ is a set of executables
which satisfies
\begin{enumerate}
 \item \label{red-closed} $e$ is in $\bbot$ if $e\red e'$ and
       $e'\in\bbot$; and
 \item \label{conc-closed} if $e$ or $f$ is in $\bbot$
       then $e\conc f\in\bbot$. %; and
% \item if both $e\in\bbot$ and $f\in\bbot$
%       then $e\hmid f\in\bbot$.
\end{enumerate}
Condition~\ref{conc-closed}. is different from Danos and
Krivine~\fix{cite}'s definition of poles.
There, the condition said if $e$ \textit{and} $f$ \textit{are} in
$\bbot$, then $e\conc f$ is in $\bbot$.  Our choice here is influenced
by hypersequents and hyper-lambda calculi \fix{cite}, where
components are interpreted disjunctively.

An \textit{environment} is a pair of a stack and an executable.
The set of environments is written as~$E$.
A \textit{program} is a pair of a term an executable.
For a set~$\mathcal Z$ of environments, $\mathcal Z\limp\bbot$ denotes
the set of programs $(t,e)$ such that
for any environment $(\pi,e')\in \mathcal Z$,
the executable $t,\pi\conc e \conc e'$ is in $\bbot$.
A set $\mathcal X$ of programs is called a truth value
iff there exists
such $\mathcal Z$ that $\mathcal X = \mathcal Z\limp \bbot$.
We define programs and environments because if we continue using
terms and stacks, the proof of adequacy (Prop.~\ref{c:adequacy}) does
not go through the case for
($\limp$E, \textminus), \ref{c:second}.

\renewcommand{\sem}[1]{|{#1}|}
\newcommand{\nsem}[1]{\sem{#1}^-}
\newcommand{\sempair}[1]{\sem{(#1)}}
For $\phi\in\form(2^E)$ and $|\cdot|^-_0\colon\pvar\rightarrow 2^E$,
we define $\nsem{\phi}\colon \form(2^E)\rightarrow
2^E$ inductively as
\begin{align*}
 \nsem{\mathcal Z} &= \mathcal Z \\
 \nsem{X}&= |X|_0^- \\
 \nsem{\phi\limp\psi}&=
 \{(t\cdot\pi, e_0\conc e_1)\mid
 (t,e_0)\in\nsem\phi\rightarrow\bbot \text{ and }(\pi,e_1)\in\nsem\psi\}\\
 \nsem{\phi\oplus\psi}=& \{(\mats x{t}{\pi}y{u}{\sigma}, f)\mid\\ &
 t[v/x],\pi\conc f\conc f'\in\bbot \text{ for all } (v,f')\in\nsem{\phi}\rightarrow\bbot\text{
 and }\\ &
 u[w/y],\sigma\conc f\conc f'\in\bbot \text{ for all } (w,f')\in\nsem{\psi}\rightarrow\bbot\}
 \\
 \nsem{\forall X\phi}=&
 \bigcup_{\mathcal Z\in 2^\Pi} \nsem{\phi[\mathcal Z/X]}\enspace.
\end{align*}
Using this, we define $\sem \phi=\nsem{\phi}\rightarrow\bbot$.
We have an equality
$\nsem{\phi\limp\psi} = \{(t\cdot\pi, e_0\conc e_1)\mid
(t,e_0)\in\sem\phi\text{ and }(\pi,e_1)\in\nsem\psi\}$.
Moreover, for types~$\phi$ and $\psi$, we define $\sempair{\phi,\psi}$
as the set of triples $(t,u,e)$ of terms $t$ and $u$ and an executable~$e$
such
that
$t,\pi\conc u,\sigma\conc e\conc e_0\conc e_1
\in\bbot$ for any $(\pi,e_0)\in\nsem\phi$
and $(\sigma,e_1)\in\nsem\psi$.

\begin{proposition}
 \label{squash}
 If $(t,u,e)$ is in $\sem{\phi,\phi}$ then $(t\conc u, e)$ is in
 $\sem\phi$.
\end{proposition}
\begin{proof}
 For any $\pi\in\nsem\phi$,
 $(t\conc u),\pi\conc e \red t,\pi\conc u,\pi\conc e$ holds.
 The reduct is in $\bbot$ by assumption.
 So, the original executable is also in $\bbot$.
\end{proof}

\begin{proposition}
 \label{comod-type}
 $(\comodL,\comodR,\emptyset)\in\sempair{\phi\limp\psi,\psi\limp\phi}$
 for any types~$\phi$ and $\psi$.
\end{proposition}
\begin{proof}
 Take any $(t\cdot\sigma,e_{0}\conc e_{1})\in\nsem{\phi\limp\psi}$
 and $(u\cdot\pi,f_{0}\conc f_{1})\in\nsem{\psi\limp\phi}$ so that
 $(t, e_{0})\in\sem{\phi}$, $(\sigma,e_{1})\in\nsem{\psi}$,
 $(u, f_{0})\in\sem{\psi}$, $(\pi,f_{1})\in\nsem{\phi}$.
 We claim $e=\comodL,t\cdot\sigma\conc\comodR,u\cdot\pi\conc
 e_{0}\conc e_{1}\conc f_{0}\conc f_{1}$ is in
 $\bbot$.
 Depending on the schedule, $e$ might reduce to
 $ t,\pi\conc e_{0}\conc e_{1}\conc f_{0}\conc f_{1}$ and otherwise to
 $ u,\sigma\conc e_{0}\conc e_{1}\conc f_{0}\conc f_{1}$,
 both of which are in $\bbot$ because
 $t,\pi\conc e_{0}\conc f_{1}$ and
 $u,\sigma\conc e_{1}\conc f_{0}$ are in $\bbot$.
 Since $\bbot$ is closed for $\red^{-1}$,
 we have $e\in\bbot$.
\end{proof}

% 2d the adequacy lemma
\fix{describe the notation $[\vec d/\G]$ and $\sem{\G}$}

Here we state adequacy.  What we want is statement~\ref{c:first}.
However, when we try to prove \ref{c:first} by induction on derivations,
the case for Com rule fails.  Thus we deal with two derivations.

\begin{proposition}[Adequacy]
 \label{c:adequacy}
 Let these sequents be derivable:
 $  \sequent{\G}{\tj{t}{\phi}} $
 and
 $  \sequent{\D}{\tj{u}{\psi}}$\enspace.
 Under these conditions, we state that:
 \begin{enumerate}[label=(\arabic{*}), ref=\textit{(\arabic{*})}]
  \item \label{c:first} the program
	$
	(t[\vec{g}/\G], \vec{e})
	$
	is in $\sem\phi$
	 for any
	$(\vec{g},\vec{e})\in\sem{\G}$; and that
  \item \label{c:second}
	when $\G$ and $\D$ are respectively
	equal to $\tj x\theta, \hat\G$ and $\tj y\tau, \hat\D$ up to exchange,
	the following triple is in $\sempair{\phi,\psi}$:
	\[\left(
	t[v/x][\vec g/\hat \G],\quad
	u[w/y][\vec d/\hat \D],\quad
	\vec e \conc \vec f \conc e'
	\right)
	\]
	for any
	$(v,w,e')\in\sempair{\theta,\tau}$,
	$(\vec g,\vec e)\in\sem{\hat\G}$ and
	$(\vec d,\vec f)\in\sem{\hat\D}$.
  \end{enumerate}
\end{proposition}
\begin{proof}
 We prove both statements at the same time by induction on the sum of
 the heights of the derivations.
  \begin{description}
  \item[(Ax, Ax)] When both derivations consist of only axiom rules,
       the statements follow from the definitions of $\sem{\phi}$ and
       $\sempair{\phi,\psi}$.
   \item[($\limp$I, \textminus)]
	The derivation for $t$ ends as
	\[
	\aseq{\tj{\hat x}{\phi_0},\G}{\tj{t_1}{\phi_1}}
	\useq{\G}{\tj{\lambda{\hat{x}}.t_1}{\phi_0\limp\phi_1}}
	\DisplayProof\enspace.
	\]
	\begin{enumerate}[label=\textit{(\arabic{*})}]
	 \item Take any
	       $(\vec g,\vec e)\in\sem{\G}$
	       and
	       $(\pi,e'')\in\nsem{\phi_0\limp\phi_1}$.
	       \fix{fill}
	 \item Take any $(v,w,e')\in\sempair{\theta,\tau}$,
	       $(\vec g,\vec e)\in\sem{\hat\G}$,
	       $(\vec d,\vec f)\in\sem{\hat\D}$,
	       $(\pi,e'')\in\nsem{\phi_0\limp\phi_1}$ and
	       $(\sigma,f'')\in\nsem\psi$. \fix{fill}
	\end{enumerate}
   \item[($\limp$E, \textminus)]
	The derivation for $t$ ends as
	\[
	\aseq{\G_0}{\tj{t_0}{\phi'\limp\phi}}
	\aseq{\G_1}{\tj{t_1}{\phi'}}
	\bseq{\G_0,\G_1}{\tj{(t_0)t_1}{\phi}}
	\DisplayProof\enspace.
	\]
	\begin{enumerate}[label=\textit{(\arabic{*})}]
	 \item Take any
	       $(\vec{g_0},\vec{e_0})\in\sem{\G_0}$,
	       $(\vec{g_1},\vec{e_1})\in\sem{\G_1}$ and
	       $(\pi,e'')\in\nsem{\phi}$.
	       We have to show that this executable is in $\bbot$:
	       \[
		((t_0)t_1)[\vec{g_0}/\G_0][\vec{g_1}/\G_1],\pi\conc
	       \vec{e_0}\conc \vec{e_1}\conc e''.
	       \]
	       By (push), this executable reduces to
	       \[
		t_0[\vec{g_0}/\G_0], t_1[\vec{g_1}/\G_1]\cdot \pi
	       \conc \vec{e_0}\conc \vec{e_1}\conc e''.
	       \]
	       By induction hypothesis~\ref{c:first} on both branches,
	       we have $(t_0[\vec{g_0/\G_0}],
	       \vec{e_0})\in\sem{\phi'\limp\phi}$
	       and
	       $(t_1[\vec{g_1}/\G_1],\vec{e_1})\in\sem{\phi'}$.
	       By the lattar, we have $(t_1[\vec{g_1}/\G_1]\cdot\pi,
	       \vec{e_1}\conc e'')\in\nsem{\phi'\limp\phi}$.
	       By definition of $\phi'\limp\phi$, we have shown that the
	       reduct is in $\bbot$.
	       Since $\bbot$ is closed for $\red^{-1}$,
	       the original executable is also in $\bbot$.
	       Since $\bbot$ is closed for $\red^{-1}$, the original
	       executable is also in $\bbot$.
	 \item Variable~$x$ might be contained in $\G_0$ or $\G_1$.
	       \begin{description}
		\item[(case $\G_0 = \tj{x}{\sigma},\hat\G_0$)]
		     Take
		     $(v,w,e')\in\sempair{\sigma,\tau}$,
		     $(\vec{g_0},\vec{e_0})\in\sem{\hat\G_0}$,
		     $(\vec{g_1},\vec{e_1})\in\sem{\G_1}$,
		     $(\vec{d},\vec{f})\in\sem{\hat\D}$,
		     $(\pi,e'')\in\nsem{\phi}$ and
		     $(\sigma,f'')\in\nsem{\psi}$.
		     We have to show that the following executable is in $\bbot$:
		     \fix{fill}
		\item[(case $\G_1 = \tj{x}{\sigma},\hat\G_1$)]
	      Take any
	      $(v,w,e')\in\sempair{\sigma,\tau}$,
	      $(\vec{g_0},\vec{e_0})\in\sem{\G_0}$,
	      $(\vec{g_1},\vec{e_1})\in\sem{\hat\G_1}$,
	      $(\vec{d},\vec{f})\in\sem{\hat\D}$,
	      $(\pi,e'')\in\nsem{\phi}$ and
	      $(\sigma,f'')\in\nsem{\psi}$.
	      We have to show that the following executable is in $\bbot$:
	      \[
	       ((t_0)t_1)[v/x][\vec{g_0}/\G_0][\vec{g_1}/\hat\G_1],\pi\conc
	      \vec{e_0}
	      \conc\hat{f}\conc
	      e''
	      \]
	      where
	      $\hat f = u[w/y][\vec{d}/\hat\D],\sigma\conc
	      \vec{f}\conc f''\conc \vec{e_1}\conc e'$.  This executable reduces
	      to
	      \[
	       t_0[\vec{g_0}/\G_0],t_1[v/x][\vec{g_1}/\hat\G_1]\cdot \pi\conc
	      \vec{e_0}
	      \conc\hat{f}\conc
	      e''\enspace.
	      \]
	      By induction hypothesis~\ref{c:second},
		     $(t_1[v/x][\vec{g_1}/\hat\G_1],
		     u[w/y][\vec{d}/\hat\D], \vec{e_1}\conc \vec{f}\conc
		     e')$ is in $\sempair{\phi',\psi}$.
		     So, since $(\sigma,f'')$ is in $\nsem{\psi}$,
	      $(t_1[v/x][\vec{g_1}/\hat\G_1],\hat f)$ is in
	      $\sem{\phi'}$.
	      Moreover we had $(\pi,e'')\in\nsem{\phi}$.
	      Combined,
	      $(t_1[v/x][\vec{g_1}/\hat\G_1]\cdot\pi,\hat f\conc e'')$
	      is in $\nsem{\phi'\limp\phi}$\kern -1pt.
	      By induction hypothesis~\ref{c:first},
	      $(t_0[\vec{g_0}/\G_0],\hat e)$ is in
	      $\sem{\phi'\limp\phi}$.
	      So, the reduct is in $\bbot$, making the original
	      executable a member of~$\bbot$.
	       \end{description}
	\end{enumerate}
   \item[($\oplus$I, \textminus)]
	Without loss of generality, we can assume that the
	derivation for $t$ ends as
	\[
	\aseq{\G}{\tj{t}{\phi}}
	\useq{\G}{\tj{\inl{t}}{\phi\oplus\psi}}
	\DisplayProof\enspace.
	\]
	\begin{enumerate}[label=\textit{(\arabic{*})}]
	 \item \fix{fill}
	 \item \fix{fill}
	\end{enumerate}
   \item[($\oplus$E, \textminus)]
	The derivation for $t$ ends in
	\[
	\aseq{\G_0}{\tj{t}{\phi_0\oplus\phi_1}}
	\aseq{\G_1,\tj{\hat{x}}{\phi_0}}{\tj{u_0}{\phi}}
	\aseq{\G_1,\tj{\hat{y}}{\phi_1}}{\tj{u_1}{\phi}}
	\tseq{\G_0,\G_1}{\tj{\mat{t}{\hat x}{u_0}{\hat y}{u_1}}{\phi}}
	\DisplayProof\enspace.
	\]
	\begin{enumerate}[label=\textit{(\arabic{*})}]
	 \item Take any $(\vec{g_0},\vec{e_0})\in\sem{\G_0}$,\quad
	       $(\pi,e')\in\nsem{\phi}$ and
	       $(\vec{g_1},\vec{e_1})\in\sem{\G_1}$.
	       We have to show that the executable
	       \[
	       (\mat t{\hat{x}}{u_0}{\hat{y}}{u_1})[\vec{ g_0}/\G_0][\vec{g_1}/\G_1],
	       \pi\conc \vec{e_0}\conc e'\conc \vec{e_1}
	       \]
	       is in $\bbot$.
	       The executable reduces to
	       \[
		t,\mats{\hat{x}}{u_0}{\pi}{\hat{y}}{u_1}{\pi}\conc\vec{e_0}\conc
	       e'\conc \vec{e_1}\enspace.
	       \]
	       We claim that
	       $(\mats{\hat{x}}{u_0}{\pi}{\hat{y}}{u_1}{\pi},\vec{e_1}\conc
	       e')$ is in $\nsem{\phi\oplus\psi}$ and that
	       $(t,\vec{e_0})$ is in $\sem{\phi\oplus\psi}$.  The first
	       claim is shown by induction hypothesis~\ref{c:first}
	       stating that $(u_0[v/\hat{x}][\vec{e_1}/\G_1], \vec{e_1}\conc
	       e'')$ is in $\sem{\phi}$ for any $(v,e'')\in\sem{\phi_0}$
	       and similarly to~$u_1$.
	       The second claim follows from induction
	       hypothesis~\ref{c:first} on $t$.
	       By the two claims and by the definition of
	       $\sem{\phi\oplus\psi}$,
	       we have shown that the reduct is in $\bbot$ and
	       thence that the original executable is in $\bbot$.
	 \item \fix{fill}
	\end{enumerate}
   \item[(Com, \textminus)]
	The derivation for $t$ ends in
	\[
	\aseq{\tj{\hat x}{\phi_0\limp\phi_1},\G_0}{\tj{t_0}{\phi}}
	\aseq{\tj{\hat y}{\phi_1\limp\phi_0},\G_1}{\tj{t_1}{\phi}}
	\bseq{\G_0,\G_1}{\tj{(t_0[\comodL/\hat x]\conc t_1
	[\comodR/\hat y])}{\phi}}
	\DisplayProof\enspace.
	\]
	\begin{enumerate}[label=\textit{(\arabic{*})}]
	\item Take any $(\vec{g_0},\vec{e_0})\in\sem{\G_0}$,
	      $(\vec{g_1},\vec{e_1})\in\sem{\G_1}$ and
	      $(\pi,e')\in\nsem{\phi}$.
	      By Prop.~\ref{comod-type}, we have
	      $(\comodL,\comodR,\emptyset)\in\sempair{\phi_0\limp\phi_1,\phi_1\limp\phi_0}$.
	      By induction hypothesis~\ref{c:second}, the terms
	      $t'_0=t_0[\comodL/\hat{x}][\vec{g_0}/\G_0]$ and
	      $t'_1=t_1[\comodR/\hat{y}][\vec{g_1}/\G_1]$
	      satisfy
	      $(t_0',t_1',\vec{e_0}\conc
	      \vec{e_1})\in\sempair{\phi,\phi}$.
	      By Prop.~\ref{squash}, we have $(t'_0\conc t'_1,
	      \vec{e_0}\conc \vec{e_1})\in\sem{\phi}$.
	\item
	      Without loss of generality,
	      we can assume $(\tj x\phi)\in\G_0$ so that
	      $\G_0 =\tj x\phi, {\hat\G_0}$ up to exchange.
	      Take any
	      $(v,w,e')\in\sempair{\theta,\tau}$,
	     $(\vec{g_0},\vec{e_0})\in\sem{\hat\G_0}$,
	     $(\vec{g_1},\vec{e_1})\in\sem{\G_1}$,
	     $(\vec d,\vec f)\in\sem{\hat\D}$,
	     $(\pi,e'')\in\nsem{\phi}$ and
	     $(\sigma,f'')\in\nsem{\psi}$.
	      By induction hypothesis~\ref{c:second},
	      the terms $t_0'=t_0[v/x][\vec
	      {g_0}/\hat\G_0]$
	      and
	      $u'=u[w/y][\vec{d}/\D]$
	      satisfy
	      $(t_0',u',\fix{?})\in\sempair{\phi,\psi}$.
	      By induction hypothesis~\ref{c:first},
	      $t_1'=t_1[\vec {g_1}/\G_1]$ satisfies
	     $(t'_1,\fix{?})\in\sem{\phi'}$. \fix{fix later}
	      From these, respectively, we obtain
	      $t_0',\pi\conc u',\sigma\in\bbot$
	      and
	      $t_1',\pi\in\bbot$.
	      Since $\bbot$ is closed for $\conc$,
	      we have $t_0',\pi\conc t_1',\pi\conc u',\sigma\in\bbot$.
	      By (dist) and (cong),
	      $(t_0'\conc t_1'),\pi\conc u',\sigma$ reduces
	      to this executable.
	      So $(t_0'\conc t_1',u')\in\sem{\phi',\psi'}$
	      where $t_0'\conc t_1' = (t_0[\comodL/\hat x]\conc
	      t_1[\comodR/\hat y])[\vec{d_0}/\D_0][\vec{d_1}/\D_1][\vec g/\G]$.
	\end{enumerate}
  \item[($\forall$I, \textminus)]
       \fix{reread}
       The derivation for $t$ ends in
       \aseq{\G}{\tj t\phi}
       \useq{\G}{\tj t{\forall X\phi}}
       \DisplayProof.
       \begin{enumerate}[label=\textit{(\arabic{*})}]
	\item Take any $(\vec g,\vec{e})\in\sem{\G}$.
	      Since $\G$ does not contain $X$ freely,
	      $\sem\G$ does not change whatever
	      $\nsem{X}_0$ is.
	      On the other hand, since the indcution
	      hypothesis~\ref{c:first}
	      holds for arbitrary $\nsem{X}_0$,
	      the program $t[\vec g/\G]$ is in
	      $\bigcap_{\mathcal Z\in 2^\Pi}\sem{\phi[\mathcal Z/X]}$.
	      Since $(\bigcap_{\mathcal Z\in 2^\Pi}\sem{\phi[\mathcal
	      Z/X]})\cdot (\bigcup_{\mathcal Z\in
	      2^\Pi}\nsem{\phi[\mathcal Z/X]})$ is a subset of $\bbot$,
	      the program is in $\sem{\forall X\phi} = \left(\bigcup_{\mathcal
	      Z\in 2^\Pi}\nsem{\phi[\mathcal Z/X]}\right) \rightarrow
	      \bbot$.
	\item Take any
	      $(v,w,e')\in\sempair{\theta,\tau}$,
	      $(\vec g,\vec e)   \in\sem{\hat\G}$,
	      $(\pi,e'')\in\nsem{\forall X\phi}$ and
	      $(\sigma,f'')\in\nsem{\psi}$.
	      We can replace $X$ in the derivation of $t$ with
	      another propositional variable~$X'$ that does not
	      occur in the derivation of $u$.
	      We are going to use the induction hypothesis on the
	      renamed derivation with the terms and stacks taken above.
	      Since $\theta$ and $\hat\G$ do not contain
	      $X$ freely, we have
	      $(v,w,e')\in\sem{\theta[X'/X],\tau}$,
	      $(\vec{g},\vec{e})\in\sem{\hat\G[X'/X]}$ and $(\pi,e'')\in
	      \nsem{\forall X'\phi[X'/X]}$.
	      By induction hypothesis~\ref{c:second}
	      on the renamed derivation,
	      the terms
	      $t' = t[v/x][\vec g/\G]$ and
	      $u' = u[w/y][\vec d/\D]$ satisfy
	      $(t',u',\vec e\conc \vec f)\in\sem{\phi[X'/X],\psi'}$ for any $\nsem{X'}_0$.
	      That is, for $\mathcal Z\in 2^E$ that makes
	      $(\pi,e'')\in\nsem{\phi[X'/X][\mathcal Z/X']}$ and
	      $(\sigma,f'')\in\nsem{\psi[\mathcal Z/X']}$,
	      $t'\pi\conc u',\sigma\conc e''\conc f''$ is in $\bbot$,
	      making $t',\pi\conc u',\sigma$ an elment of
	      $\bbot$..
       \end{enumerate}
  \item[($\forall$E, \textminus)]
       The derivation for $t$ ends in
       \aseq{\G}{\tj t{\forall X\phi}}
       \useq{\G}{\tj t{\phi[\psi/X]}}
       \DisplayProof.
       Both statements follow immediately from the induction hypotheses
       because $\nsem{\phi[\psi/X]}$ is a subset of $\nsem{\forall X\phi}$.
 \end{description}
 \end{proof}
Note that \ref{c:first} uses \ref{c:second} and vice versa, for example in the (Com, \textminus) case.

\begin{proposition}
 The following set is a pole: the set of executables that reduces to
 an executable containing an element of a fixed set of executables.
\end{proposition}
\begin{proof}
 \fix{fill}
\end{proof}

\begin{proposition}
 Let
 $\sequent{}{}{\tj c
 {\forall X\forall A\forall B
 [((A\limp B)\limp X)
  \limp((B\limp A)\limp X)
  \limp X]}}$
 be
 derivable.
 For all terms $\rho,\sigma, r$ and for all stacks $\pi, \pi_A$ and
 $\pi_B$,
 if $[(\rho)d  ,\pi]\reduce [d,a\cdot \pi_B]$ and
    $[(\sigma)f,\pi]\reduce [f,b\cdot \pi_A]$ hold for all $d$ and $f$,
 then
 $[(c)(\rho)\sigma,\pi],S_\epsilon$ reduces to a multiset containing an
 element of
 $\{(a,\pi_A),(b,\pi_B)\}$.
\end{proposition}
\begin{proof}
\end{proof}

\subsection{Adding Exponentials}


\section{Asynchronous Semantics}

A \textit{term}~$t$ is defined by BNF:
\[
 t::= x
 \mid (t)t
 \mid t\conc t
 \mid \lambda x.t
 \mid \ast_t
 \mid \comod c c
 \mid \reader  c
\]
where $x$ is a variable and $c\colon\phi$ is a channel.
A \textit{stack}~$\pi$ is defined by BNF:
\[
 \pi ::= \epsilon
 \mid t\cdot \pi
 \enspace.
\]
We write the set of terms as $\Lambda$ and stacks~$\Pi$.
A \textit{store} is a partial mapping from locations to
terms, equivalently, a mapping from locations to terms and $\bot$'s.
The \textit{empty store}~$S_\epsilon$ maps any channel to $\bot$.
For a store $S$, we define a store $S[c\colon\phi\mapsto x]$ to be
the same as $S$ except that $S[c\colon\phi\mapsto x](c\colon\phi\mapsto
x)$ is $x$.
A \textit{store} is a partial mapping from locations to
terms, equivalently, a mapping from locations to terms and $\bot$'s.
The \textit{empty store}~$S_\epsilon$ maps any channel to $\bot$.
For a store $S$, we define a store $S[c\colon\phi\mapsto x]$ to be
the same as $S$ except that $S[c\colon\phi\mapsto x](c\colon\phi\mapsto
x)$ is $x$.
An \textit{executable} is a finite multiset on $\Lambda \times \Pi$,
paired with a store.

% 2a' reduction
We have reduction relation~$\red$ on executables,
which is defined to be the smallest binary relation
that satisfies:
\begin{description}
 \item[(cong)] if
	    $[t,\pi],         S \red [ t',\pi'],        S'$
	    then
	    $[t,\pi \conc e], S \red [ t',\pi'\conc e], S'$\enspace;
 \item[(push)]
	    $[(t)u,\pi],S       \red [t,u\cdot\pi],S$;
 \item[(dist)]
	    $[t\conc u,\pi],S   \red [t,\pi\conc u,\pi],S$\enspace;
 \item[(store)]
	    $[\lambda x.t,u\cdot\pi],S
	     \red
	     [t[\ast_u/x],      \pi],S$\enspace;
 \item[(load)]
	    $[\ast_u,\pi],S\red[u,\pi],S$\enspace;
 \item[(write)]
	    $
	    [\comod c{\co c}, t\cdot\pi], S[\co
	    c\colon\psi\mapsto\bot]
	    \red
	    [\reader c, \pi],
	    S[\co c\colon\psi\mapsto t]
	    $\enspace;
 \item[(write')]
	    $
	    [\comod c{\co c}, t\cdot\pi], S[\co
	    c\colon\psi\mapsto u]
	    \red
	    [\reader c, \pi],
	    S[\co c\colon\psi\mapsto u]
	    $\enspace;
 \item[(read)]$
	    [\reader c ,\pi],
	    S[c\colon\phi\mapsto u]
	    \red
	    [u,\pi],
	    S[c\colon\phi\mapsto u]
	    $\enspace; and
 \item[(fail)]
	    $
	    [\reader c,\pi],
	    S[c\colon\phi\mapsto \bot]
	    \red
	    \emptyset,S[c\colon\phi\mapsto \bot]
	    $
	    \enspace.
\end{description}
We denote the reflexive transitive closure of $\red$ as $\reduce$.


We can implement something similar to Lafont's example,
showing that confluence does not hold.
Suppose $\G\tr\tj t\phi$ and $\G\tr\tj u\phi$ are both derivable.
Then, by induction on the derivation,
both $\G,\tj x{\phi\limp\phi}\tr\tj{(x)t}\phi$
and $\G,\tj y{\phi\limp\phi}\tr\tj{(y)u}\phi$ are derivable
for $x$ and $y$ not appearing in $\G$, $u$, or $t$.
By the communication rule,
$\G\tr\tj{(\comod c{\co c})t\conc(\comod {\co c} c)u}\phi$ is derivable.
But $[(\comod c{\co c})t\conc (\comod{\co c} c)u,
\pi],S_\epsilon$
can reduce both to $[t,\pi], S_\epsilon[c\mapsto u, \co c\mapsto t]$
and to $[u,\pi], S_\epsilon[c\mapsto u,\co c\mapsto t]$.
Since $t$ and $u$ were taken arbitrarily, we cannot distinguish terms
of the same type if we equate a term with what it reduces to.


Another important property of an executable is
non-abortfullness
which states that the executable has no reduction sequence leading to
$\emptyset,S$.
The name comes from hyper-lambda calculus formulation in \fix{cite},
where a term sometimes turns into $\mathsf{abort}$ and there the property
stated that a hyperterm has no reduction sequence leading to a hyperterm
full of $\mathsf{abort}'s$.
This property is important because it ensures existence of
constructive content of proofs.

Non-abortfullness cannot be verified using poles
because any pole must have $\emptyset,S$ as an element for
any store~$S$.
This condition for poles is used in the
communication case of the proof of adequacy.
In order to prove non-abortfullness as a logical property,
we define another variant of poles called scheduled poles.


\fix{find a property that can only be verified using scheduled poles}.
\fix{maybe exact specification}


\begin{proposition}[Non-abortfullness]
Let $\tr\tj t\psi$ be derivable, then,
 $[t,\epsilon], S_\epsilon$ has no run leading to $\emptyset, S'$ for
 any store $S'$.
\end{proposition}
\begin{proof}
\end{proof}


%%%%%%%% some texts

\section{Comparison with the Hypersequent Formulation}


\section*{where to put them}

``Undecidability of second order linear logic'' has
\begin{align*}
 \phi\otimes \psi&\equiv \forall X((\phi\limp\psi\limp X)\limp X) \\
 {1}      &\equiv \forall X(X\limp X)\\
 \exists X\phi   &\equiv \forall Y((\forall X(\phi\limp Y))\limp Y)
\end{align*}

Not all disjunctive tautologies are valid in G\"odel--Dummett logic:
$(P\limp Q)\lor(Q\limp R)$.

Non-abortfullness is not a pole.
In order to change this, we have to do something more subtle.
