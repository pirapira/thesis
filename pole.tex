\chapter{Some Disjunctive Tautologies as
  Asynchronous Communication Schemes}

	% packages
% \usepackage{setspace}
% \doublespacing

% \usepackage{bussproofs}
% \usepackage{graphicx}
% \usepackage{amssymb}

% % title, author, etc
% \title{Some Disjunctive Tautologies as\\
%  Asynchronous Communication Schemes}
% \author{Yoichi Hirai}

% \usepackage{amsmath}	% required for `\align*' (yatex added)
% \begin{document}

% \maketitle

\subsection{Summary}
%%% abstract
This work is a refinement of
Danos and Krivine's ``Disjunctive Tautologies as
Synchronisation Schemes.''
We show that some autologies,
namely the therems of G\"odel--Dummett logic,
can be viewed as asynchronous communication schemes.
We call these asynchronous because the operational semantics
of the communicating terms does not allow a term to wait for another
term.
In contrast to Danos and Krivine's \fix{cite} formulation,
where computation can wait for another,
our calculus is weaker and resides in a particular class of
distributed computation called waitfreedom.
This work is a reformulation of Hirai~\fix{cite} in the
second-order logic.
This allowed parametricity argument.
Also, differently from Hirai's \fix{cite} hypersequent formulation,
we succceed in describing the computational behaviour of the Dummett
(a.k.a symmetric excluded middle) in the implicational form: this
difference is to be discussed in Sect. \fix{?}.

%%% 1. introduction

% 1a operational semantics for GD case

% 1b difference from Danos--Krivine

%%% 2. terms types and _models_?
\section{Types and Terms}

% 2a terms -- unchanged -- remove pi or anything

\newcommand{\conc}{\parallel}
\newcommand{\comod}[4]{\ast^{\rightarrow {#3 \colon
{#4}}}_{\leftarrow{#1\colon {#2}}}}
\newcommand{\reader}[2]{\ast_{\leftarrow{#1\colon {#2}}}}

We consider a programming language, which is a modification of
Danos and Krivine's.
We assume a set~$\pvar$ of propositional variables whose cardinality is
countably infinite.
For a set~$S$,
the set $\form(S)$ denotes the set of formulas:
\[
\phi::= s \mid X \mid \phi\imp\phi\mid \forall X \phi
\]
where $s\in S$ and $X\in \pvar$.
A type is an element of $\form(\emptyset)$.
Channels have involution $c\mapsto\co c$ with
$c\neq \co c$ and
$\co{\co c} = c$.
Moreover, each channel $c$ is associated with a type~$\phi$,
written as $c\colon\phi$.
For any types $\phi$ and $\psi$, there are infinitely many
channels $c\colon\phi$ with $\co c\colon\psi$.
A \textit{term}~$t$ is defined by BNF:
\[
 t::= x
 \mid (t)t
 \mid t\conc t
 \mid \lambda x.t
 \mid \ast_t
 \mid \comod c\phi c\phi
 \mid \reader  c\phi
\]
where $x$ is a variable and $c\colon\phi$ is a channel.
A \textit{stack}~$\pi$ is defined by BNF:
\[
 \pi ::= \epsilon
 \mid t\cdot \pi
 \enspace.
\]
We write the set of terms as $\Lambda$ and stacks~$\Pi$.
A \textit{store} is a partial mapping from locations to
terms, equivalently, a mapping from locations to terms and $\bot$'s.
The \textit{empty store}~$S_\epsilon$ maps any channel to $\bot$.
For a store $S$, we define a store $S[c\colon\phi\mapsto x]$ to be
the same as $S$ except that $S[c\colon\phi\mapsto x](c\colon\phi\mapsto
x)$ is $x$.
An \textit{executable} is a finite multiset on $\Lambda \times \Pi$,
paired with a store.

% 2a' reduction
\newcommand{\red}{\succ_1}
\renewcommand{\reduce}{\succ}
We have reduction relation~$\red$ on executables,
which is defined to be the smallest binary relation
that satisfies:
\begin{description}
 \item[(cong)] if
	    $[t,\pi],         S \red [ t',\pi'],        S'$
	    then
	    $[t,\pi \conc e], S \red [ t',\pi'\conc e], S'$\enspace;
 \item[(push)]
	    $[(t)u,\pi],S       \red [t,u\cdot\pi],S$;
 \item[(dist)]
	    $[t\conc u,\pi],S   \red [t,\pi\conc u,\pi],S$\enspace;
 \item[(store)]
	    $[\lambda x.t,u\cdot\pi],S
	     \red
	     [t[\ast_u/x],      \pi],S$\enspace;
 \item[(load)]
	    $[\ast_u,\pi],S\red[u,\pi],S$\enspace;
 \item[(write)]
	    $
	    [\comod c\phi{\co c}\psi, t\cdot\pi], S[\co
	    c\colon\psi\mapsto\bot]
	    \red
	    [\reader c\phi, \pi],
	    S[\co c\colon\psi\mapsto t]
	    $\enspace;
 \item[(write')]
	    $
	    [\comod c\phi{\co c}\psi, t\cdot\pi], S[\co
	    c\colon\psi\mapsto u]
	    \red
	    [\reader c\phi, \pi],
	    S[\co c\colon\psi\mapsto u]
	    $\enspace;
 \item[(read)]$
	    [\reader c \phi,\pi],
	    S[c\colon\phi\mapsto u]
	    \red
	    [u,\pi],
	    S[c\colon\phi\mapsto u]
	    $\enspace; and
 \item[(fail)]
	    $
	    [\reader c\phi,\pi],
	    S[c\colon\phi\mapsto \bot]
	    \red
	    \emptyset,S[c\colon\phi\mapsto \bot]
	    $
	    \enspace.
\end{description}
We denote the reflexive transitive closure of $\red$ as $\reduce$.

% I want to write these rules are non-blocking here.
% but, actually, Danos and Krivines rules are also non-blocking.
% they just busy-wait.
% In order to remove busy-waiting, we need types.

% 2b type system -- remove pierce -- add com'

We type terms as follows.\\ \noindent
\AxiomC    {}
\LeftLabel {Axiom}
\UnaryInfC {$\G,\tj x \phi\tr \tj x \phi$}
\DisplayProof
    \ruleskip\noindent
%%
\AxiomC    {$\G,\tj x \phi\tr \tj t \psi$}
\LeftLabel {Abstraction}
\UnaryInfC {$\G\tr\tj{\lambda x.t}{\phi\imp\psi}$}
\DisplayProof
    \ruleskip\noindent
%%
\AxiomC    {$\G\tr\tj{t}{\phi\imp\psi}$}
\AxiomC    {$\G\tr\tj u \phi$}
\LeftLabel {Application}
\BinaryInfC{$\G\tr\tj{(t)u}{\psi}$}
\DisplayProof
    \ruleskip\noindent
%%
\AxiomC    {$\G\tr\tj t \phi$}
\LeftLabel {Generalization}
\UnaryInfC {$\G\tr\tj{t}{\forall X\phi}$}
\DisplayProof
($X$ not free in $\G$)
    \ruleskip\noindent
%%
\AxiomC    {$\G\tr\tj t{\forall X\phi}$}
\LeftLabel {Instantiation}
\UnaryInfC {$\G\tr\tj t{\phi[\psi/X]}$}
\DisplayProof
    \ruleskip\noindent
%%
\AxiomC    {$\G\tr\tj t \phi$}
\AxiomC    {$\G\tr\tj u \phi$}
\LeftLabel {Mix}
\BinaryInfC{$\G\tr\tj {t\conc u}{\phi}$}
\DisplayProof
    \ruleskip\noindent
%%
\AxiomC    {$\G,\tj x{\phi\imp \psi}\tr\tj t \theta$}
\AxiomC    {$\G,\tj y{\psi\imp \phi}\tr\tj u \theta$}
\LeftLabel {Communication}
\BinaryInfC{$
\G\tr\tj{
t[\comod c\psi {\co c}\phi/x]
   \conc
u[\comod{\co c}\phi c\psi/y]
  }{\theta}$}
\DisplayProof

We can implement something similar to Lafont's example,
showing that confluence does not hold.
Suppose $\G\tr\tj t\phi$ and $\G\tr\tj u\phi$ are both derivable.
Then, by induction on the derivation,
both $\G,\tj x{\phi\imp\phi}\tr\tj{(x)t}\phi$
and $\G,\tj y{\phi\imp\phi}\tr\tj{(y)u}\phi$ are derivable
for $x$ and $y$ not appearing in $\G$, $u$, or $t$.
By the communication rule,
$\G\tr\tj{(\comod c\phi{\co c}\phi)t\conc(\comod {\co c}\phi c
\phi)u}\phi$ is derivable.
But $[(\comod c\phi{\co c}\phi)t\conc (\comod{\co c}\phi c\phi)u,
\pi],S_\epsilon$
can reduce both to $[t,\pi], S_\epsilon[c\mapsto u, \co c\mapsto t]$
and to $[u,\pi], S_\epsilon[c\mapsto u,\co c\mapsto t]$.
Since $t$ and $u$ were taken arbitrarily, we cannot distinguish terms
of the same type if we equate a term with what it reduces to.

\section{Specification Using Poles}

% 2C truth values and models. make them disjunctive!
%    so that the empty set does not count as successful.
%    Also, make it closed for ``for all''
A \textit{pole}~$\bbot$ is a set of executables
which satisfies
\begin{enumerate}
 \item $e$ is in $\bbot$ if $e'\in\bbot$ and
       $e\red e'$;
 \item $\emptyset, S$ is in $\bbot$ for any store~$S$; and
 \item if $(m,S)\in\bbot$ and $(m',S)\in\bbot$
       then $(m\conc m',S)\in\bbot$.
\end{enumerate}
For a set of executable~$E$, the pole generated by~$E$ is the smallest
pole containing~$E$.
This is well-defined because the condition for a pole is monotonic.
\begin{proposition}
 Let $e$ be a nonempty executable in the pole generated by $E$.
 Then $e$ reduces to a multiset on~$E$.
\end{proposition}
\begin{proof}
 \fix{prove}
\end{proof}

A term-store pair is a pair of a term and a store.
For a term~$t$, stack~$\pi$ and store~$S$, we identify $([t,\pi], S)$
as $((t,S), \pi)$
For a set~$\mathcal Z$ of stacks, $\mathcal Z\imp\bbot$ denotes
the largest set~$\mathcal X$ of term-store pairs such that
$\mathcal X\times\mathcal Z\subset \bbot.$
A set $\mathcal X$ of terms is called a truth value
iff there exists
such $\mathcal Z$ that $\mathcal X = \mathcal Z\imp \bbot$.

\renewcommand{\sem}[1]{|{#1}|}
\newcommand{\nsem}[1]{\sem{#1}^-}
For $F\in\form(2^\Pi)$ and $|\cdot|^-_0\colon\pvar\rightarrow 2^\Pi$,
and a set~$\Sigma$ of stores,
we define $\nsem{\phi}_\Sigma\colon \form(2^\Pi)\rightarrow
2^\Pi$ inductively as
\begin{align*}
 \nsem{\mathcal Z}_\Sigma &= \mathcal Z \\
 \nsem{X}_\Sigma&= |X|_0^- \\
 \nsem{\phi\imp\psi}_\Sigma&=
 \{t\cdot\pi\mid(t,S)\in\nsem\phi_\Sigma\rightarrow\bbot\text{ for all store
 }S\in \Sigma\text{ and }\pi\in\nsem\psi_\Sigma\}
 \\
 \nsem{\forall X\phi}_\Sigma&=
 \bigcup_{\mathcal Z\in 2^\Pi} \nsem{\phi[\mathcal Z/X]}_\Sigma
\end{align*}
Using this, we define $\sem \phi_\Sigma=\nsem{\phi}_\Sigma\rightarrow\bbot$.

For $\Sigma\subset \Sigma'$, we have
$\nsem{\phi}_\Sigma\supset\nsem{\phi}_\Sigma$
and $\sem{\phi}_\Sigma\subset\sem{\phi}_\Sigma$
for all $\phi$.
When we define $F(\Sigma)$ as the set of stores $S$
such that $S(c\colon\phi) \in \sem{\phi}_\Sigma\cup\{\bot\}$.
Then, $F$ is an order-preserving function.
So, by Knaster--Tarski theorem,
there is the greatest $\hat\Sigma$ such that $F(\hat\Sigma) =
\hat\Sigma$.
An element of $\hat\Sigma$ is called a \textit{proper store}.
Note that the empty store is proper by definition of~$F$.
We define $\nsem{\phi} = \nsem{\phi}_{\hat\Sigma}$
and $\sem{\phi} = \sem{\phi}_{\hat\Sigma}$.
When we abuse $\sem{\phi}$ as a set of terms,
$\sem{\phi}$ is the largest set~$\mathcal T$
with $\mathcal T\times\hat\Sigma\subset\sem{\phi}$.
With these notations, we have an equality
$\nsem{\phi\imp\psi} = \{t\cdot\pi\mid
t\in\sem\phi\text{ and }\pi\in\nsem\psi\}$.

\begin{proposition}
 \label{type-conc}
 The set $\sem\phi$ of terms is closed for $\conc$.
\end{proposition}
\begin{proof}
 Assuming $t$ and $u$ are in $\sem\phi$, we show $t\conc u$ is also in
 $\sem\phi$.
 By definition of $\sem\phi$, both $(t,S)$ and $(u,S)$ are in $\sem\phi$
 for any proper store~$S$.
 In other words, for any $\pi\in\nsem\phi$,
 both $[t,\pi],S$ and $[u,\pi],S$ are in $\bbot$.
 By definition of a pole,
 $[t\conc u,\pi],S$ is also in $\bbot$,
 making $(t\conc u, S)$ an element of $\sem\phi$, further ensuring
 membership of $t\conc u$ with regard to $\sem\phi$.\qed
\end{proof}
% 2d the adequacy lemma
\begin{proposition}[Adequacy]
 Let $\tj{x_1}{\phi_1},\ldots,\tj{x_n}{\phi_n}\tr\tj t \psi$ be derivable,
 $\bbot$ be any pole,
 and $|\cdot|_0^-$ be any map from propositional variables to
 $2^\Pi$, then, for all
 $v_1\in\sem{\phi_1},\ldots,v_n\in\sem{\phi_n}$,
 the term $t[v_1/x_1,\ldots,v_n/x_n]$ is in $\sem\psi$.
\end{proposition}
\begin{proof}
 By induction on the derivation of~$t$.

 (Application
 \AxiomC    {$\G\tr\tj{t}{\phi\imp\psi}$}
 \AxiomC    {$\G\tr\tj u \phi$}
 \BinaryInfC{$\G\tr\tj{(t)u}{\psi}$}
 \DisplayProof )
 Take $v_i\in\sem{\phi_i}$.
 By induction hypothesis, $t[v_i/x_i]$ is in $\sem{\phi\imp\psi}$
 and $u[v_i/x_i]$ is in $\sem{\phi}$.
 For any proper store~$S$ and $\pi\in\nsem\psi$,
 we claim that $e = [(t)u[v_i/x_i],\pi],S$ is in $\bbot$.
 One reduction from $e$ is
 $e\red[t[v_i/x_i],u[v_i/x_i]\cdot\pi],S$.
 Since $u[v_i/x_i]\in\sem\phi$ and $\pi\in\nsem\psi$,
 $u[v_i/x_i]\cdot\pi$ is in $\nsem{\phi\imp\psi}$.
 Moreover, since $S$ is proper,
 $(t[v_i/x_i], S)$ is in $\sem{\phi\imp\psi}$.
 By definition of $\sem{\cdot}$,
 $[t[v_i/x_i],u[v_i/x_i]\cdot\pi],S$ is in $\bbot$.
 By definition of a pole, $e$ is also in $\bbot$.

 (Communication
 \AxiomC{$\G,\tj x{\phi\imp\psi}\tr\tj t \theta$}
 \AxiomC{$\G,\tj y{\psi\imp\phi}\tr\tj u \theta$}
 \BinaryInfC{$\G\tr\tj{
t[\comod c\psi {\co c}\phi/x]
   \conc
u[\comod{\co c}\phi c\psi/y]
}{\theta}$}
 \DisplayProof
 )
 First we claim that $\reader c\psi$ is in $\sem\psi$.
 For that, for any proper store~$S$ and a stack $\pi_\psi\in\nsem\psi$,
 we show that $e=[\reader c\psi,\pi_\psi],S$ is in $\bbot$.
 The reductions from $e$ are
 $e\red[S(\tj c\psi),\pi_\psi],S$ and
 $e\red\emptyset,S$ depending on whether $S(\tj c\psi)$ is a term in
 $\sem\psi$ or $\bot$.
 In the former case, since $S(\tj c\psi)$ is in $\sem\psi$ and $S$ is
 proper, $(S(\tj c\psi),S)$ is in $\sem\psi$, making
 the reduct $[S(\tj c\psi),\pi_\psi],S$ an element of $\bbot$.
 Otherwise, the reduct $\emptyset,S$ is in $\bbot$ by definition of a
 pole.
 Since at least one reduction from $e$
 leads to an element of $\bbot$,
 $e$ itself is an element of $\bbot$.
 We have shown the first claim that $\reader c\psi$ is in $\sem\psi$.
 We also claim that $\comod c\psi{\co c}\phi$ is in
 $\sem{\phi\imp\psi}$.
 For that, for any proper store~$S$,
 $v\in\sem\phi$ and $\pi\in\nsem\psi$, we show
 $e'=[\comod c\psi{\co c}\psi,v\cdot\pi],S$ is in $\bbot$.
 The only reduction from $e'$ is to $e'\red[\reader c\psi,\pi], S''$
 where $S''$ might be $S[\co c\colon\phi\mapsto v]$ or
 unchanged $S$ depending on $S(\co c\colon\phi)$.
 Anyway, since $v$ is in $\sem\phi_{\hat\Sigma}$,
 $S''$ is proper i.e. in $F(\hat\Sigma) = \hat\Sigma$.
 Since $S''$ is proper and $\pi$ is in $\nsem\psi$,
 we have $[\reader c\psi,\pi],S''\in\bbot$ because $\reader c\psi$ is in
 $\sem\psi$.
 Now take any $v_i\in\sem{\phi_i}$ and $\pi'\in\nsem \theta$.
 Since $\comod c\psi{\co c}\phi$ is in $\sem{\phi\imp\psi}$,
 by induction hypothesis,
 $t[\comod c\psi{\co c}\phi/x][v_i/x_i]$ is in $\sem \theta$.
 By a symmetric argument,
 $u[\comod {\co c}\phi c \psi/y][v_i/x_i]$ is also in $\sem \theta$.
 By Prop.~\ref{type-conc},
 $(t[\comod c\psi{\co c}\phi/x]\conc u[\comod {\co c}\phi c
 \psi/y])[v_i/x_i]$ is also in $\sem \theta$.

 (Abstraction
 \AxiomC{$\G,\tj x\phi\tr\tj t\psi$}
 \UnaryInfC{$\G\tr\tj{\lambda x.t}{\phi\imp\psi}$}
 \DisplayProof)
 With arbitrary $v_i\in\sem{\phi_i}$,
 $u\cdot\pi\in\nsem{\phi\imp\psi}$
 and a proper store~$S$,
 it is enough to show that
 $e = [\lambda x.t[v_i/x_i],u\cdot\pi],S$ is in $\bbot$.
 One reduction from $e$ is to
 $[t[v_i/x_i][\ast_u/x],\pi],S$.
 We claim that $\ast_u$ is in $\phi$.
 For that, taking any $\pi_\phi\in\nsem\phi$ and
 proper store~$S'$, showing
 $[\ast_u,\pi_\phi],S'\in\bbot$ is enough.
 Since a reduction from this executable is to
 $[u,\pi_\phi],S'$, which is in $\bbot$,
 $[\ast_u,\pi_\phi],S'$ is in $\bbot$,
 making $\ast_u$ an element of $\sem\phi$.
 Back to $t[v_i/x_i][\ast_u/x]$,
 by induction hypothesis,
 this term is in $\sem\psi$.
 This shows that the reduct of $e$,
 which is
 $[t[v_i/x_i][\ast_u/x],\pi],S$, is in $\bbot$.
 Consequently, $e$ is also in $\bbot$.

 (Mix)

 (Generalization)

 (Instantiation)

 (Axiom)
 \qed
\end{proof}

One might want to show this property.
\begin{example}
 Let
 $\tr\tj c
 {\forall X\forall A\forall B
 [((A\imp B)\imp X)
  \imp((B\imp A)\imp X)
  \imp X]}$
 be
 derivable.
 For all terms $\rho,\sigma, r$ and for all stacks $\pi, \pi_A$ and
 $\pi_B$,
 if $[(\rho)d  ,\pi], S'\reduce [d,a\cdot \pi_B], S''$ and
    $[(\sigma)f,\pi], S'\reduce [f,b\cdot \pi_A], S'''$ hold for all $d$,
 $f$ and $S$,
 then
 $[(c)(\rho)\sigma,\pi],S_\epsilon$ reduces to a multiset on
 $E = \{([a,\pi_A],S),([b,\pi_B],S)\mid S \text{ is a store}\}$.
\end{example}
However, the executables which reduce to a multiset on~$E$ does not form
a pole.  Since $\comod c\phi{\co c}\psi$ and $\comod {\co c}\psi c\phi$
are separate, they just turn into $\emptyset$, however, when they are
connected by $\conc$, they do not turn into $\emptyset$.

\section{Specification Using Existential Poles}

We seek to have a weaker condition on poles, and arrive at a
existential poles.

What we can readily show is the following.
\fix{define witness}
\begin{proposition}
 Let
 $\tr\tj c
 {\forall X\forall A\forall B
 [((A\imp B)\imp X)
  \imp((B\imp A)\imp X)
  \imp X]}$
 be
 derivable.
 For all terms $\rho,\sigma, r$ and for all stacks $\pi, \pi_A$ and
 $\pi_B$,
 if $[(\rho)d  ,\pi], S'\reduce [d,a\cdot \pi_B], S''$ and
    $[(\sigma)f,\pi], S'\reduce [f,b\cdot \pi_A], S'''$ hold for all $d$,
 $f$ and $S$,
 then
 $[(c)(\rho)\sigma,\pi],S_\epsilon$ reduces to a witness on
 $E = \{([a,\pi_A],S),([b,\pi_B],S)\mid S \text{ is a store}\}$.
\end{proposition}
\begin{proof}
 \fix{fill}
\end{proof}
We obtain non-abortfullness as a corollary of this proposition.

Another important property of an executable is
non-abortfullness
which states that the executable has no reduction sequence leading to
$\emptyset,S$.
The name comes from hyper-lambda calculus formulation in \fix{cite},
where a term sometimes turns into $\mathsf{abort}$ and there the property
stated that a hyperterm has no reduction sequence leading to a hyperterm
full of $\mathsf{abort}'s$.
This property is important because it ensures existence of
constructive content of proofs.

Non-abortfullness cannot be verified using poles
because any pole must have $\emptyset,S$ as an element for
any store~$S$.
This condition for poles is used in the
communication case of the proof of adequacy.
In order to prove non-abortfullness as a logical property,
we define another variant of poles called scheduled poles.


\section{Specification Using Scheduled Poles}

Since our calculus is non-deterministic,
some interesting properties have to mention
all possibilities.
For that, we use the concept of schedules?

\fix{find a property that can only be verified using scheduled poles}.
\fix{maybe exact specification}


\newcommand{\sche}{\sqsubseteq}
A \textit{schedule}~$\sche$ is a total order on channels.
If a channel~$c$ satisfies $\co c\sche c$, then it is called
an $\textit{active}$ channel on $\sche$.
The reduction relation on a schedule~$\sche$, which is written
$\red^\sche$ is defined in the same way as $\red$ but without the
(fail) condition for $\reader c\phi$ for any channel~$c$ with $\co c
\sche c$.

A \textit{run} is a nonempty finite sequence
$(e_i)_{i\in\{0,\ldots,n\}}$ of executables where
$e_i\red e_{i+1}$ holds for any $i\in\{0,\ldots,n\}$.
The run is \textit{compatible} to a schedule~$\sche$ iff
$e_i\red^\sche e_{i+1}$ for any $i\in\{0,\ldots,n-1\}$.

\begin{proposition}
 To any initialized run, there exists a compatible schedule.
\end{proposition}
\begin{proof}
 Seeking contradiction, assume a fail reduction occurs for both $\reader
 c\phi$ and $\reader{\co c}\psi$ in a run.
 Without loss of generality, we can assume that the fail reduction for
 $\reader c\phi$ occurs before that for $\reader{\co c}\psi$.
 Since the run is initialized\fix{define},
 before the fail reduction for $\reader c \phi$,
 there is a (write) reduction
 or (write') reduction for $\comod c\phi{\co c}\psi$.
 After that, the store maps $\co c\psi$ to a term.
 That contradicts our assumption that the fail reduction for $\co c\psi$
 occurs after that for $c\phi$.
\end{proof}

A \textit{scheduled pole}~$\bbot_\sche$ is a set of executables
which satisfies
\begin{enumerate}
 \item $e$ is in $\bbot$ if $e'\in\bbot_\sche$ for all
       $e'$ with $e\red^\sche e'$;
 \item if $(m,S)\in\bbot$ or $(m',S)\in\bbot_\sche$
       then $(m\conc m',S)\in\bbot_\sche$.
\end{enumerate}

\begin{proposition}
 If $t$ is in the set of terms $\sem{\phi}^\sche$, then
 $t\conc u$ and $u\conc t$ are in $\sem{\phi}^\sche$.
\end{proposition}
\fix{prove}

\fix{define quibbly: closed for taking prefix of stacks, has (x,epsilon)
as element}

\begin{proposition}[Scheduled Adequacy]
 Let $\tj{x_1}{\phi_1},\ldots,\tj{x_n}{\phi_n}\tr\tj t\psi$ be
 derivable,
 $\bbot_\sche$ be any scheduled pole,
 and $|\cdot|_0^-$ be any map from propositional variables to $2^\Pi$,
 then,
 for all $v_1\in\sem{\phi_1}_\sche,\ldots,v_n\in\sem{\phi_n}_\sche$, the
 term $t[v_1/x_1,\ldots,v_n/x_n]$ is in $\sem{\psi}_\sche$.
\end{proposition}
\begin{proof}
 By induction on derivation of $t$.

 (Communication
 \AxiomC{$\G,\tj x{\phi\imp\psi}\tr\tj t \theta$}
 \AxiomC{$\G,\tj y{\psi\imp\phi}\tr\tj u \theta$}
 \BinaryInfC{$\G\tr\tj{
t[\comod c\psi {\co c}\phi/x]
   \conc
u[\comod{\co c}\phi c\psi/y]
}{\theta}$}
 \DisplayProof
 )
 Since the schedule~$\sche$ is a total order on channels, without loss
 of generality, we can assume $\co c\subseteq c$.  Now we claim that
 $\reader c\psi$ is in $\sem{\psi}_\sche$.
 For that, for any proper store~$S$ and a stack
 $\pi_\psi\in\nsem\psi_\sche$,
 we show that $e=[\reader c\psi,\pi_\psi], S$ is in $\bbot_\sche$.
 \fix{now, a problem arises.  if S(c colon psi) is empty, what to do?
 it has no reduction to anything...  so, we have to think about it.
 maybe, one way is allowing this.  so we have to change the definition
 of scheduled pole}
 If $S(c\colon\psi) = \bot$, the definition of scheduled poles
 immidiately makes $e$ a member of $\bbot_\sche$.
 Otherwise, since $S$ is proper, $[S(c\colon\psi),\pi_\psi], S$ is in
 $\bbot$, making $e$ an element of $\bbot_\sche$.
 Using this, we can also show that $\comod c\psi{\co c}\phi$ is in $\sem
{\phi\imp\psi}_\sche$, in exactly the same manner as Prop.~\fix{fill}.
 By induction hypothesis,
 $t[\comod c\psi{\co c}\phi/x][v_i/x_i]$ is in $\sem{\theta}_\sche$.
 By defintion of scheduled poles,
 $t[\comod c\psi {\co c}\phi/x]
   \conc
  u[\comod{\co c}\phi c\psi/y]$ is in $\sem\theta_\sche$.
\end{proof}
\begin{remark}
 The mix rule can be made stronger.  \fix{fill}
\end{remark}

\begin{proposition}[Non-abortfullness]
Let $\tr\tj t\psi$ be derivable, then,
 $[t,\epsilon], S_\epsilon$ has no run leading to $\emptyset, S'$ for
 any store $S'$.
\end{proposition}
\begin{proof}
 For any run $(e_i)$, take a compatible schedule~$\sche$.
 For this $\sche$, we define $\bbot_\sche$ to be the set of executables
 which has no run compatible to $\sche$ leading to $\emptyset, S$ for
 any store~$S$.
 Then $\bbot_\sche$ is a scheduled pole.
 For any propositional variable~$A$, we define $\nsem{A}_0 =
 \{\epsilon\}$.
 Since $\bbot_\sche$ is quibbly, every type~$\phi$ has
 $\epsilon\in\nsem{\phi}_\sche$.
 By scheduled adequacy, $t$ is in $\sem \psi _\sche$.
\end{proof}


%%%%%%%% some texts

\section{Comparison with the Hypersequent Formulation}


\section*{where to put them}

Not all disjunctive tautologies are valid in G\"odel--Dummett logic:
$(P\imp Q)\lor(Q\imp R)$.

Non-abortfullness is not a pole.
In order to change this, we have to do something more subtle.
