\chapter{Some Disjunctive Tautologies as
  Asynchronous Communication Schemes}

	% packages
% \usepackage{setspace}
% \doublespacing

% \usepackage{bussproofs}
% \usepackage{graphicx}
% \usepackage{amssymb}

% % title, author, etc
% \title{Some Disjunctive Tautologies as\\
%  Asynchronous Communication Schemes}
% \author{Yoichi Hirai}

% \usepackage{amsmath}	% required for `\align*' (yatex added)
% \begin{document}

% \maketitle

\subsection{Summary}
%%% abstract
This work is a refinement of
Danos and Krivine's ``Disjunctive Tautologies as
Synchronisation Schemes.''
We show that some autologies,
namely the therems of G\"odel--Dummett logic,
can be viewed as asynchronous communication schemes.
We call these asynchronous because the operational semantics
of the communicating terms does not allow a term to wait for another
term.
In contrast to Danos and Krivine's \fix{cite} formulation,
where computation can wait for another,
our calculus is weaker and resides in a particular class of
distributed computation called waitfreedom.
This work is a reformulation of Hirai~\fix{cite} in the
second-order logic.
This allowed parametricity argument.
Also, differently from Hirai's \fix{cite} hypersequent formulation,
we succceed in describing the computational behaviour of the Dummett
(a.k.a symmetric excluded middle) in the implicational form: this
difference is to be discussed in Sect. \fix{?}.

%%% 1. introduction

% 1a operational semantics for GD case

% 1b difference from Danos--Krivine

%%% 2. terms types and _models_?
\section{Types and Terms}

% 2a terms -- unchanged -- remove pi or anything

\newcommand{\conc}{\parallel}
\newcommand{\comod}[2]{\ast^{\rightarrow {#2}}_{\leftarrow{#1}}}
\newcommand{\reader}[1]{\ast_{\leftarrow{#1}}}

We consider a programming language, which is a modification of
Danos and Krivine's.
We assume a set~$\pvar$ of propositional variables whose cardinality is
countably infinite.
For a set~$S$,
the set $\form(S)$ denotes the set of formulas:
\[
\phi::= s \mid X \mid \phi\imp\phi\mid \forall X \phi
\]
where $s\in S$ and $X\in \pvar$.
A type is an element of $\form(\emptyset)$.
Channels have involution $c\mapsto\co c$ with
$c\neq \co c$ and
$\co{\co c} = c$.
A \textit{term}~$t$ is defined by BNF:
\[
 t::= x
 \mid (t)t
 \mid t\conc t
 \mid \lambda x.t
 \mid \ast_t
 \mid \comod c c
 \mid \reader  c
\]
where $x$ is a variable and $c\colon\phi$ is a channel.
A \textit{stack}~$\pi$ is defined by BNF:
\[
 \pi ::= \epsilon
 \mid t\cdot \pi
 \enspace.
\]
We write the set of terms as $\Lambda$ and stacks~$\Pi$.
A \textit{store} is a partial mapping from locations to
terms, equivalently, a mapping from locations to terms and $\bot$'s.
The \textit{empty store}~$S_\epsilon$ maps any channel to $\bot$.
For a store $S$, we define a store $S[c\colon\phi\mapsto x]$ to be
the same as $S$ except that $S[c\colon\phi\mapsto x](c\colon\phi\mapsto
x)$ is $x$.
An \textit{executable} is a finite multiset on $\Lambda \times \Pi$,
paired with a store.

% 2a' reduction
\newcommand{\red}{\succ_1}
\renewcommand{\reduce}{\succ}
We have reduction relation~$\red$ on executables,
which is defined to be the smallest binary relation
that satisfies:
\begin{description}
 \item[(cong)] if
	    $[t,\pi],         S \red [ t',\pi'],        S'$
	    then
	    $[t,\pi \conc e], S \red [ t',\pi'\conc e], S'$\enspace;
 \item[(push)]
	    $[(t)u,\pi],S       \red [t,u\cdot\pi],S$;
 \item[(dist)]
	    $[t\conc u,\pi],S   \red [t,\pi\conc u,\pi],S$\enspace;
 \item[(store)]
	    $[\lambda x.t,u\cdot\pi],S
	     \red
	     [t[\ast_u/x],      \pi],S$\enspace;
 \item[(load)]
	    $[\ast_u,\pi],S\red[u,\pi],S$\enspace;
 \item[(write)]
	    $
	    [\comod c{\co c}, t\cdot\pi], S[\co
	    c\colon\psi\mapsto\bot]
	    \red
	    [\reader c, \pi],
	    S[\co c\colon\psi\mapsto t]
	    $\enspace;
 \item[(write')]
	    $
	    [\comod c{\co c}, t\cdot\pi], S[\co
	    c\colon\psi\mapsto u]
	    \red
	    [\reader c, \pi],
	    S[\co c\colon\psi\mapsto u]
	    $\enspace;
 \item[(read)]$
	    [\reader c ,\pi],
	    S[c\colon\phi\mapsto u]
	    \red
	    [u,\pi],
	    S[c\colon\phi\mapsto u]
	    $\enspace; and
 \item[(fail)]
	    $
	    [\reader c,\pi],
	    S[c\colon\phi\mapsto \bot]
	    \red
	    \emptyset,S[c\colon\phi\mapsto \bot]
	    $
	    \enspace.
\end{description}
We denote the reflexive transitive closure of $\red$ as $\reduce$.

% I want to write these rules are non-blocking here.
% but, actually, Danos and Krivines rules are also non-blocking.
% they just busy-wait.
% In order to remove busy-waiting, we need types.

% 2b type system -- remove pierce -- add com'

We type terms as follows.\\ \noindent
\AxiomC    {}
\LeftLabel {Axiom}
\UnaryInfC {$\G,\tj x \phi\tr \tj x \phi$}
\DisplayProof
    \ruleskip\noindent
%%
\AxiomC    {$\G,\tj x \phi\tr \tj t \psi$}
\LeftLabel {Abstraction}
\UnaryInfC {$\G\tr\tj{\lambda x.t}{\phi\imp\psi}$}
\DisplayProof
    \ruleskip\noindent
%%
\AxiomC    {$\G\tr\tj{t}{\phi\imp\psi}$}
\AxiomC    {$\G\tr\tj u \phi$}
\LeftLabel {Application}
\BinaryInfC{$\G\tr\tj{(t)u}{\psi}$}
\DisplayProof
    \ruleskip\noindent
%%
\AxiomC    {$\G\tr\tj t \phi$}
\LeftLabel {Generalization}
\UnaryInfC {$\G\tr\tj{t}{\forall X\phi}$}
\DisplayProof
($X$ not free in $\G$)
    \ruleskip\noindent
%%
\AxiomC    {$\G\tr\tj t{\forall X\phi}$}
\LeftLabel {Instantiation}
\UnaryInfC {$\G\tr\tj t{\phi[\psi/X]}$}
\DisplayProof
    \ruleskip\noindent
%%
\AxiomC    {$\G\tr\tj t \phi$}
\AxiomC    {$\G\tr\tj u \phi$}
\LeftLabel {Mix}
\BinaryInfC{$\G\tr\tj {t\conc u}{\phi}$}
\DisplayProof
    \ruleskip\noindent
%%
\AxiomC    {$\G,\tj x{\phi\imp \psi}\tr\tj t \theta$}
\AxiomC    {$\G,\tj y{\psi\imp \phi}\tr\tj u \theta$}
\LeftLabel {Communication}
\BinaryInfC{$
\G\tr\tj{
t[\comod c {\co c}/x]
   \conc
u[\comod{\co c} c/y]
  }{\theta}$}
\DisplayProof

We can implement something similar to Lafont's example,
showing that confluence does not hold.
Suppose $\G\tr\tj t\phi$ and $\G\tr\tj u\phi$ are both derivable.
Then, by induction on the derivation,
both $\G,\tj x{\phi\imp\phi}\tr\tj{(x)t}\phi$
and $\G,\tj y{\phi\imp\phi}\tr\tj{(y)u}\phi$ are derivable
for $x$ and $y$ not appearing in $\G$, $u$, or $t$.
By the communication rule,
$\G\tr\tj{(\comod c{\co c})t\conc(\comod {\co c} c)u}\phi$ is derivable.
But $[(\comod c{\co c})t\conc (\comod{\co c} c)u,
\pi],S_\epsilon$
can reduce both to $[t,\pi], S_\epsilon[c\mapsto u, \co c\mapsto t]$
and to $[u,\pi], S_\epsilon[c\mapsto u,\co c\mapsto t]$.
Since $t$ and $u$ were taken arbitrarily, we cannot distinguish terms
of the same type if we equate a term with what it reduces to.

\section{Specification Using Poles}

% 2C truth values and models. make them disjunctive!
%    so that the empty set does not count as successful.
%    Also, make it closed for ``for all''
A \textit{pole}~$\bbot$ is a set of executables
which satisfies
\begin{enumerate}
 \item $e$ is in $\bbot$ if $e'\in\bbot$ and
       $e\red e'$;
 \item $\emptyset, S$ is in $\bbot$ for any store~$S$; and
 \item if $(m,S)\in\bbot$ and $(m',S)\in\bbot$
       then $(m\conc m',S)\in\bbot$.
\end{enumerate}
For a set of executable~$E$, the pole generated by~$E$ is the smallest
pole containing~$E$.
This is well-defined because the condition for a pole is monotonic.
\begin{proposition}
 Let $e$ be a nonempty executable in the pole generated by $E$.
 Then $e$ reduces to a multiset on~$E$.
\end{proposition}
\begin{proof}
 \fix{prove}
\end{proof}

A term-store pair is a pair of a term and a store.
For a term~$t$, stack~$\pi$ and store~$S$, we identify $([t,\pi], S)$
as $((t,S), \pi)$
For a set~$\mathcal Z$ of stacks, $\mathcal Z\imp\bbot$ denotes
the largest set~$\mathcal X$ of term-store pairs such that
$\mathcal X\times\mathcal Z\subset \bbot.$
A set $\mathcal X$ of terms is called a truth value
iff there exists
such $\mathcal Z$ that $\mathcal X = \mathcal Z\imp \bbot$.

\renewcommand{\sem}[1]{|{#1}|}
\newcommand{\nsem}[1]{\sem{#1}^-}
For $F\in\form(2^\Pi)$ and $|\cdot|^-_0\colon\pvar\rightarrow 2^\Pi$,
and a set~$\Sigma$ of stores,
we define $\nsem{\phi}_\Sigma\colon \form(2^\Pi)\rightarrow
2^\Pi$ inductively as
\begin{align*}
 \nsem{\mathcal Z}_\Sigma &= \mathcal Z \\
 \nsem{X}_\Sigma&= |X|_0^- \\
 \nsem{\phi\imp\psi}_\Sigma&=
 \{t\cdot\pi\mid(t,S)\in\nsem\phi_\Sigma\rightarrow\bbot\text{ for all store
 }S\in \Sigma\text{ and }\pi\in\nsem\psi_\Sigma\}
 \\
 \nsem{\forall X\phi}_\Sigma&=
 \bigcup_{\mathcal Z\in 2^\Pi} \nsem{\phi[\mathcal Z/X]}_\Sigma
\end{align*}
Using this, we define $\sem \phi_\Sigma=\nsem{\phi}_\Sigma\rightarrow\bbot$.

When we abuse $\sem{\phi}$ as a set of terms,
$\sem{\phi}$ is the largest set~$\mathcal T$
with $\mathcal T\times\hat\Sigma\subset\sem{\phi}$.
With these notations, we have an equality
$\nsem{\phi\imp\psi} = \{t\cdot\pi\mid
t\in\sem\phi\text{ and }\pi\in\nsem\psi\}$.

\begin{proposition}
 \label{type-conc}
 The set $\sem\phi$ of terms is closed for $\conc$.
\end{proposition}
\begin{proof}
 Assuming $t$ and $u$ are in $\sem\phi$, we show $t\conc u$ is also in
 $\sem\phi$.
 By definition of $\sem\phi$, both $(t,S)$ and $(u,S)$ are in $\sem\phi$
 for any proper store~$S$.
 In other words, for any $\pi\in\nsem\phi$,
 both $[t,\pi],S$ and $[u,\pi],S$ are in $\bbot$.
 By definition of a pole,
 $[t\conc u,\pi],S$ is also in $\bbot$,
 making $(t\conc u, S)$ an element of $\sem\phi$, further ensuring
 membership of $t\conc u$ with regard to $\sem\phi$.\qed
\end{proof}
% 2d the adequacy lemma
\begin{proposition}[Adequacy]
 Let $\tj{x_1}{\phi_1},\ldots,\tj{x_n}{\phi_n}\tr\tj t \psi$ be derivable,
 $\bbot$ be any pole,
 and $|\cdot|_0^-$ be any map from propositional variables to
 $2^\Pi$, then, for all
 $v_1\in\sem{\phi_1},\ldots,v_n\in\sem{\phi_n}$,
 the term $t[v_1/x_1,\ldots,v_n/x_n]$ is in $\sem\psi$.
\end{proposition}
\begin{proof}
 By induction on the derivation of~$t$.

 (Application
 \AxiomC    {$\G\tr\tj{t}{\phi\imp\psi}$}
 \AxiomC    {$\G\tr\tj u \phi$}
 \BinaryInfC{$\G\tr\tj{(t)u}{\psi}$}
 \DisplayProof )

 (Communication
 \AxiomC{$\G,\tj x{\phi\imp\psi}\tr\tj t \theta$}
 \AxiomC{$\G,\tj y{\psi\imp\phi}\tr\tj u \theta$}
 \BinaryInfC{$\G\tr\tj{
t[\comod c {\co c}/x]
   \conc
u[\comod{\co c} c/y]
}{\theta}$}
 \DisplayProof
 )

 (Abstraction
 \AxiomC{$\G,\tj x\phi\tr\tj t\psi$}
 \UnaryInfC{$\G\tr\tj{\lambda x.t}{\phi\imp\psi}$}
 \DisplayProof)

 (Mix)

 (Generalization)

 (Instantiation)

 (Axiom)
 \qed
\end{proof}

One might want to show this property.
\begin{example}
 Let
 $\tr\tj c
 {\forall X\forall A\forall B
 [((A\imp B)\imp X)
  \imp((B\imp A)\imp X)
  \imp X]}$
 be
 derivable.
 For all terms $\rho,\sigma, r$ and for all stacks $\pi, \pi_A$ and
 $\pi_B$,
 if $[(\rho)d  ,\pi], S'\reduce [d,a\cdot \pi_B], S''$ and
    $[(\sigma)f,\pi], S'\reduce [f,b\cdot \pi_A], S'''$ hold for all $d$,
 $f$ and $S$,
 then
 $[(c)(\rho)\sigma,\pi],S_\epsilon$ reduces to a multiset on
 $E = \{([a,\pi_A],S),([b,\pi_B],S)\mid S \text{ is a store}\}$.
\end{example}
However, the executables which reduce to a multiset on~$E$ does not form
a pole.  Since $\comod c{\co c}$ and $\comod {\co c} c$
are separate, they just turn into $\emptyset$, however, when they are
connected by $\conc$, they do not turn into $\emptyset$.

Another important property of an executable is
non-abortfullness
which states that the executable has no reduction sequence leading to
$\emptyset,S$.
The name comes from hyper-lambda calculus formulation in \fix{cite},
where a term sometimes turns into $\mathsf{abort}$ and there the property
stated that a hyperterm has no reduction sequence leading to a hyperterm
full of $\mathsf{abort}'s$.
This property is important because it ensures existence of
constructive content of proofs.

Non-abortfullness cannot be verified using poles
because any pole must have $\emptyset,S$ as an element for
any store~$S$.
This condition for poles is used in the
communication case of the proof of adequacy.
In order to prove non-abortfullness as a logical property,
we define another variant of poles called scheduled poles.


\fix{find a property that can only be verified using scheduled poles}.
\fix{maybe exact specification}


\newcommand{\sche}{\sqsubseteq}

\begin{proposition}[Non-abortfullness]
Let $\tr\tj t\psi$ be derivable, then,
 $[t,\epsilon], S_\epsilon$ has no run leading to $\emptyset, S'$ for
 any store $S'$.
\end{proposition}
\begin{proof}
\end{proof}


%%%%%%%% some texts

\section{Comparison with the Hypersequent Formulation}


\section*{where to put them}

Not all disjunctive tautologies are valid in G\"odel--Dummett logic:
$(P\imp Q)\lor(Q\imp R)$.

Non-abortfullness is not a pole.
In order to change this, we have to do something more subtle.
