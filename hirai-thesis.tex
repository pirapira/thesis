\documentclass[doctor]{iscs-thesis}

\usepackage{amsmath, stmaryrd, rotating, amssymb,
setspace, float, amsthm}
\usepackage{bussproofs}

\newcommand{\R}[1]{{#1}^{\mathsf R}}
\newcommand{\vdashR}{\vdash}
\newcommand{\vdashRLB}{\vdash}
\newcommand{\ruleskip}{\vskip 5mm}


\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}



\newcommand{\fix}[1]{\fbox{ #1 }}

\newcommand{\nat}{\mathbb{N}}
\newcommand{\steps}[2]{Steps_{#1}\left({#2}\right)}

\newcommand{\hypc}[2]{{\mathcal{C}#1}\left[{#2}\right]}
\newcommand{\hyper}{\mathcal{H}}
\newcommand{\hypert}{\mathcal{O}}
\newcommand{\hmid}{\mid\mid\mid}

\newcommand{\tr}{\vartriangleright}
\newcommand{\update}{\vartriangleleft}

\newcommand{\elim}{\mathcal E}
\newcommand{\intro}{\mathcal I}

\newcommand{\coml}{\leftarrow_{\mathrm g}}
\newcommand{\comr}{\leftarrow_{\mathrm d}}

\newcommand{\reduce}{\rightsquigarrow}
\newcommand{\reduction}{\reduce^\ast}
\newcommand{\processes}{\mathbb{P}}
\newcommand{\ProV}{\mathbf{ProV}}
\newcommand{\LB}{\textbf{LB}}
\newcommand{\p}[1]{\texttt{#1}}
\newcommand{\tuple}[1]{\langle{#1}\rangle}

%% terms
\newcommand{\g} [0]{\mathsf{g}}
\newcommand{\spair} [1]{\langle{#1}\rangle^{\square}}
\newcommand{\lpair} [1]{\langle{#1}\rangle}
\newcommand{\gpair} [1]{\langle{#1}\rangle^{\g}}
\newcommand{\cotuple}[1]{[{#1}]}
\newcommand{\ev}[1]{\mathsf{ev}\left({#1}\right)}

\newcommand{\ginl}[1]{\mathsf{inl}^{\g}\left({#1}\right)}
\newcommand{\linl}[1]{\mathsf{inl}\left({#1}\right)}
\newcommand{\sinl}[1]{\mathsf{inl}^{\square}\left({#1}\right)}
\newcommand{\bsinl}[1]{\mathsf{inl}^{\blacksquare}\left({#1}\right)}

\newcommand{\ginr}[1]{\mathsf{inr}^{\g}\left({#1}\right)}
\newcommand{\linr}[1]{\mathsf{inr}\left({#1}\right)}
\newcommand{\sinr}[1]{\mathsf{inr}^{\square}\left({#1}\right)}
\newcommand{\bsinr}[1]{\mathsf{inr}^{\blacksquare}\left({#1}\right)}

\newcommand{\gpil}[1]{\pi^{\g}_{\mathrm l}\left({#1}\right)}
\newcommand{\lpil}[1]{\pi_{\mathrm l}\left({#1}\right)}
\newcommand{\spil}[1]{\pi^{\square}_{\mathrm l}\left({#1}\right)}

\newcommand{\gpir}[1]{\pi^{\g}_{\mathrm r}\left({#1}\right)}
\newcommand{\lpir}[1]{\pi_{\mathrm r}\left({#1}\right)}
\newcommand{\spir}[1]{\pi^{\square}_{\mathrm r}\left({#1}\right)}

\newcommand{\vg}[2]{{#1}_{#2, \mathrm g}}
\newcommand{\vd}[2]{{#1}_{#2, \mathrm d}}


\newcommand{\gmat}[5]{\mathsf{match}^{\g}\,{#1}\,\mathsf{of}\, \ginl{#2}. {#3}/
\ginr{#4}. {#5}}
\newcommand{\lmat}[5]{\mathsf{match}\,{#1}\,\mathsf{of}\, \linl{#2}. {#3}/
\linr{#4}. {#5}}
\newcommand{\smat}[5]{\mathsf{match}^{\square}\,{#1}\,\mathsf{of}\, \sinl{#2}. {#3}/
\sinr{#4}. {#5}}
\newcommand{\bsmat}[5]{\mathsf{match}^{\blacksquare}\,{#1}\,\mathsf{of}\, \bsinl{#2}. {#3}/
\bsinr{#4}. {#5}}

\newcommand{\ifte}[3]{\mathsf{If}\, {#1}\, \mathsf{then}\, {#2}\, \mathsf{else}\, {#3}}

\newcommand{\ltor}[4]{\overrightarrow{{#2}^{#1}_{#3}} \left({#4}\right)}
\newcommand{\rtol}[4]{\overleftarrow{{#2}^{#1}_{#3}} \left({#4}\right)}
\newcommand{\abort}{\mathsf{abort\,}}

\newcommand{\compare}[2]{{#1} == {#2}}

\newcommand{\term} [0]{\mathcal{T}}
\newcommand{\lterm}[0]{\mathcal{T}^-}
\newcommand{\val}  [0]{\mathcal{V}}
\newcommand{\lval} [0]{\mathcal{V}^-}
\newcommand{\tj}   [2]{ {#1} \colon{#2} }

\newcommand{\Nat}{\mathsf{Nat}}
\newcommand{\pvar}{\mathsf{Pvar}}
\newcommand{\wvar}{\mathsf{Wvar}}
\newcommand{\wor}{\mathsf{{or}}}
\newcommand{\agents}{\mathsf{A}}
\newcommand{\fml}{\mathsf{Fml}}

\newcommand{\Id}{\mathsf{Id}}
\newcommand{\lgd}{$\lambda$-GD}

%% configuration
\newcommand{\lstore}{{\sigma}}
\newcommand{\rstore}{{\tau}}
\newcommand{\conf}[3]{(\lstore{#1},\rstore{#2},{#3})}
\newcommand{\confwithcontext}[3]{\conf{#1}{#2}{\hypert\hmid C[{{#3}}]\hmid\hypert'}}
\newcommand{\concreteconf}[3]{({#1},{#2},{#3})}

%% reductions and the like
\newcommand{\breduce}{\reduce_{\mathrm B}}
\newcommand{\areduce}{\reduce_{\mathrm A}}
\newcommand{\wreduce}{\reduce_{\mathrm W}}
\newcommand{\rreduce}{\reduce_{\mathrm R}}
\newcommand{\preduce}{\reduce_{\mathrm P}}
\newcommand{\bpreduce}{\reduce_{\mathrm{B/P}}}

%% logical rules
\newcommand{\UnaryRule}[3]{ \AxiomC{#1}
\LeftLabel{#2}
\UnaryInfC{#3} \DisplayProof} 
\newcommand{\BinaryRule}[4]{ \AxiomC{#1} \AxiomC{#2}
\LeftLabel{#3}
\BinaryInfC{#4}\DisplayProof}
\newcommand{\TrinaryRule}[5]{ \AxiomC{#1} \AxiomC{#2}
\AxiomC{#3} \LeftLabel{#4}
\TrinaryInfC{#5} \DisplayProof}

%% investi
\newcommand{\inv}[1]{{#1}^{\mathsf i}}

\newcommand{\rightlocal}{\rightsquigarrow_{\beta{\mathrm l}}}
\newcommand{\rightcomm}{\rightsquigarrow_{\beta{\mathrm c}}}
\newcommand{\rightdist}{\rightsquigarrow_{\beta{\mathrm d}}}
\newcommand{\id}[1]{\mathsf{id}_{#1}}
\newcommand{\dist}[2]{[{#1}; {#2}]}

\newcommand{\interpret}[1]{\llbracket {#1} \rrbracket}

\newcommand{\memory}{{\mathrm m}}
\newcommand{\process}{p}
\newcommand{\contex}[1]{\mathcal C[{#1}]}
\newcommand{\sem}[1]{\llbracket{#1}\rrbracket}
\newcommand{\semi}[1]{\llparenthesis{#1}\rrparenthesis}

\newcommand{\wwedge}{\operatorname*{\bigwedge\kern -8pt \bigwedge}}

\etitle{A Computational Interpretation of G\"odel--Dummett Logic}


\begin{document}

\paragraph{Acknowledgement.}
The work about Hyper $\lambda$ calculus is encouraged by feedbacks from
ACAN (Algebraic and
Coalgebraic
Approaches to
Non-Classical Logics Workshop) and OPLSS'11 participants,
supported by Grant-in-Aid for JSPS Fellows 23-6978,
and partly prepared during the author's stay in
ILPS, the University of Amsterdam.


Many of the contents also appear in the author's Master's Thesis \fix{cite}.

\chapter{Introduction}

We extended the Curry--Howard correspondence to G\"odel--Dummett logic.
The Curry--Howard correspondence is \fix{add}

G\"odel--Dummett logic is an intermediate logic \fix{cite} between
classical logic and intuitionistic logic.  Every theorem in
intuitionistic logic is a theorem in G\"odel--Dummet logic and every
theorem in G\"odel--Dummett logic is a theorem in classical logic.
The inclusion is strict.  The law of excluded middle
$\varphi\vee(\varphi\supset \bot)$ is not a theorem in G\"odel--Dummett
logic and $(\varphi\supset\psi)\vee(\psi\supset\varphi)$ is not a
theorem in intuitionistic logic.

Without modalities.


In terms of Kripke semantics, the axiom is sound and complete for
requiring that the models are linearly ordered.
In terms of algebraic semantics, the axiom is sound and complete for
requiring that the truth values are linearly ordered.  \fix{ is this
usage of ``truth values'' correct? }
In terms of computation, what is it?


who said logic is about temporality.
Waitfreedom is a kind of temporality appeared in computer science.
This research shows that the proof theory is not only about abstract notions of temporality, but also about concrete notions of temporality appearing in computer science.



\section{Curry--Howard Correspondence for Different Logics}

Prawitz

Pfenning

Davies--Pfenning S4 A Modal Analysis of Staged Computation
  
Curien

Hypersequent

Game

\section{Location Aware Languages}

X10


Hypersequents were born to solve proof theoretical difficulties, but we
apply hypersequents to solve distributed computational difficulties.

\chapter{Properties}

\section{Finite Model Property}

\fix{just put NASSLLI paper here.}

\chapter{Waitfree Protocols in Logical Form}


\section{Introduction}

We proved finite model property of a class of intermediate modal logics
using analytic tableaux.
The target logics have Kripke frames where modalities are interpreted as
functions over the frame.  Moreover, each logic is parametrized by a
set of restrictions.  Each restriction is a disjunction of some
inequalities posing restrictions on the shape of the frame.

The target class of intermediate modal logics is a generalization of
intuitionistic epistemic logic proposed by Hirai~\cite{hirailpar}.
He used intuitionistic epistemic logic in order to model shared memory
consistencies, which are criteria that guarantees levels of
synchronization among different processes.
Both shared memory consistencies and some intermediate modal logics
can be characterized as a restriction on
partially-ordered structure:
Kripke frames for intermediate modal logics
and executions for shared memory
consistencies~\cite{steinke2004unified}.
He regarded Kripke frames as executions in order to translate
an intermediate modal logic into a shared memory
consistency.

However, he did not show finite model property for those
intermediate modal logics.  When software engineers talk about shared
memory consistencies, they assume an execution is finite.
When we think of Kripke models as executions, we are obliged to show
that the model is finite.
Especially when we want to construct a specific counterexample execution,
we have to build a \textit{finite} Kripke model.

For example,
under \textit{sequential consistency logic}, which is intuitionistic epistemic
logic along with the axioms of the form
$(K_m\varphi\supset K_m\psi) \vee (K_m\psi\supset K_m\varphi)$,
the formula $K_aK_mK_aI \supset K_bK_mK_bJ\supset K_bI$ is not a
theorem.
In terms of shared memory consistency, this means that even when a
process~$a$ has put information~$I$ on the shared memory and got a
successful acknowledgement from the shared memory and the other
process~$b$ does the same with information~$J$, it is not always the
case that process~$b$ has obtained information~$I$\kern -2pt.
In other words, there are executions without this property.
This can be confirmed via
finite model property for sequential consistency logic.
We show this property in a generalized form.

\section{The Target Logics}
 \label{logic}

The class of logics that we consider is a generalization of
intuitionistic propositional logic.
The class of logics also contains G\"{o}del--Dummett logic~\cite{dummett59}
and the intuitionistic epistemic logic proposed by 
Hirai~\cite{hirailpar}.
Let us assume that
there are a countably infinite set~$\pvar$ of \textit{propositional variables} and a 
finite set~$\agents$ of \textit{agents}. 

\begin{definition}
We define the set~$\fml$ of formulas by BNF:
\[
 \varphi,\psi ::= \bot\mid I\mid K_a\varphi\mid (\varphi\vee\psi)\mid
 (\varphi\wedge\psi)\mid (\varphi\supset\psi)
\]
 where $a$ is an agent in $\agents$
 and $I$ is a propositional variable in~$\pvar$.
\end{definition}

For a set of formulas $\Gamma\!$, notation $K_a\Gamma$ denotes the set
$\{K_a\varphi\mid\varphi\in\Gamma\}$\enspace.

\begin{definition}[Kripke frame]
A \textit{frame} $\tuple{W,\preceq,(f_a)_{a\in \agents}}$ is a tuple where
\begin{itemize}
 \item $\tuple{W,\preceq}$ is a partially ordered set, and
 \item each $f_a\colon W\rightarrow W$ is a monotonic function with
       respect to~$\preceq$.
\end{itemize} 
\end{definition}

\begin{definition}[Kripke model]
A \textit{model} $\tuple{W,\preceq, (f_a)_{a\in \agents},\rho}$ is a tuple where
\begin{itemize}
 \item $\tuple{W,\preceq,(f_a)_{a\in \agents}}$ is a frame, and
 \item $\rho\colon \pvar\rightarrow 2^W$ is a function that maps every
       propositional variable to a upward-closed subset of $W\!$.
\end{itemize} 
\end{definition}

We are going to prove finite model property for a class of
intermediate modal logics.  The logics are parametrized with
world restriction sets,  which we are going to define.
We assume that there is a countably infinite set of \textit{world
variables}~$\wvar$.
We use $\mathsf v, \mathsf w,\ldots$ to denote world variables.
We define \textit{world terms} using BNF:
\[
 \mathsf s::=\mathsf v\mid \mathsf s.a
\]
where $a$ is an agent.
Every world term can be written as $\mathsf v.s$ where $s$ is a fintie sequence
of agents (a postfix).
A \textit{world inequality} is an inequation of the form $\mathsf s\le
\mathsf t$ where $\mathsf s$ and $\mathsf t$ are world terms.
\begin{definition}
A world restriction is a sequence of world inequalities jointed
 by~$\wor$ formed like
 $\mathsf v_0.s_0\le\mathsf v_1.t_1\wor\cdots\wor
 \mathsf v_{n-1}.s_{n-1}\le\mathsf v_n.t_n\wor \mathsf v_n.s_n\le\mathsf
 v_0.t_0$ that satisfies either
 \begin{itemize}
  \item (single clause) $n=0$, or
  \item (single postfix) $s_i = t_i = s_j = t_{j}$ for $0\le i,j\le n$.
 \end{itemize}
\end{definition}
A \textit{world restriction set} is a finite set of world restrictions.

A \textit{world valuation} maps a world variable into a world of a frame.
We extend a world valuation on world variables
$\delta\colon\mathcal V_W\rightarrow W$ to that on world terms
inductively as $\delta(\mathsf s.a)=f_a(\delta(\mathsf s))$.
A frame $\tuple{W,\preceq, 1,(f_a)_{a\in\agents}}$ satisfies a world inequality
$\mathsf s\le\mathsf t$ iff $\delta(\mathsf s)\preceq \delta(\mathsf t)$
for all $\delta\colon\mathcal V_W\rightarrow W$.
A frame~$F$ satisfies a world restriction $\mathsf r$
iff $M$ satisfies $\delta(\mathsf r)$ for any world valuation~$\delta$.
For example, a frame satisfies $\mathsf v\le \mathsf w\wor\mathsf
w\le\mathsf v$ iff the frame is totally ordered.
An $\mathsf R$-frame is a frame that
satisfies all world restrictions in~$\mathsf R$.
An $\mathsf R$-model is a model with an $\mathsf R$-frame.

\newcommand{\modelsR}{\models_{\mathsf R}}

\begin{definition}
 We define the \textit{validity relation} $M,w\models\varphi$ over a model
 $M = \tuple{W,\preceq,(f_a)_{a\in \agents},\rho}$, a state~$w\in W$ and a
 formula~$\varphi$ inductively on $\varphi$.
 In this definition, let
 us abbreviate $M,w\models \varphi$ into $w\models \varphi$\enspace.
\newcommand{\m}{}
\begin{itemize}
\item $w\models \bot$ never holds.
\item $w\models I$ iff
$w \in
 \rho(I)$.
\item	    $w\models K_a \psi$ iff
	    $f_a(w)\models \psi$.
\item $w\models \psi_0\wedge\psi_1$ iff both
 $w\models \psi_0$ and $w\models \psi_1$ hold.
\item
 $ w\models \psi_0\vee\psi_1$ iff either
 $ w\models \psi_0$ or $w\models \psi_1$ holds.
\item
	   $w\models \psi_0\supset\psi_1$ iff 
	   $w'\succeq w$ and $w'\models \psi_0$ imply
	   $w'\models\psi_1$ for any $w'\in W$\enspace.
\end{itemize}
\end{definition}
A model~$M$ \textit{satisfies} $\varphi$ iff $M,w\models\varphi$ holds for any
state~$w$ of~$M$.
A formula~$\varphi$ is \textit{valid under} $\mathsf R$ iff
every $\mathsf R$-model~$M$ satisfies $M\models \varphi$.
For this, we write $\modelsR \varphi$\enspace.

\begin{lemma}[Kripke monotonicity]
 \label{monot}
 $M,w\models\varphi$ and $w\preceq v$ imply 
$M,v\models\varphi$.
\end{lemma}
\begin{proof}
 Induction on~$\varphi$.
 We use monotonicity of $f_a$ here.
\end{proof}

\paragraph{The proof system.}
Since both $\pvar$ and $\wvar$ are countably infinite,
there is an injection that maps a world variable to a propositional
variable.
We fix one such injection
$\mathsf w\mapsto I_{\mathsf w}$.
Inductively on the construction of world terms,
we assign a formula~$[\mathsf t]$ to every world term~$\mathsf t$:
\begin{itemize}
 \item for a world term $\mathsf w\in \wvar$, we define $[\mathsf w]$ to be
       $I_{\mathsf w}$,
 \item for a world term $\mathsf{s.a}$, we construct
 a formula $[\mathsf{s.a}]$ by
replacing every propositional variable~$P$ with $K_aP$ in $[\mathsf s]$.
\end{itemize}
Note that the sequence $\mathsf{.a.b.c}$ is translated into the same
order $K_a K_b K_c$ although a postfix is translated into a prefix.
We define $K_s\varphi$ as $[\mathsf w.s][\varphi/I_{\mathsf w}]$.
Also, we define $f_b\circ f_a$ as $f_{ab}$.  This ensures $M, w\models
K_s\varphi\Leftrightarrow M,f_s(w)\models\varphi$.

This translation of world terms into formulas
enables us to translate world inequalities and world restrictions
into formulas:
\begin{itemize}
 \item $[\mathsf s\le \mathsf t] := [\mathsf s]\supset [\mathsf t]$, and
 \item $[\mathsf{s_0}\le \mathsf{t_0}\wor \cdots\wor \mathsf{s_n}\le \mathsf{t_n}] := [\mathsf{s_0}\le \mathsf{t_0}]\vee
       \cdots \vee [\mathsf{s_n}\le \mathsf{t_n}]$ \enspace.
\end{itemize}

We define $\mathbf{Ax}(\mathsf R)$ to be the substitution closure of
$\{[\mathsf r]\mid \mathsf r\in \mathsf R\}$.
The substitution closure of a set~$S$ of formulas is defined as
$\{\varphi[\psi/P]\}$ where $\psi$ run freely on~$\fml$ and $P$ on~$\pvar$.

\begin{figure}[t]
\begin{center}
 \def\fCenter{\vdashR}
\AxiomC{}
\LeftLabel{(axiom)}
\UnaryInf$\varphi \fCenter \varphi$
 \DisplayProof
\hfill
\Axiom$\Gamma\fCenter\varphi$
\LeftLabel{(weakening)}
 \UnaryInf$\psi,\,\Gamma\fCenter\varphi$
\DisplayProof
 \hfill
\Axiom$ \varphi,\,\varphi,\,\Gamma\fCenter\psi$
\LeftLabel{(contraction)}
\UnaryInf$\varphi,\,\Gamma\fCenter\psi$
\DisplayProof
\ruleskip
\Axiom$\Gamma, \varphi,\psi,\, \Gamma'\fCenter\theta$
\LeftLabel{(exchange)}
\UnaryInf$\Gamma,\,\psi,\varphi,\,\Gamma'\fCenter\theta$
\DisplayProof
\hfill
\Axiom$\Gamma\fCenter\varphi$
\Axiom$\Gamma'\fCenter\psi$
\LeftLabel{($\wedge$-I)}
\BinaryInf$\Gamma,\Gamma'\fCenter \varphi\wedge\psi$
\DisplayProof
\hfill
\Axiom$\Gamma\fCenter \varphi$
\LeftLabel{($\vee$-I$_0$)}
\UnaryInf$\Gamma\fCenter \varphi\vee\psi$
\DisplayProof
\ruleskip
\Axiom$\Gamma\fCenter \varphi$
\LeftLabel{($\vee$-I$_1$)}
\UnaryInf$\Gamma\fCenter \psi\vee\varphi$
\DisplayProof
\hfill
\Axiom$\Gamma \fCenter\varphi\wedge\psi$
\LeftLabel{($\wedge$-E$_0$)}
\UnaryInf$\Gamma\fCenter \varphi$
\DisplayProof
\hfill
\Axiom$\Gamma\fCenter \varphi\wedge\psi$
\LeftLabel{($\wedge$-E$_1$)}
\UnaryInf$\Gamma\fCenter \psi$
\DisplayProof
\ruleskip
\Axiom$\Gamma\fCenter \psi_0\vee\psi_1$
\Axiom$\Gamma,\,\psi_0\fCenter \varphi$
\Axiom$\Gamma,\,\psi_1\fCenter \varphi$
\LeftLabel{($\vee$-E)}
\TrinaryInf$\Gamma\fCenter \varphi$
\DisplayProof
\vskip 5mm
\Axiom$\varphi,\,\Gamma\fCenter\psi$
\LeftLabel{($\supset$-I)}
\UnaryInf$\Gamma\fCenter \varphi\supset\psi$
\DisplayProof
\hfill
\Axiom$\Gamma\fCenter\psi_0\supset\psi_1$
\Axiom$\Gamma\fCenter \psi_0$
\LeftLabel{($\supset$-E)}
\BinaryInf$\Gamma\fCenter \psi_1$
\DisplayProof
\hfill
\Axiom$\Gamma\fCenter\bot$
 \LeftLabel{($\bot$-E)}
 \UnaryInf$\Gamma\fCenter\varphi$
 \DisplayProof
\ruleskip
\AxiomC{}
\LeftLabel{($\vee K$)}
 \UnaryInf$K_a(\varphi\vee\psi)\fCenter (K_a \varphi)\vee K_a\psi$
\DisplayProof
 \hfill
 \AxiomC{}
 \LeftLabel{($\varphi\in \mathbf{Ax}(\mathsf R)$)}
 \UnaryInf$\fCenter\varphi$
 \DisplayProof
 \ruleskip
 \Axiom$\Gamma\fCenter\varphi$
 \LeftLabel{(necessitation)}
 \UnaryInf$K_a\Gamma\fCenter K_a\varphi$
 \DisplayProof
\end{center}
\caption{Deduction rules of $\vdashR$.}
\label{fig}
\end{figure}

\begin{definition}
 We define the proof system $\vdashR$ by Fig.~\ref{fig}.
\end{definition}

\begin{theorem}
 \label{sound-comp-nat-kripke}
 $\Gamma\vdashR\varphi\Longleftrightarrow\Gamma\modelsR \varphi$\enspace.
\end{theorem}
We put the proof in Appendix~\ref{app} because the method is
standard.

\subsection{Examples}

\paragraph{Classical logic.}
When
$\mathsf R = \{\mathsf v\le\mathsf w\wor\mathsf w\le\mathsf x\wor\mathsf x\le\mathsf
v\}$,
the corresponding axioms can be obtained as follows:
\begin{align*}
[ \mathsf v\le \mathsf w\wor \mathsf w\le\mathsf x\wor \mathsf x\le\mathsf v ] &=
(I_{\mathsf v}\supset I_{\mathsf w})\vee (I_{\mathsf w}\supset
I_{\mathsf x})\vee (I_{\mathsf x}\supset I_{\mathsf v})
\\
\mathbf{Ax}(\mathsf R) = \mathbf{Ax}(\{\mathsf v\le\mathsf w\wor \mathsf
w\le \mathsf x \wor \mathsf x\le\mathsf v\}) &= \{(\varphi\supset\psi)\vee(\psi\supset\chi)\vee(\chi\supset\varphi)\}.
\end{align*}
$\mathbf{Ax}(\mathsf R)$ is equivalent to the excluded middle so $\mathsf R$ defines
classical logic.

\paragraph{G\"{o}del--Dummett logic.}
When $\mathsf R=\{\mathsf v\le\mathsf w\wor\mathsf w\le\mathsf v\}$,
the corresponding axioms can be obtained as follows:
\begin{align*}
[\mathsf v\le \mathsf w\wor \mathsf w\le\mathsf v] &=
(I_{\mathsf v}\supset I_{\mathsf w})\vee (I_{\mathsf w}\supset
I_{\mathsf v})\\
\mathbf{Ax}(\mathsf R) = \mathbf{Ax}(\{\mathsf v\le\mathsf w\wor \mathsf
w\le \mathsf v\}) &= \{(\varphi\supset\psi)\vee(\psi\supset\varphi)\mid
\varphi,\psi\colon\mbox{formula}\}.
\end{align*}
$\mathbf{Ax}(\mathsf R)$ coincides with the axioms of
G\"{o}del--Dummett logic~\cite{dummett59}.

\paragraph{Sequential consistency logic.}
When $\mathsf R=\{\mathsf v.\mathsf m\le\mathsf w.\mathsf m\wor \mathsf
w.\mathsf m\le \mathsf v.\mathsf m\}$,
the corresponding set of axioms
$\mathbf{Ax}(\mathsf R) = \{(K_{\mathsf m}\varphi\supset K_{\mathsf
m}\psi)\vee(K_{\mathsf m}\psi\supset K_{\mathsf m}\varphi)\mid \varphi,
\psi\colon\mbox{formula}\}$
 axiomatizes sequential consistency logic,
which is proposed by Hirai~\cite{hirailpar} for modeling a shared memory consistency called sequential consistency.


\section{Finite Model Property}
\label{fmp-proof}

This is our main result.
\begin{theorem}
 \label{fmp}
 $\vdashR\varphi$ holds iff $M\models \varphi$ holds
 for all finite {\sf R}-model $M$.
\end{theorem}

We use another deduction system\,\LB\,in order to obtain finite model
property.
The outline of the proof is these circular implications:
\begin{align*}
 \vdashRLB\varphi &\Longrightarrow \quad \models_{\mathsf R}\varphi\quad
 &(\mbox{by Lemma~\ref{sound}})\\
 &\Longrightarrow \quad \vdash_{\mathsf R}\varphi &(\mbox{by
 Thm.~\ref{sound-comp-nat-kripke}}) \\
 &\Longrightarrow\quad \modelsR\varphi &\mbox{(by Thm.~\ref{sound-comp-nat-kripke})}\\
 &\Longrightarrow\quad M\models\varphi \mbox{ for any finite $\mathsf
 R$-model }M\\
 &\Longrightarrow\quad \vdashRLB\varphi & (\mbox{by
 Lemma~\ref{R-fmp}})\enspace .
\end{align*}
This method extends Waaler
and Wallen's method for intuitionistic logic~\cite{waaler1999tableaux}.

\subsection{\LB}

The deduction system\,\LB\,uses \textit{prefixed formulas}.  A
prefixed formula is shaped like $\mathsf s::\varphi$ where $\mathsf s $
is a world term and $\varphi$ is a formula.
Informally, this prefixed formula means that the formula~$\varphi$ is
satisfied in a state referenced by~$\mathsf s$.
A \textit{sequent} is shaped like
  $\Theta\parallel \Gamma\longrightarrow \Delta$ where
$\Theta$ is a finite set of world inequalities and both
$\Gamma$ and $\Delta$ are finite sets of prefixed formulas.
In a sequent, world inequality
$\mathsf s\le \mathsf s$ must be in $\Theta$
 for any world term $\mathsf s$ occurring in $\Delta$ or $\Gamma$.

A set~$\Theta$ of world inequalities
\textit{conforms to} world restriction set~$\mathsf R$ when all of the
following hold:
\begin{itemize}
 \item $\mathsf s\le \mathsf t, \mathsf t\le \mathsf u\in
       \Theta\Longrightarrow
       \mathsf s\le \mathsf u\in\Theta$,
 \item If $\mathsf{s_0}\le \mathsf{t_0} \wor \mathsf{s_1}\le \mathsf
       {t_1}\wor
       \cdots\wor \mathsf{s_n}\le
       \mathsf{t_n}\in \bar{\mathsf R}$ and all of
       $\mathsf{s_0},\mathsf{s_1},\ldots,\mathsf{s_n},
       \mathsf{t_0},\mathsf{t_1},\ldots, \mathsf{t_n}$ appear in~$\Theta$, then,
       $\mathsf{s_i}\le \mathsf{t_i}\in\Theta$ for at least
       one~$\mathsf{i}$, where $\bar {\mathsf R}$ is the substitution
       closure of~$\mathsf R$,
 \item If $\mathsf s\le\mathsf t\in\Theta$ and both $\mathsf s.a$ and
       $\mathsf t.a$ appear in~$\Theta$, then $\mathsf s.a\le\mathsf
       t.a\in \Theta$.
\end{itemize}
We define $\mathsf R(\Theta)$ to be the set of the minimal
supersets of~$\Theta$ conforming to~$\mathsf R$.
For example, when $\mathsf R=\{\mathsf w\le \mathsf v\wor\mathsf v\le \mathsf
w\}$,
$\mathsf R(\{\mathsf w\le \mathsf w, \mathsf v\le \mathsf v\}) =
\{\{\mathsf w\le \mathsf v, \mathsf w\le \mathsf w, \mathsf v \le
\mathsf v\}, \{\mathsf v \le
\mathsf w, \mathsf w\le \mathsf w, \mathsf v\le \mathsf v\}\}$\enspace.
 When $\Theta$ is finite, so is $\mathsf R(\Theta)$ because $\mathsf
 R(\Theta)\subseteq \{\mathsf s\le\mathsf
 t\mid\mathsf s,\mathsf t\mbox{ appears in }\Theta\}$.

\begin{definition}
 The calculus\,\LB\,for a world restriction set~$\mathsf R$ is defined in Fig.~\ref{LB}.
 When $\mathsf w\le \mathsf w\parallel \rightarrow \mathsf
 w::\varphi$ is provable in \LB\,for~$\mathsf R$,
 we write $\vdashRLB\varphi$.
\end{definition}

\begin{figure}[t]
  \def\fCenter{\longrightarrow}
 \small
 \begin{center}
\ruleskip
  \Axiom$\Theta\parallel \Gamma\fCenter \mathsf s::\varphi,\Delta$
  \Axiom$\Theta\parallel \Gamma, \mathsf t::\psi \fCenter \Delta$
  \RightLabel{L$\supset$}
  \BinaryInf$\Theta, \mathsf s\le \mathsf t\parallel \Gamma, \mathsf t::\varphi\supset\psi
  \fCenter \Delta$
  \DisplayProof
  \ruleskip
  \Axiom$\Theta'\parallel \Gamma, \mathsf w::\varphi\fCenter
  \mathsf w::\psi,\Delta\quad\mbox{ for every }\Theta'\in \mathsf
  R(\Theta\cup\{\mathsf s\le \mathsf w\})$
  \RightLabel{R$\supset$}
  \UnaryInf$\Theta\parallel \Gamma \fCenter \mathsf s::\varphi\supset\psi, \Delta$
  \DisplayProof\\ ($\mathsf w$ does not appear in the conclusion)
  \ruleskip
  \Axiom$\Theta'\parallel \Gamma, \mathsf s.a::\varphi\fCenter\Delta$
  \RightLabel{L$a$}
  \UnaryInf$\Theta\parallel \Gamma, \mathsf s::K_a\varphi\fCenter\Delta$
  \DisplayProof
\hfill
  \Axiom$\Theta\parallel \Gamma\fCenter\Delta, \mathsf s.a::\varphi$
  \RightLabel{R$a$}
  \UnaryInf$\Theta\parallel\Gamma\fCenter\Delta, \mathsf s :: K_a\varphi$
  \DisplayProof
 \end{center}
 \caption{The inference rules of \LB. Modification of Fig.~3 of
 Waaler and Wallen~\cite{waaler1999tableaux}.
 Since $\mathsf R(\Theta\cup\{\mathsf s\le\mathsf w\})$ is finite,
 R$\supset$
 is finitely branching.}
\label{LB}
\end{figure}

\begin{figure}[ht]
 \def\fCenter{\longrightarrow}
 \Axiom$\Theta,\mathsf v\le\mathsf x\parallel\mathsf v::\varphi,\mathsf
 x::\psi\fCenter\mathsf v::\psi,\mathsf x::\varphi$
 \Axiom$\Theta,\mathsf x\le\mathsf v\parallel\mathsf v::\varphi,\mathsf
 x::\psi\fCenter\mathsf v::\psi,\mathsf x::\varphi$
 \RightLabel{R$\supset$}
 \BinaryInf$\mathsf w\le\mathsf w,\mathsf w\le\mathsf v,\mathsf
 v\le\mathsf v\parallel\mathsf v::\varphi\fCenter\mathsf v::\psi,\mathsf
 w::\psi\supset\varphi$
 \RightLabel{R$\supset$}
 \UnaryInf$\mathsf w\le\mathsf w\parallel\fCenter\mathsf
 w::\varphi\supset\psi,\mathsf w::\psi\supset\varphi$
 \RightLabel{R$\vee$}
 \UnaryInf$\mathsf w\le\mathsf w\parallel\fCenter\mathsf
 w::(\varphi\supset\psi)\vee(\psi\supset\varphi)$
 \DisplayProof
 
 \caption{A derivation for
 $\vdashRLB(\varphi\supset\psi)\vee(\psi\supset\varphi)$ where
 $\mathsf R=\{\mathsf v\le\mathsf w,\mathsf w\le\mathsf v\}$.
 In the figure, $\Theta$ stands for $\{\mathsf w\le\mathsf w,\mathsf
 w\le \mathsf v, \mathsf v\le\mathsf v, \mathsf w\le \mathsf x, \mathsf
 x \le \mathsf x\}$. }
 \label{gdlb}
\end{figure}

\section{Soundness of LB}

For a world valuation $\delta:\mathcal V_W\longrightarrow M$,
we let $\delta(\Theta)$ denote a condition on
model~$M$ stating $\delta(\mathsf s)\preceq \delta(\mathsf t)$ for any
$\mathsf s\le \mathsf t\in\Theta$.
Likewise, $\delta(\mathsf s::\varphi)$ is a condition stating
$M,\delta(\mathsf s)\models\varphi$.  For a sequence~$\Gamma =
(t_i::\varphi_i)_{i\in I}$ of
prefixed formulas, $\delta(\Gamma)$ denotes the conjunction
of $\delta(t_i::\varphi_i)$ taken over $i\in I$.
   We say a pair
$\tuple{M,\delta}$ \textit{satisfies}
$\Theta\parallel\Gamma\longrightarrow\Delta$ when $\delta(\Theta)$ and
$\delta(\Gamma)$ implies $\delta(\varphi)$ for some $\varphi$
in~$\Delta$.

\begin{proposition}
 \label{exp-sound}
 If an $\mathsf R$-model satisfies $\delta(\Theta)$,
 the model satisfies $\delta(\Theta')$ for 
 at least one element~$\Theta'$ of $\mathsf R(\Theta)$.
\end{proposition}
\begin{proof}
 Let $\Theta_M$ be the set of world inequalities
 $\{\mathsf s\le \mathsf t\mid M\mbox{
 satisfies }\delta(\mathsf s\le \mathsf t)\}$.
 The set $\Theta_M$ is clearly conforms to $\mathsf R$.
 By definition of $\mathsf R(\Theta)$, there exists at least one $\Theta'\in
 \mathsf R(\Theta)$ with $\Theta'\subseteq \Theta_M$.
 Since $M$ satisfies $\delta(\Theta_M)$, it satisfies $\delta(\Theta')$.
\end{proof}

\begin{lemma}
 \label{sound}
If a sequent $\Theta\parallel \Gamma\longrightarrow \Delta$ is
provable,
then, for any $\mathsf R$-model $M$ and world valuation $\delta$,
the pair~$\tuple{M,\delta}$ satisfies the sequent $\Theta\parallel
 \Gamma\rightarrow\Delta$.
\end{lemma}
\begin{proof}
Induction on derivation trees.
 The case of R$\supset$ is tricky.
 Assume an $\mathsf R$-model~$M$ satisfies all elements of
 $\delta(\Theta)$ and $\delta(\Gamma)$ but no elements of $\delta(\Delta)$.
 In order to prove $M,\delta(\mathsf s)\models\varphi\supset\psi$, we
 arbitrarily take $w\in M$ with $ w\succeq \delta(\mathsf s)$ and assume $M,
  w\models\varphi$.
 Showing $M,w\models\psi$ is enough.
 Let $\mathsf w$ be a world variable which does not occur in~$\Theta$.
 We extend $\delta$ with $\mathsf{w}\mapsto w$ and call the extension~$\epsilon$.
 Since $M$ is an~$\mathsf R$-model,
 it satisfies $\delta(\Theta')$ for some $\Theta'\in \mathsf R(\Theta\cup
 \{\mathsf s\le \mathsf w\})$ by Prop.~\ref{exp-sound}.
 By induction hypothesis, $M$ satisfies some elements of $\epsilon(\Delta)$ or
 $\epsilon(\mathsf w::\psi)$. Since $\Delta$ does not contain~$\mathsf w$,
 $\epsilon(\Delta)$ is equivalent to $\delta(\Delta)$, of which no elements are
 satisfied by~$M$.
 Thus, $M$ satisfies $\epsilon(\mathsf w::\psi)$.
 Since $\epsilon(\mathsf w) = w$, this means $M,  w\models\psi$.
\end{proof}

\section{Finite Model Property of LB}
\label{fmplb}

\begin{figure}[t]
 \small
\begin{center}
 \def\fCenter{\longrightarrow}
 \Axiom$\Theta\parallel\Gamma\fCenter\mathsf t::\varphi,\quad \Delta$
 \RightLabel{R$\wedge_0$}
 \UnaryInf$\Theta\parallel\Gamma\fCenter \mathsf
 t::\varphi\wedge \psi,\quad \Delta$
 \DisplayProof
 \hfill
 \Axiom$\Theta\parallel\Gamma\fCenter \mathsf t:: \psi,\quad \Delta$
 \RightLabel{R$\wedge_1$}
 \UnaryInf$\Theta\parallel\Gamma\fCenter \mathsf
 t::\varphi\wedge\psi,\quad\Delta$
 \DisplayProof
 \ruleskip
 \Axiom$\Theta\parallel\Gamma,\quad \mathsf t::\varphi\fCenter\Delta$
 \RightLabel{L$\vee_0$}
 \UnaryInf$\Theta\parallel\Gamma,\quad \mathsf
 t::\varphi\vee\psi\fCenter \Delta$
 \DisplayProof
 \hfill
 \Axiom$\Theta\parallel\Gamma,\quad \mathsf t::\psi\fCenter\Delta$
 \RightLabel{L$\vee_1$}
 \UnaryInf$\Theta\parallel\Gamma,\quad \mathsf
 t::\varphi\vee\psi\fCenter\Delta$
 \DisplayProof
 \ruleskip
 \Axiom$\Theta\parallel\Gamma\fCenter\mathsf
 t::\varphi, \quad\mathsf t::\psi,\quad \Delta$
 \RightLabel{R$\vee$}
 \UnaryInf$\Theta\parallel\Gamma\fCenter\mathsf
 t::\varphi\vee\psi,\quad \Delta$
 \DisplayProof
 \hfill
 \Axiom$\mathsf s\ge \mathsf t,
 \Theta \parallel \Gamma, \quad\mathsf t:: \varphi\supset\psi
 \fCenter\mathsf s:: \varphi, \quad \Delta$
 \RightLabel{LC$\supset_0$}
 \UnaryInf$\mathsf s\ge \mathsf t,\Theta \parallel \Gamma, \quad
 \mathsf t::\varphi\supset\psi\fCenter \Delta$
 \DisplayProof
 \ruleskip
 \Axiom$\Theta\parallel\Gamma,\quad \mathsf
 t::\varphi,\quad \mathsf t::\psi\fCenter\Delta$
 \RightLabel{L$\wedge$}
 \UnaryInf$\Theta\parallel\Gamma,\quad \mathsf t::
 \varphi\wedge \psi\fCenter \Delta$
 \DisplayProof
 \hfill
 \Axiom$\Theta\parallel\Gamma,\quad\mathsf t::\psi\fCenter \Delta$
 \RightLabel{L$\supset_1$}
 \UnaryInf$\Theta\parallel\Gamma,\quad\mathsf
 t::\varphi\supset\psi\fCenter\Delta$
 \DisplayProof
 \ruleskip
 \Axiom$\Theta'\parallel\Gamma,\quad \mathsf w::\varphi\fCenter
 \mathsf w::\psi,\quad \Delta$
 \RightLabel{R$\supset$}
 \UnaryInf$\Theta\parallel\Gamma\fCenter \mathsf t::\varphi\supset\psi,\quad
 \Delta$
 \DisplayProof\\
($\Theta'\in \mathsf R(\Theta\cup \{\mathsf t\le
 \mathsf w\})$ and $\mathsf w$ does not appear in the conclusion)
 \ruleskip
 \Axiom$\Theta'\parallel \Gamma,\quad \mathsf s.a::\varphi\fCenter\Delta$
 \RightLabel{L$a$}
 \UnaryInf$\Theta\parallel \Gamma,\quad \mathsf s::K_a\varphi\fCenter
 \Delta$
 \DisplayProof
 \hfill
 \Axiom$\Theta'\parallel \Gamma\fCenter\Delta,\quad \mathsf s.a::\varphi$
 \RightLabel{R$a$}
 \UnaryInf$\Theta\parallel \Gamma\fCenter\Delta,\quad \mathsf s::K_a \varphi$
 \DisplayProof
\\
(in L$a$ and R$a$, $\Theta'\in \mathsf R(\Theta\cup \{\mathsf s.a\le\mathsf s.a\})$)
 \ruleskip
 \Axiom$\Theta\parallel\Gamma
 \fCenter \Delta$
 \RightLabel{LT}
 \UnaryInf$\Theta\parallel\Gamma,\quad
 \mathsf t::\varphi
\fCenter\Delta$
 \DisplayProof
 \caption{The rules for refutation ladders. A modified version of Fig.~6 of Waaler and
 Wallen~\cite{waaler1999tableaux} with additional world inequality sidenotes and
 prefixes.  The top of a refutation ladder can be any sequent.
 No rule is branching.  Comma separated notation $\Gamma,\quad \mathsf
 s::\varphi$ denotes the disjoint union $\Gamma\uplus \{\mathsf
 s::\varphi\}$ in this figure.
}
 \label{refladder} 
\end{center}
\end{figure}

We are going to use yet another derivation called the refutation
ladder in order to construct a finite model from an unprovable sequent.
Refutation ladders have rules in Fig.~\ref{refladder}.
If the assumption of a rule is unprovable, so is the conclusion of the rule.
A refutation ladder is not branching.

 Not all ladders made of the rules in Fig.~\ref{refladder} are
 refutation ladders.
 There are some restrictions on the ladders.
 In order to describe the restrictions,
 we use a relation~$\prec$ between sequent occurrences in a ladder.
Relation $T\prec S$ holds iff
 $S$ is above $T$, and
 at least one interleaving \textrm{R$\supset$} rule between $S$ and $T$
 has its left formula not introduced by thinning~(LT).
\begin{definition}
 A \textit{refutation ladder} is a ladder made of the rules in
 Fig.~\ref{refladder} that satisfies
\begin{description}
 \item[ (R1)] Thinning \textrm{(LT)} occurs only immediately above \textrm{R$\supset$} for the
	    left side formula of the \textrm{R$\supset$} occurrence.
 \item[ (R2)] 
	    On the other hand, if an \textrm{R$\supset$} occurrence
	    for a formula
	    $\mathsf s::\varphi\supset\psi$ has $\mathsf t\le \mathsf s$
	    in the sidenote of the assumption and
	    $\mathsf t::\varphi$ in the left hand side of the assumption,
	    then, 
	    there is a thinning just above the R$\supset$ introducing
	    $\mathsf w::\varphi$ where $\mathsf w$ is the world variable
	    introduced by the \textrm{R$\supset$} occurrence.
 \item[ (R3)]
	    If there are two \textrm{LC$\supset_0$} occurrences one above the
	    other.
	    Let $S$ be former occurrence's conclusion and $T$ be latter occurrence's
	    conclusion.
	    Then, $T\prec S$ holds.
 \item[ (R4)]
	    The conclusion of \textrm{R$\supset$} must not be a
	    possible conclusion of any other rule.
	    In other words, when building up a refutation ladder from
	    bottom to up, avoid using R$\supset$ whenever some other
	    rules are applicable.
 \item[ (R5)]
	    For every sequent $\Theta\parallel \Gamma\rightarrow\Delta$
	    in the ladder, $\Theta$ conforms to~$\mathsf R$.
\end{description} 
\end{definition}
A \textit{refutation ladder of a sequent}~$S$ is a refutation ladder
 with
 $S$ at the bottom.
The conditions \textbf{(R2)} and \textbf{(R3)} ensure that every
 refutation ladder is finite~(Prop.~\ref{refladder-finite}).
 Some other conditions \textbf{(R1)} and \textbf{(R4)} ensure
 that thinning is not applied to non-atomic formulas.


\begin{proposition}
\label{refladder-finite}
 Every refutation ladder is finite.
\end{proposition}
\begin{proof}
 If a refutation ladder is infinite,
 it must contain infinitely many $\supset$LC$_0$ occurrences.
 By \textbf{(R3)}, there must also be infinitely many R$\supset$ rule
 occurrences.
 Moreover, by the definition of~$\prec$,
 those occurrences have left-side formula not
 introduced by thinning.
 The number of such formulas is not more than the number of subformulas
 in the endsequent because thinning occurs whenever it is possible as
 \textbf{(R2)} states.
\end{proof}

\begin{definition}
A \textit{complete refutation ladder} of~$S$ is a refutation ladder which is
\begin{itemize}
 \item maximal: not a proper sub-ladder of any
       refutation ladder of~$S$
 \item open:
       for any sequent~$\Theta\parallel \Gamma\longrightarrow \Delta$,
      the prefixed formula~$\mathsf t::\bot$ is not contained in~$\Gamma$.       
       Either
       $\mathsf t::\varphi\notin \Gamma$ or
       $\mathsf s::\varphi\notin\Delta$ or $\mathsf t\le \mathsf s\notin
       \Theta$.
\end{itemize} 
\end{definition}

We are going to show that
if a sequent $S$ is not provable in\,\LB, then there is a complete
refutation ladder of $S$, and then there is a finite counter model.

\subsection{Existence of a Complete Refutation Ladder}

\begin{lemma}\label{chooser}
 If a sequent~$S$ does not form a maximal refutation ladder by itself and
 every applicable rule to $S$ yields a provable
 sequent in \LB, then $S$ is provable in \LB.
\end{lemma}
\begin{proof}
 At least one rule is applicable to $S$ because the sequent does
 not form a maximal refutation ladder by itself. We split cases by the
 applicable rule.
 \begin{description}
  \item[ (Case L$\wedge$ R$\vee$ L$a$ R$a$)]
	    If the above is provable, then so is the below.
  \item[ (Case R$\wedge_0$)]
	     R$\wedge_1$ is also applicable.
  \item[ (Case R$\wedge_1$)]
	     In this case, we use the fact that R$\wedge_0$ is also
	     applicable.
	     Since $\Theta\parallel\Gamma\longrightarrow \mathsf t::\varphi, \Delta$ and
	     $\Theta\parallel\Gamma\longrightarrow \mathsf t::\psi,
	     \Delta$ are both provable in \LB,
	     $\Theta\parallel\Gamma\longrightarrow \mathsf
	     t::\varphi\wedge\psi$ is also provable in \LB.
  \item[ (Case L$\vee_0$ L$\vee_1$)]
	     Similar to the R$\wedge$ cases.
  \item[ (Case L$\supset_1$ Split)] Immediate.
  \item[ (Case LC$\supset_0$)]
	     L$\supset_1$ is also applicable.
  \item[ (Case R$\supset$)]
	     The rule is also applicable with any $\Theta'\in
	     \mathsf R(\Theta\cup\{\mathsf s\le \mathsf w\})$. Since every one of these is
	     provable in \LB,
	     the endsequent is also provable in \LB.
 \end{description}
\end{proof}

For a refutation ladder~$L$, we define a sequent $\cup L$ as
the sequent $\left(\bigcup_i \Theta_i\right)\parallel \left(\bigcup_i \Gamma_i\right)\longrightarrow
\left(\bigcup_i\Delta_i\right)$ where $i$ runs over
each sequent $\Theta_i\parallel \Gamma_i\longrightarrow\Delta_i$
occurring in~$L$.
We say $L$ is \textit{unprovable} when $\cup L$ is.

\begin{lemma}
 \label{comprefl}
 An unprovable sequent has a complete refutation ladder.
\end{lemma}
\begin{proof}
Assume the sequent
$S = \Theta\parallel \Gamma\longrightarrow\Delta$
is unprovable.
Let $L$ be the set of refutation ladders of~$S$ and
let $\bar L$ be the set of maximal such refutation ladders.
We collect unprovable refutation ladders in~$L$ and call them~$L_u$.
Again, $\bar L_u$ denotes the maximal elements of~$L_u$.
The ladder consisting of only~$S$ is an element of~$L_u$
so that $L_u$ is not empty.
 Moreover, every refutation ladder in~$L_u$ is finite.
These combined implies existence of maximal elements in $L_u$ so that $\bar L_u$ is not empty.
By the contraposition of Lemma~\ref{chooser}, the set $\bar L_u$ is included in $\bar L$.
Thus, there is an unprovable ladder~$l$ in~$\bar L$.
Since $l$ is unprovable, $l$ is open.
We can conclude that $l$ is a complete refutation ladder. 
\end{proof}


\subsection{Constructing a Model from a Complete Refutation Ladder}

\begin{definition}[Hintikka Sequent]
 A sequent $\Theta\parallel \Gamma\longrightarrow\Delta$ is $\mathsf R$-Hintikka
 iff
 \begin{enumerate}
  \item $\Theta$ conforms to $\mathsf R$.
  \item $\Gamma$ does not contain $\mathsf s::\bot$ for any world
	term~$\mathsf s$.
  \item If $\mathsf s::P\in \Gamma$ and $\mathsf t::P\in\Delta$ for
	some~$P\in\pvar$\!, then
	$\Theta$ does not contain~$\mathsf s\le \mathsf t$.
  \item $\mathsf s::\varphi\wedge\psi\in\Gamma\Longrightarrow
	\mathsf s::\varphi,\mathsf s::\psi\in\Gamma$
  \item $\mathsf s::\varphi\vee\psi\in\Gamma
	\Longrightarrow \mathsf s::\varphi\in\Gamma$ or
	$\mathsf s::\psi\in\Gamma$.
  \item If $\mathsf t::\varphi\supset\psi
	\in\Gamma$ and $\mathsf s\ge t\in \Theta$,
	then 
	either
	$\mathsf t::\varphi\in\Gamma$ or
	$\mathsf s::\psi\in\Delta$ hold.
  \item $\mathsf s::K_a\varphi\in\Gamma
	\Longrightarrow \mathsf s.a::\varphi\in\Gamma$
  \item $\mathsf s::\varphi\wedge\psi
	\in\Delta\Longrightarrow \mathsf
	s::\varphi\in\Delta$
	or $\mathsf s::\psi\in\Delta$.
  \item $\mathsf s::\varphi\vee\psi\in\Delta
	\Longrightarrow \mathsf s::\varphi, \mathsf s::\psi\in
	\Delta$.
  \item If $\mathsf s::\varphi\supset\psi\in\Delta\Longrightarrow$, then
	there exists a world term $\mathsf t$ with $\mathsf
	s\le \mathsf t\in\Theta$ such that
	$\mathsf t::\varphi\in\Gamma$, $\mathsf t::\psi\in\Delta$.
  \item $\mathsf s:: K_a\varphi\in\Delta\Longrightarrow
	\mathsf s.a::\varphi\in\Delta$.
 \end{enumerate}
\end{definition}

\begin{proposition}
 \label{Hsat}
 A $\mathsf R$-Hintikka sequent is satisfiable in a finite $\mathsf R$-model.
\end{proposition}
\begin{proof}
 \newcommand{\W}{WT(\Theta)}
 Let $\Theta\parallel \Gamma\longrightarrow\Delta$ be a Hintikka sequent.
 To construct a satisfying model, we use $\W$,
 which is the set of world
 terms occurring in~$\Theta$.
 We define a frame $\tuple{\W, \preceq, (f_a)_{a\in\agents}}$ with
 $\preceq$ being the relation $\{\tuple{\mathsf s,\mathsf t}\in
 \W\times \W\mid
 \mathsf s\le
 \mathsf t\in\Theta\}$ and
 $f_a(\mathsf s) = \mathsf s.a$ for $\mathsf s\in\W$\enspace.
 Since $\Theta$ conforms to $\mathsf R$, 
 the tuple is actually an $\mathsf R$-frame.
 We define $\rho$ to be $\rho(P) = 
 \{\mathsf s\in \W\mid
 \mbox{there exists a world term } \mathsf t \in \W \mbox{ such that }
 \mathsf t\le
 \mathsf s \in \Theta\mbox{
 and }\mathsf t::P\in \Gamma\}$.
 The tuple $\tuple{\W,\preceq,(f_a)_{a\in \agents},\rho}$ forms
 an $\mathsf R$-model because $\Theta$ conforms to $\mathsf R$.
 Moreover, by induction on $\varphi$, we can show both 
 $\mathsf s::\varphi\in\Gamma\Longrightarrow M,\mathsf s\models\varphi$
 and 
 $\mathsf s::\varphi\in\Delta\Longrightarrow M,\mathsf s\not\models\varphi$.
 Thus, the sequent $\Theta\parallel \Gamma\longrightarrow\Delta$ is satisfiable.
\end{proof}

\begin{proposition}
\label{completehintikka}
 For a complete refutation ladder~$L$,
$\cup L$ is a Hintikka sequent.
\end{proposition}
\begin{proof}
 By openness, maximality and rules \textbf{(R3)}, \textbf{(R4)}.
\end{proof}

\begin{lemma}
\label{R-fmp}
 If $\vdashR\varphi$  does not hold, there exists a finite $\mathsf
 R$-model~$M$ with $M\not\models\varphi$.
\end{lemma}
\begin{proof}
 Assume $\not\vdashR\varphi$.
 By soundness of \LB,
 the sequent $\mathsf w\le\mathsf w\parallel \longrightarrow\varphi$ is not
 provable in \LB.
 By Lemma~\ref{comprefl},
 there is a complete refutation ladder~$L$ for the sequent.
 By Prop.~\ref{completehintikka},
 $\cup L = L$  forms a Hintikka
 sequent.
 Moreover, 
 the union $\bigcup_i\Theta_i$ conforms to~$\mathsf
 R$.
 Thus, when we construct a model from $\cup L$ with the method described in
 the proof of Prop.~\ref{Hsat},
 we obtain a finite $\mathsf R$-model.
 Moreover, the state $\mathsf w$ of the model does not satisfy~$\varphi$.
\end{proof}
Now we can carry out the proof strategy for Thm.~\ref{fmp} described
at the beginning of Sect.~\ref{fmp-proof}.

\section{Application to Sequential Consistency Logic}

Sequential consistency logic can be defined with the following world
restrictions:
\begin{itemize}
 \item $\mathsf v.a\le\mathsf v.a.a$ for all $a\in\agents$,
 \item $\mathsf v.a\le\mathsf v$ for all $a\in\agents$,
 \item $\mathsf v.m\le\mathsf w.m$ where $m\in\agents$ is a special
       agent called shared memory.
\end{itemize}

Let us consider a formula $K_a K_m K_a P\supset K_a K_m K_b Q\supset
(K_a Q\wedge K_b P)$.
Informally, this formula means that whenever processes $a$ and $b$ have
made a round-trip communication with the shared memory, each process is
guaranteed to have received the other process's initial knowledge (with
an assumption a message carries all of sender's knowledge).
We can build a countermodel for this formula by the method described in
this paper, by building
a complete refutation ladder for the formula~(Fig.~\ref{compex})
\begin{figure}
 \tiny
 \def\fCenter{\longrightarrow}
 \begin{center}
  \Axiom$cl(\Theta_2, \mathsf x.b.m.b\le\mathsf x.b.m, \mathsf
  x.a\le\mathsf x)\parallel\mathsf v.a.m.a::P, \mathsf
  x.b.m.b::Q\fCenter \mathsf x.a::Q$
  \RightLabel{R$a$}
  \UnaryInf$cl(\Theta_2,\mathsf x.b.m.b\le\mathsf x.b.m)\parallel\mathsf
  v.a.m.a::P, \mathsf x.b.m.b::Q\fCenter\mathsf x::K_a Q$
  \RightLabel{R$\wedge_0$}
  \UnaryInf$cl(\Theta_2, \mathsf x.b.m.b\le\mathsf
  x.b.m)\parallel\mathsf v.a.m.a::P, \mathsf x.b.m.b::Q\fCenter\mathsf
  x::K_a Q\wedge K_a P$
  \RightLabel{L$b$}
  \UnaryInf$\Theta_2=cl(\Theta_1,\mathsf x.b\le\mathsf x,\mathsf
  x.b.m\le\mathsf x.b,\mathsf v.a.m\le\mathsf x.b.m)\parallel\mathsf
  v.a.m.a::P, \mathsf x.b.m::K_b Q\fCenter \mathsf x::K_a Q\wedge K_b P$
  \RightLabel{L$b$}
  \UnaryInf$cl(\Theta_1, \mathsf x.b\le\mathsf x)\parallel
  \mathsf v.a.m.a::P, \mathsf x.b::K_m K_b Q\fCenter x::K_a Q\wedge K_b
  P$
  \RightLabel{L$b$}
  \UnaryInf$\Theta_1=cl(\Theta_0,\mathsf v\le\mathsf x, \mathsf
  v.a.m.a\le \mathsf v.a.m)\parallel\mathsf v.a.m.a::P, \mathsf x::K_b
  K_m K_b Q\fCenter x::K_a Q\wedge K_b P$
  \RightLabel{R$\supset$}
  \UnaryInf$cl(\Theta_0,\mathsf v.a.m.a\le\mathsf v.a.m)\parallel
  \mathsf v.a.m.a::P\fCenter \mathsf v:: K_b K_m K_b Q\supset (K_a
  Q\wedge K_b P)$
  \RightLabel{L$a$}
  \UnaryInf$\Theta_0=cl(\mathsf w\le\mathsf v, \mathsf v.a\le\mathsf v,
  \mathsf v.a.m\le\mathsf v.a)\parallel\mathsf v.a.m::K_a P\fCenter
  \mathsf v::K_b K_m K_b Q\supset (K_a Q\wedge K_b P)$
  \RightLabel{L$a$}
  \UnaryInf$cl(\mathsf w\le\mathsf v, \mathsf v.a\le\mathsf
  v)\parallel\mathsf v.a::K_m K_a P\fCenter \mathsf v::K_b K_m K_b
  Q\supset (K_a Q\wedge K_b P)$
  \RightLabel{L$a$}
  \UnaryInf$cl(\mathsf w\le\mathsf v)\parallel \mathsf v:: K_a K_m K_a P
  \fCenter \mathsf v:: K_b K_m K_b Q\supset (K_a Q\wedge K_b P)$
  \RightLabel{R$\supset$}
  \UnaryInf$\mathsf w\le \mathsf w\parallel\fCenter \mathsf w:: K_a K_m K_a
  P\supset K_b K_m K_b Q\supset (K_a Q\wedge K_b P)$
  \DisplayProof
 \end{center}
 \caption{A complete refutation ladder for the considered formula.
 $cl(\Theta)$ denotes the reflexive transitive closure of~$\Theta$.}
 \label{compex}
\end{figure}


\section{Related Work}

\paragraph{Work on intuitionistic modal logics.}

Amati and Pirri~\cite{amati94} presented a uniform tableau method for a number of
intuitionistic modal logics whose language contains two modalities
$\square$ and $\lozenge$.
However, they did not consider the functional modality where the two
modalities coincide.  Nor did they consider the multimodal case.
Their uniform tableau method uses boxes around some sequents of the
tableaux.  This boxing method does not trivially encode our tableaux since our
tableau method utilizes sequents whose different formulas are prefixed
with different world terms.

Baldoni, Giordano and Martelli~\cite{baldoni98} presented a tableau
calculus for a class of multimodal logics called grammar logics.
Their method is similar to our method in that worlds are denoted by
variables and the relationship between the worlds are kept as a
sidenote.
However, their method does not parametrize logics with conditions involving
disjunction while our method parametrizes logics with conditions
involving $\wor$.

\paragraph{Work on intermediate logics.}

Sonobe~\cite{sonobe} gave a Gentzen-style formulation of some
intermediate logics, the simplest of which is G\"{o}del--Dummett logic.
He wrote his result ``was first obtained by way of tableau method.''
Thus both Sonobe's and our method contain a tableau formalization for
G\"{o}del--Dummett logic.  However, there are some differences even when
we compare Sonobe's formalization of G\"odel--Dummett logic and our
specialized method for G\"odel--Dummett logic.
In our formalization\,\LB, branches are for different shapes of Kripke
frames.  In Sonobe's formalization, branches are made for different
states in a Kripke model.

Avron~\cite{avron2000} presented a tableau system of G\"odel--Dummett logic
based on a hypersequent calculus.
As he points out, the system has an advantage of not using a rule with
arbitrary number of
premises.  Our tableau system does not have this advantage.
Larchey-Wendling~\cite{countermodelsearch} proposes an efficient parallel
countermodel searching method for G\"odel--Dummett logic.
It would be interesting to try to extend their methods to the
class of logics considered in this paper.

\section{Conclusion}

We have extended Waaler and Wallen's tableau method~\cite{waaler1999tableaux} for intuitionistic
logic in two ways: adding functional modalities, and adding restrictions on the Kripke frames.
This resulted in the finite model property of sequential consistency
logic~\cite{hirailpar} and a class of intermediate logics with
functional modalities.

\section{Proof of Thm.~\ref{sound-comp-nat-kripke}}
\label{app}
\subsection{Soundness}

\begin{lemma}[Soundness]
 $\Gamma\modelsR\varphi\Longleftarrow\Gamma\vdashR\varphi$
\end{lemma}
\begin{proof}
We show $\Gamma\modelsR\varphi$ inductively
on the definition of $\Gamma\vdashR\varphi$.
\begin{description}
 \item[(Case {Ax})]
	    Suppose $\varphi\in \mathsf{Ax}(R)$.
	    For an $\mathsf{R}$-model~$M$ and a state~$w$ of~$M$,
	    we are going to show $M,w\models\varphi$.
	    Seeking contradiction,
	    we assume $M,w\not\models\varphi$.
	    Since $\varphi\in\mathsf{Ax}(R)$, there exists a world
	    restriction $\mathsf r\in\mathsf R$ with
	    $\varphi=[\mathsf r]\theta$,
	    where $\theta$ is a substitution.
	    Let $\mathsf r$ be
	    $\mathsf v_0.s_0\le\mathsf v_1.t_1\wor\cdots\wor
	    \mathsf v_{n-1}.s_{n-1}\le\mathsf v_n.t_n\wor\mathsf
	    v_n.s_n\le\mathsf v_0.t_0$.
	    Then,
	    $\varphi = (K_{s_0}\varphi_0\supset
	    K_{t_1}\varphi_1)\vee\cdots\vee
	    (K_{s_{n-1}}\varphi_{n-1}\supset K_{t_n}\varphi_n)
	    \vee (K_{s_n}\varphi_n\supset K_{t_0}\varphi_0)$
	    for some $(\varphi_i)_{0\le i\le n}$.
	    We define $\varphi_{n+1}$ to be $\varphi_0$ and
	    $\varphi_{-1}$ to be $\varphi_n$.
	    By assumption, $M,w\not\models K_{s_i}\varphi_i\supset
	    K_{t_{i+1}}\varphi_{i+1}$ for any $0\le i\le n$.
	    This implies existence of a sequence
	    $(v_i)_{0\le i\le n}$ of states with $w\preceq v_i$ and
	    $M,v_i\models K_{s_i}\varphi_i$ but $M,v_i\not\models
	    K_{t_{i+1}}\varphi_{i+1}$.
	    By the semantics of modalities, we have
	    $M,f_{s_i}(v_i)\models \varphi_i$ but $M,
	    f_{t_{i+1}}(v_i)\not\models\varphi_{i+1}$
	    for any $0\le i\le n$.
	    When $\mathsf r$ is single clause,
	    $\mathsf r = \mathsf v.s\le\mathsf v.t$.
	    Let $\delta(\mathsf v)$ be $v_0$.
	    Since $M$ is an $\mathsf R$-model,
	    $f_s(v_0)\preceq f_t(v_0)$ holds.
	    Since $n=0$,
	    we have $M,v_0\models K_s\varphi_0$ but $M,v_0\not\models
	    K_t\varphi_0$.
	    This contradicts Kripke monotonicity.
	    Otherwise, when $\mathsf r$ is single postfix,
	    $\mathsf r = \mathsf v_0.s\le\mathsf
	    v_1.s\wor\cdots\wor\mathsf v_{n-1}.s\le\mathsf
	    v_n.s\wor\mathsf v_n.s\le\mathsf v_0.s$.
	    Let $\delta(\mathsf v_i)$ be $v_{n-i}$.
	    Since $M$ is an $\mathsf R$-model,
	    for some $0\le i\le n$,
	    we have $\delta(\mathsf v_i.s)\preceq \delta(\mathsf
	    v_{i+1}.s)$.
	    This is equivalent to $f_s(v_{n-1})\preceq f_s(v_{n-i-1})$.
	    The way we took $(v_i)_{0\le i\le n}$ ensures
	    $M,v_{n-1}\models K_s\varphi_{n-i}$.
	    In other words, $M,f_s(v_{n-1})\models \varphi_{n-i}$.
	    By Kripke monotonicity, $M,f_s(v_{n-i-1})\models
	    \varphi_{n-i}$.
	    This contradicts $M,f_s(v_{n-i-1})\not\models\varphi_{n-1}$.
 \item[(Other rules)]
	    Straightforward.
\end{description}
\end{proof}

\subsection{Completeness}
We prove completeness via
  adaptation of the standard saturated set construction (see Troelstra
  and van Dalen~\cite[Ch.~2]{troelstra1988constructivism}).
  Hirai~\cite{hirailpar} contains a similar proof for a special case of
  sequential consistency logic.

\begin{definition}
 A set~$\Gamma$ of formulas is
 $\mathsf R$-saturated iff all of these conditions hold:
 \begin{enumerate}
  \item $\Gamma$ does not contain $\bot$;
  \item $\Gamma$ is closed under $\mathsf R$-deduction, i.e.,
	$\Gamma\vdashR\varphi\Rightarrow\varphi\in\Gamma$;
  \item $\varphi\vee\psi\in\Gamma\Rightarrow\varphi\in\Gamma$ or $\psi\in\Gamma$.
 \end{enumerate}
\end{definition}

\begin{lemma}
 \label{saturation}
 For a set~$\Gamma$ of formulas with $\Gamma\not\vdashR\varphi$,
 there exists a
 saturated set $\Gamma^{\omega}$ of formulas with
 $\Gamma^{\omega}\not\vdashR\varphi$ and
 $\Gamma\subseteq \Gamma^{\omega}$.
\end{lemma}
\begin{proof}
 Exactly the same as Lemma~2.10 in Hirai~\cite{hirailpar}.
\end{proof}


\begin{definition}[Canonical model candidate]
 We define a tuple
 $\R M = \tuple{\R W, \R\preceq, (\R{f_a})_{a\in \agents}, \R\rho}$
 where
 \begin{itemize}
  \item $\R W$ is the set of $\mathsf R$-saturated sets of formulas;
  \item $\Gamma\R\preceq \Delta$ iff $\Gamma\subseteq\Delta$;
  \item $\R{f_a}(\Gamma) = \{\varphi\mid K_a\varphi\in\Gamma\}$;
  \item $\R\rho(P)=\{\Gamma\mid P\in \Gamma\}$.
 \end{itemize}
\end{definition}

\begin{lemma}
 The tuple $\R M$ is a model.
\end{lemma}
\begin{proof}
 Exactly the same as Lemma~2.11 in Hirai~\cite{hirailpar}.
\end{proof}

\begin{proposition}
 \label{X}
 For a saturated set~$\Gamma$ of formulas and the canonical model~$\R
 M$,
 $\varphi\in\Gamma\Leftrightarrow \R M,\Gamma\models\varphi$ holds.
\end{proposition}
\begin{proof}
 Exactly the same as Lemma~2.13 in Hirai~\cite{hirailpar}.
\end{proof}

\begin{definition}
 A frame~$F = \tuple{W,\preceq, (f_a)_{a\in\agents}}$
 is a pseudo $\mathsf R$-frame iff $F$ satisfies
 $\delta(\mathsf R)$ for all world valuation
 $\delta$ and $w\in W$ s.t.
 every world variable~$\mathsf v$ satisfies
 $w\preceq \delta(\mathsf v)$.
\end{definition}
 A pseudo $\mathsf R$-model is a model with a pseudo $\mathsf R$-frame.

\begin{lemma}
 \label{pseudo-real}
 For a pseudo $\mathsf R$-model~$M$ and a state $w$ of $M$ with
 $M,w\models\varphi$,
 there exists an $\mathsf R$-model $\bar M$ and a state $\bar w$
 with $\bar M,\bar w\models\varphi$.
\end{lemma}
\begin{proof}
 A deep postfix is a postfix~$s$ that contains any sequence of agents
 encountered during parsing~$\varphi$ in the top-down direction.
 Let $s$ be a deep postfix for~$\varphi$. Let $M$ be
 $\tuple{W,\preceq,(f_a)_{a\in\agents},\rho}$.
 We define $\bar M$ to be $\tuple{\bar W,\bar\preceq,
 (\bar f_a)_{a\in\agents},\bar \rho}$ where
 $\bar W=\{v\in W\mid v\succeq f_s(w)\}$,$\bar\preceq =
 \preceq\cap (\bar W\times\bar W)$,
 $\bar f_a(w)= \begin{cases}
		    f_a(w)&(\mbox{if }f_a(w)\in\bar W)\\
		    w&(\mbox{otherwise})\enspace,
		   \end{cases}$
 and $\bar \rho(P) =\rho(P)\cap\bar W$.
 We define $\bar w$ to be $w$.
 The new model~$\bar M$ simulates the original model~$M$ well enough
 to make $\bar M,\bar w\models\varphi$ hold.
 Since $\bar M$ is a restriction of $M$, $\bar M$ is a pseudo
 $\mathsf R$-model.
 Moreover, since $\bar M$ has the minimum state, $\bar M$ is an
 $\mathsf R$-model.
\end{proof}

\begin{lemma}
 $\R M$ is a pseudo $\mathsf R$-model.
\end{lemma}
\begin{proof}
 Seeking contradiction,
 assume the frame $\R F = \tuple{\R W, \R\preceq, (\R
 {f_a})_{a\in\agents}}$
 does not satisfy $\delta(\mathsf R)$ for
 a world valuation~$\delta$ with
 $\Delta\R\preceq\delta(\mathsf v)$ for all $\Delta\in\R W$.
 There exists a world restriction
 $\mathsf r\in\mathsf R$.
 Let $\mathsf r$ be $\mathsf v_0.s\le\mathsf v_1.s\wor\cdots \wor\mathsf
 v_{n-1}.s\le\mathsf v_n.s\wor\mathsf v_n.s\le\mathsf v_0.s$.
 Since $\R F$ does not satisfy $\delta(\mathsf r)$,
 $f_s(\delta(\mathsf v_i))\not{\R \preceq}f_s(\delta(\mathsf v_{i+1}))$
 for
 all $0\le i\le n$ (we define $\mathsf v_{n+1} = \mathsf v_0$).
 Since $\R\preceq = \subseteq$, there exists
 a formula $\psi_i\in f_s(\delta(\mathsf v_{i+1}))\setminus
 f_s(\delta(\mathsf v_i))$ for every $0\le i\le n$.
 In other words, $K_s\psi_i\in\delta(\mathsf v_{i+1})$
 but $K_s\psi_i\notin\delta(\mathsf v_i)$.
 By Prop.~\ref{X},
 $\R M,\delta(\mathsf v_{i+1})\models K_s\psi_i$ but
 $\R M,\delta(\mathsf v_{i})\not\models K_s\psi_i$.
 On the other hand, $\mathbf{Ax}(\mathsf R)$ contains
 $\bigvee_{0\le i\le n}\left(K_s\psi_i\supset K_s\psi_{i+1}\right)$.
 So, for some $0\le i\le n$,
 $K_s\psi_i\supset K_s\psi_{i+1}\in\Delta$.
 This means, by Prop.~\ref{X},
 $\R M,\Delta\models K_s\psi_i\supset K_s\psi_{i+1}$.
 Since $\Delta\R\preceq\delta(\mathsf v_i)$,
 by Kripke monotonicity (Lemma~\ref{monot}),
 $\R M,\delta(\mathsf v_{i+1})\models K_s\psi_i\supset K_s\psi{i+1}$.
 This contradicts $\R M,\delta(\mathsf v_{i+1})\models K_s\psi_i$ and
 $\R M,\delta(\mathsf v_i)\not\models K_s\psi_i$.
\end{proof}
 
\begin{lemma}[Completeness]
 $\modelsR\varphi\Longrightarrow\vdashR\varphi$
\end{lemma}
\begin{proof}
 We show the contraposition.
 Assume $\not\vdashR \varphi$. By
 Lemma~\ref{saturation}, there exists
 a saturated set~$\Gamma^\omega$ with $\Gamma^\omega\not\vdashR\varphi$.
 By Lemma~\ref{X}, $\R M, \Gamma^\omega\not\models\varphi$.
 By Lemma~\ref{pseudo-real}, there exists an
 $\mathsf R$-model $\bar M$ and a state~$\bar w$ of $\bar M$
 with $\bar M,\bar w\not\models \varphi$.
 This witnesses $\not\modelsR\varphi$.
\end{proof}

\chapter{A Hyper $\lambda$-Calculus for G\"odel--Dummett Logic}

We propose a typed lambda calculus based on Avron's hypersequent
calculus for G\"odel--Dummett logic.  This calculus turns out to model
waitfree computation.
Besides strong normalization and non-abortfullness, 
we give soundness and completeness of
the calculus against the typed version of waitfree protocols.
The calculus is not only proof theoretically interesting,
but also valuable as a basis for distributed programming languages.

\section{Introduction}

The Curry--Howard isomorphism~\cite{curryhoward} is surprising because the same
method works for two different purposes: a logical purpose of
removing redundancy from proofs and a computational purpose of finding a
class of terminating programs.
We extend
this surprise to G\"odel--Dummett logic and
waitfreedom.
G\"odel--Dummett logic~\cite{dummett59}
is one of the intermediate logics
between classical and intuitionistic logics.
Waitfreedom~\cite{Herlihy88,Saks:1993vq} is a class of distributed
computation without synchronization among processes.

We connect G\"odel--Dummett logic and waitfreedom using
Avron's hypersequent calculus~\cite{avron91}.
We respond to his suggestion:
\begin{quote}
it seems to us extremely important to determine the exact
       computational content of them~[intermediate logics] ---
       and {to develop corresponding `$\lambda$-calculi'}
       ---Avron~\cite{avron91}. 
\end{quote}
Differently from intuitionistic logic, G\"odel--Dummett logic validates
all formulae of the form
 $(\varphi\supset\psi)\vee(\psi\supset\varphi)$.
Our aim is building a typed lambda calculus
with some terms witnessing those formulae.
Such a term
$\tj{M}{(\varphi\supset\psi)\vee(\psi\supset\varphi)}$ must choose 
$M\reduction \linl\cdots$ or $M\reduction \linr\cdots$.
We devise a nondeterministic $\lambda$-calculus in Sect.~\ref{lgd}.

Waitfreedom is a class of distributed computation where
processes cannot wait for other processes.  When two processes try to
exchange information, the faster process can pass information to the
slower one, but not always vice versa because the slower process might
start after the faster one finishes.
So, the computation is nondeterministic.
The contribution of this paper is capturing
this nondeterminism using the nondeterministic $\lambda$-calculus for
G\"odel--Dummett logic: in Sect.~\ref{comparison}, we show that the
$\lambda$-terms in the calculus can solve a typed input-output
problems if and only if it is waitfreely solvable.

\section{\lgd}
\label{lgd}

We first present a proof system for G\"odel--Dummet logic.
Then we turn the proof system into typing rules for $\lambda$-terms
of~\lgd, give a set of reductions and prove strong-normalization and
non-abortfullness.

\subsection{Logic}

\newcommand{\m}[1]{{#1}^+}

Let us assume a countably infinite set of \textit{propositional variables}.
We define \textit{local formulae} $\varphi, \psi$ by the following BNF,
where $I$ is a
propositional variable%
\footnote{We include $\bot$ because G\"odel--Dummett logic has it
although $\bot$ is not necessary for us to encode waitfree computation.}%
:
\[
 \varphi,\psi ::= \bot \mid I \mid (\varphi\supset\psi) \mid (\varphi\wedge\psi) \mid
 (\varphi\vee\psi)\enspace.
\]
Further, we define \textit{global formulae} $\m\varphi, \m\psi$ with the following
BNF:
\[
 \m\varphi,\m\psi :: = [i]\varphi \mid
 (\m\varphi\wedge\m\psi)\mid (\m\varphi\vee\m\psi)
\]
where $i$ is a natural number (representing a process).  The unary operators $[0],
[1],\ldots$ are called \textit{modalities}.
We omit parentheses following the usual convention.
Informally, the local formulae describe datatypes used by each process.
The global formulae describe inputs or outputs of all
processes together.

A \textit{context} (denoted by $\Gamma$ and $\Delta$ possibly
subscripted) is a potentially empty
finite sequence of global formulae.
A \textit{sequent}~$\Gamma\vdash\m\varphi$ is a pair of a context and a
global formula.
A \textit{hypersequent} is a finite sequence of sequents.

The underlying logic has the derivation rules in Fig.~\ref{fig:logic}.  If
we omit all the modalities, these rules characterize
G\"odel--Dummett logic.
However, the modalities have at least some sense: while
$([0]\varphi\supset[0]\psi)\vee([1]\psi\supset[1]\varphi)$ is provable,
$([0]\varphi\supset[1]\psi)\vee([0]\psi\supset[1]\varphi)$ is not.
A semantics will be given in Sect.~\ref{comparison}.

\begin{figure}
 \small
  \begin{center}
  \textbf{External Rules}
   \vskip 2mm
%%communication
   \BinaryRule
   {$\hyper\hmid\Gamma,\Delta\vdash[i]\varphi$}
   {$\hyper\hmid\Gamma,\Delta\vdash[j]\psi$}
   {com'}
   {$\hyper\hmid\Gamma\vdash[i]\psi\hmid\Delta\vdash[j]\varphi$}
  \hfill
%% external structural   
 \UnaryRule
 {$\hyper^+$}
 {EW}
 {$\hyper^+\hmid\Gamma\vdash \m\varphi$}
 \vskip 2mm
 \UnaryRule
 {$\hyper\hmid\Gamma\vdash \m\varphi\hmid\Gamma\vdash \m\varphi$}
 {EC}
 {$\hyper\hmid\Gamma\vdash \m\varphi$}
 \hfill
 \UnaryRule
 {$\hyper\hmid\Gamma\vdash \m\varphi\hmid\Delta\vdash \m\psi\hmid \hyper'$}
 {EE}
 {$\hyper\hmid\Delta\vdash \m\psi   \hmid\Gamma\vdash \m\varphi\hmid
   \hyper'$}
 \vskip 2mm
\textbf{Inner Global Rules}
\vskip 2mm
%% structural
   \UnaryRule{$\hyper\hmid\Gamma,\m\varphi,\m\psi,\Delta\vdash\m\theta$}
   {IE}
   {$\hyper\hmid\Gamma,\m\psi,\m\varphi,\Delta\vdash \m\theta$}
   \hfill
   \UnaryRule{$\hyper\hmid\Gamma\vdash\m\varphi$}
   {IW}
   {$\hyper\hmid\m\psi,\Gamma\vdash\m\varphi$}
   \hfill
   \UnaryRule{$\hyper\hmid\m\psi,\m\psi,\Gamma\vdash\m\varphi$}
   {IC}
   {$\hyper\hmid\m\psi,\Gamma\vdash\m\varphi$}
   \vskip 2mm
%% local conj intro
  \BinaryRule
   {$\hyper\hmid\Gamma\vdash \m\varphi$}
   {$\hyper\hmid\Gamma\vdash \m\psi$}
   {$\wedge\intro$}
   {$\hyper\hmid\Gamma\vdash \m\varphi\wedge\m\psi$}
   \vskip 2mm
%% local conj elim
  \UnaryRule
   {$\hyper\hmid\Gamma\vdash \m\varphi\wedge\m\psi$}
   {$\wedge\elim_0$}
   {$\hyper\hmid\Gamma\vdash \m\varphi$}
   \hfill
  \UnaryRule
   {$\hyper\hmid\Gamma\vdash\m\varphi\wedge\m\psi$}
   {$\wedge\elim_1$}
   {$\hyper\hmid\Gamma\vdash\m\psi$}
\vskip 2mm
%% local disj intro
  \UnaryRule
   {$\hyper\hmid\Gamma\vdash\m\varphi$}
   {$\vee\intro_0$}
   {$\hyper\hmid\Gamma\vdash\m\varphi\vee\m\psi$}
   \hfill
  \UnaryRule
   {$\hyper\hmid\Gamma\vdash\m\psi$}
   {$\vee\intro_1$}
   {$\hyper\hmid\Gamma\vdash\m\varphi\vee\m\psi$}
\vskip 2mm
%% local disj elim
   \TrinaryRule
   {$\hyper\hmid\Gamma\vdash           \m\varphi\vee\m\psi$}
   {$\hyper\hmid\m\varphi, \Gamma\vdash\m\theta$}
   {$\hyper\hmid\m\psi,    \Gamma\vdash\m\theta$}
   {$\vee\elim$}
   {$\hyper\hmid         \Gamma\vdash\m\theta$}
\vskip 2mm
\textbf{Inner Local Rules}
\vskip 2mm
%% axiom
  \UnaryRule{}{$[i]$Ax}
   {$[i]\varphi,\Gamma\vdash [i]\varphi$}
   \hfill
%% bot elim   
 \UnaryRule{$\hyper\hmid\Gamma\vdash[i]\bot$}
   {$[i]\bot\elim$}
   {$\hyper\hmid\Gamma\vdash[i]\varphi$}
   \vskip 2mm
%% local imp intro
  \UnaryRule{$\hyper\hmid[i]\varphi,\Gamma\vdash [i]\psi$}
  {$[i]\supset\intro$}
  {$\hyper\hmid\Gamma\vdash [i](\varphi\supset \psi)$}
  \hfill
%% local imp elim   
  \BinaryRule
  {$\hyper\hmid\Gamma\vdash [i](\varphi\supset\psi)$}
  {$\hyper\hmid\Gamma\vdash [i]\varphi$}
  {$[i]\supset\elim$}
  {$\hyper\hmid\Gamma\vdash [i]\psi$}
   \vskip 2mm
%% local conj intro
  \BinaryRule{$\hyper\hmid\Gamma\vdash [i]\varphi$}
   {$\hyper\hmid\Gamma\vdash [i]\psi$}
   {$[i]\wedge\intro$}
   {$\hyper\hmid\Gamma\vdash [i](\varphi\wedge\psi)$}
   \vskip 2mm
%% local conj elim
  \UnaryRule{$\hyper\hmid\Gamma\vdash [i](\varphi\wedge\psi)$}
   {$[i]\wedge\elim_0$}
   {$\hyper\hmid\Gamma\vdash[i]\varphi$}
   \hfill
  \UnaryRule{$\hyper\hmid\Gamma\vdash[i](\varphi\wedge\psi)$}
   {$[i]\wedge\elim_1$}
   {$\hyper\hmid\Gamma\vdash[i]\psi$}
\vskip 2mm
%% local disj intro
  \UnaryRule
   {$\hyper\hmid\Gamma\vdash[i]\varphi$}
   {$[i]\vee\intro_0$}
   {$\hyper\hmid\Gamma\vdash[i](\varphi\vee\psi)$}
   \hfill
  \UnaryRule{$\hyper\hmid\Gamma\vdash[i]\psi$}
   {$[i]\vee\intro_1$}
   {$\hyper\hmid\Gamma\vdash[i](\varphi\vee\psi)$}
\vskip 2mm
%% local disj elim
   \TrinaryRule
   {$\hyper\hmid\Gamma\vdash[i](\varphi\vee\psi)$}
   {$\hyper\hmid[i]\varphi, \Gamma\vdash[i]\theta$}
   {$\hyper\hmid[i]\psi,    \Gamma\vdash[i]\theta$}
   {$[i]\vee\elim$}
   {$\hyper\hmid         \Gamma\vdash[i]\theta$}
\vskip 2mm
\end{center}
\caption{The underlying logic.
 Metavariables~$i$ and $j$ stand for a process.
 $\hyper$ stands for a
 hypersequent.
 $\hyper^+$ stands for a nonempty hypersequent.
 $\Gamma$ and $\Delta$ stand for possibly empty contexts.
 The most important com' rule is based on a rule by
 Avron~\cite{avron96}.
 }
\label{fig:logic}
\end{figure}

\subsection{Term Assignment}
\label{term}

We assume distinct, countably infinite sets of \textit{variables},
\textit{locations}
and
\textit{processes}.
Locations are denoted by~$l$; process~$i,j, \ldots$ and variables~$x,
y, \ldots$.
Later, locations will be used to specify a pair of stores
holding terms.  
Like in the $\lambda$-calculus, some terms reduces to other
terms, but in this calculus, terms may interact with the store (like
a program written in Haskell or OCaml does with an i-var).
This behavior will be shown later in the definition of reductions.

We define \textit{terms}~$\term$ by the BNF
where $\Gamma$ is a sequence of variables:
\begin{align*}
\term ::=&\,
 x\mid \ltor i l \Gamma \term \mid \rtol i l \Gamma \term \mid
 \gpair {\term,\term}\mid
 \gpil \term \mid \gpir \term \mid
 \ginl\term \mid
 \ginr\term \mid \\ & \gmat \term x\term y \term \mid 
 \cotuple{\term,\term} \mid \abort \mid
  \lpil \term \mid \lpir \term \mid
 \lpair {\term,\term}\mid \\&
  \linl \term \mid  \linr \term \mid
 \lambda x.\term\mid (\term \term)
\mid \lmat \term x\term y \term \enspace.
\end{align*}
All variable occurrences (including those in $\Gamma$)
except the first clause are
binding.
The constructs with a~$\g$ represent the global rules and the
constructs without a~$\g$ represent the local rules.

We extend a \textit{sequent}
to $\Gamma\tr \tj M{\m \varphi}$, where $\Gamma$ is
a sequence like $\tj{x}{\m\psi}, \tj{y}{\m\theta}$ and $M$ is a term.
In a sequent $\Gamma\tr\tj{M}{\m\varphi}$, we require the variables in
$\Gamma$ to be distinct from each other.
A \textit{contexted type}
 $\Gamma\tr\m\varphi$ is a sequent without a term but with variables in
 $\Gamma$.
A \textit{hypersequent} is a finite sequence of sequents (called
\textit{components})
where the same
variable has the same type even if it appears in different components.
The typing rules for the terms are given in Fig.~\ref{termassign}.

\begin{figure}[p]
 \small
  \begin{center}
\textbf{External Rules}
\vskip 2mm
%% communication
\BinaryRule
   {$\hypert_0\hmid\Gamma,\Delta\tr\tj{M}{[i]\varphi}$}
   {$\hypert_1\hmid\Gamma,\Delta\tr\tj{N}{[j]\psi}$}
   {}
   {$\cotuple{\hypert_0,\hypert_1}\hmid\Gamma\tr\tj{\ltor i{l}\Delta{M}}{[i]\psi}\hmid
   \Delta\tr\tj{\rtol j{l}\Gamma {N}}{[j]\varphi}$}
\hfill
%% external structural   
 \UnaryRule
 {$\hypert^+$}
 {}
 {$\hypert^+\hmid\Gamma\tr \tj \abort {\m\varphi}$}
\vskip 2mm
 \UnaryRule
 {$\hypert\hmid\Gamma\tr\tj M {\m\varphi}\hmid\Gamma\tr \tj N {\m\varphi}$}
 {}
 {$\hypert\hmid\Gamma\tr \tj {\cotuple{M,N}}{\m\varphi}$}
\hfill
 \UnaryRule
 {$\hypert\hmid\Gamma\tr M\colon\m\varphi\hmid\Delta\tr N\colon \m\psi\hmid \hypert'$}
 {}
 {$\hypert\hmid\Delta\tr N\colon\m\psi   \hmid\Gamma\tr M\colon \m\varphi\hmid \hypert'$}
 \vskip 2mm
\textbf{Inner Global Rules}
   \vskip 2mm
   \UnaryRule
   {$\hypert\hmid \Gamma\tr\tj M {\m\varphi}$}
   {}
   {$\hypert\hmid \tj x {\m\psi}, \Gamma\tr \tj{M}{\m\varphi}$}
   \hfill
   \UnaryRule
   {$\hypert\hmid \tj{x}{\m\varphi}, \tj{y}{\m\varphi}, \Gamma\tr \tj
   M{\m\psi}$}
   {}
   {$\hypert \hmid \tj{x}{\m\varphi}, \Gamma\tr \tj{M[x/y]}{\m\psi}$}
\vskip 2mm
\UnaryRule
   {$\hypert\hmid\Gamma,\tj x{\m\varphi},\tj y{\m\psi},\Delta\tr
   \tj M{\m\theta}$}{}
   {$\hypert\hmid\Gamma,\tj y{\m\psi},\tj x{\m\varphi},\Delta\tr \tj M{\m\theta}$} %IE
\hfill
%% conj intro
\BinaryRule
   {$\hypert_0\hmid\Gamma\tr \tj M{\m\varphi}$}
   {$\hypert_1\hmid\Gamma\tr \tj N{\m\psi}$}
   {}
   {$\cotuple{\hypert_0,\hypert_1}\hmid\Gamma\tr
     \tj{\gpair{M,N}}{\m\varphi\wedge\m\psi}$}
   \vskip 2mm
%% conj elim
  \UnaryRule
   {$\hypert\hmid\Gamma\tr M\colon\m\varphi\wedge\m\psi$}
   {}
   {$\hypert\hmid\Gamma\tr \gpil{M}\colon\m\varphi$}
   \hfill
  \UnaryRule
   {$\hypert\hmid\Gamma\tr M\colon\m\varphi\wedge\m\psi$}
   {}
   {$\hypert\hmid\Gamma\tr\gpir M\colon\m\psi$}
\vskip 2mm
%% disj intro
  \UnaryRule
   {$\hypert\hmid\Gamma\tr M\colon\m\varphi$}
   {}
   {$\hypert\hmid\Gamma\tr\ginl{M}\colon\m\varphi\vee\m\psi$}
   \hfill
  \UnaryRule
   {$\hypert\hmid\Gamma\tr M\colon\m\psi$}
   {}
   {$\hypert\hmid\Gamma\tr \ginr{M}\colon\m\varphi\vee\m\psi$}
\vskip 2mm
%% disj elim
\TrinaryRule
   {$\hypert_0\hmid\Gamma\tr \tj M {\m\varphi\vee\m\psi}$}
   {$\hypert_1\hmid\tj x{\m\varphi},\Gamma\tr \tj {N_0}{\m\theta}$}
   {$\hypert_2\hmid\tj y{\m\psi},   \Gamma\tr \tj {N_1}{\m\theta}$}
   {}
   {$\cotuple{\cotuple{\hypert_0,\hypert_1},\hypert_2}\hmid\Gamma \tr \tj{\gmat M x {N_0} y {N_1}}{\m\theta}$}
\vskip 2mm
\textbf{Inner Local Rules}
\vskip 2mm
%% axiom   
  \UnaryRule{}{}{$\tj x{[i]\varphi}, \Gamma\tr \tj x{[i]\varphi}$}
                       \hfill
%% bot elim   
 \UnaryRule
   {$\hypert\hmid\Gamma\tr \tj M{[i]\bot}$} {}
   {$\hypert\hmid\Gamma\tr \tj{\abort}{[i]\varphi}$}
   \vskip 2mm
%% local imp intro
  \UnaryRule
   {$\hypert\hmid\tj x{[i]\varphi},\Gamma\tr \tj M{[i]\psi}$}
   {}
   {$\hypert\hmid\Gamma\tr \tj{\lambda x.M}{[i](\varphi\supset\psi)}$}
                       \hfill
%% local imp elim
  \BinaryRule{$\hypert_0\hmid\Gamma \tr \tj M{[i](\varphi\supset \psi)}$}
  {$\hypert_1\hmid\Gamma\tr \tj N{[i]\varphi}$}
  {}
  {$\cotuple{\hypert_0,\hypert_1}\hmid\Gamma\tr \tj{MN}{[i]\psi}$}
                       \vskip 2mm
%% local conj intro
\BinaryRule{$\hypert_0\hmid\Gamma\tr \tj M{[i]\varphi}$}
   {$\hypert_1\hmid\Gamma\tr \tj N{[i]\psi}$}
   {}
   {$\cotuple{\hypert_0,\hypert_1}\hmid\Gamma\tr
     \tj{\lpair {M,N}}{[i](\varphi\wedge\psi)}$}
   \vskip 2mm
%% local conj elim
  \UnaryRule
   {$\hypert\hmid\Gamma\tr M\colon[i](\varphi\wedge\psi)$}
   {}
   {$\hypert\hmid\Gamma\tr \lpil{M}\colon[i]\varphi$}
   \hfill
  \UnaryRule
   {$\hypert\hmid\Gamma\tr M\colon[i](\varphi\wedge\psi)$}
   {}
   {$\hypert\hmid\Gamma\tr\lpir M\colon[i]\psi$}
\vskip 2mm
%% local disj intro
  \UnaryRule
   {$\hypert\hmid\Gamma\tr M\colon[i]\varphi$}
   {}
   {$\hypert\hmid\Gamma\tr\linl {M}\colon[i](\varphi\vee\psi)$}
   \hfill
  \UnaryRule
   {$\hypert\hmid\Gamma\tr M\colon[i]\psi$}
   {}
   {$\hypert\hmid\Gamma\tr \linr{M}\colon[i](\varphi\vee\psi)$}
\vskip 2mm
%% local disj elim
\TrinaryRule
   {$\hypert_0\hmid\Gamma\tr \tj M {[i](\varphi\vee\psi)}$}
   {$\hypert_1\hmid\tj x{[i]\varphi},\Gamma\tr \tj {N_0}{[i]\theta}$}
   {$\hypert_2\hmid\tj y{[i]\psi},   \Gamma\tr \tj {N_1}{[i]\theta}$}
   {}
   {$\cotuple{\cotuple{\hypert_0,\hypert_1},\hypert_2}\hmid\Gamma \tr \tj{\lmat M x {N_0} y {N_1}}{[i]\theta}$}
\vskip 2mm
\end{center}
 \caption{Term assignment.
 $\hypert$ stands for
 a possibly empty hypersequent (with possible subscripts).
 $\hypert^+$ stands for a non-empty hypersequent.
 Within each rule, $\hypert_0$, $\hypert_1$ and $\hypert_2$ have the
 same length and the same type so that $\cotuple{\hypert_0,\hypert_1}$
 can be defined as
 the elementwise application of $\cotuple{\term,\term}$.
 }
 \label{termassign}
\end{figure}

\subsection{Reduction}

A term~$M$ is \textit{of} type~$\m\varphi$ iff there is a derivation of
$\Gamma\tr
\tj{M}{\m\varphi}$.
A \textit{local} term is a term without $\overleftarrow l$,
$\overrightarrow l$ or any $\g$ constructs.
A \textit{hyperterm}~$\hypert$ is a nonempty sequence of terms.
A \textit{store} maps a location to a
local term or $\epsilon$.
For a store~$\sigma$, the updated store $\sigma[l\mapsto x]$ maps $l$ to
$x$ and $l'$ to $\sigma(l')$ if $l'$ is different from~$l$.
A \textit{configuration} is a triple $\conf{}{}\hypert$ of two
stores $\lstore, \rstore$ and a hyperterm~$\hypert$.

To complete the definition of \lgd,
 we define the \textit{reductions} $\reduce_\clubsuit$ of
 configurations for $\clubsuit\in\{\mathrm B, \mathrm W, \mathrm R, \mathrm A,
 \mathrm P\}$.
 We consider terms up to $\alpha$-equivalence and implicitly
 require all instances
 of $\rightsquigarrow_\clubsuit$ to avoid free variable captures.
 Below, $\square$ and $\blacksquare$ match $\g$ or nothing.

\begin{definition}[Basic Reduction]
 The basic reduction $\breduce$ is the smallest congruence containing
 the followings:
 \begin{itemize}
  \item  $\conf{}{}{(\lambda x.M)O}\breduce
 \conf{}{}{M[O/x]}$
  \item $\conf{}{}{\spil{\spair{M,N}}} \breduce
	 \conf{}{}{           M   }$
  \item $\conf{}{}{\spir{\spair{M,N}}} \breduce
	 \conf{}{}{             N }$
  \item $\conf{}{}{\smat{\sinl M}x N y O} \breduce
	 \conf{}{}{              N[M/x]}$
  \item $\conf{}{}{\smat{\sinr M}x N y O} \breduce
	 \conf{}{}{                  O[M/y]}$
 \end{itemize}
\end{definition}

There are two sorts of reductions that interact with the store.
In summary, $\rtol i l \Gamma N$ tries to write to the right store and read from
the left store of the configuration.
If a term tries to read from an empty location of a store,
the term changes into $\abort$.  If a term writes to a full location of
a store, it does not abort but the store is not updated.
The formal definition follows.
\begin{definition}[Write Reduction]
 The write reduction $\wreduce$ is the smallest congruence
 containing the followings where $M$ is a local term:
 \begin{itemize}
  \item $\conf{}{[l\mapsto\epsilon]}{\rtol i l \Gamma M}
	\wreduce
	\conf{}{[l\mapsto M]}{\rtol i l \Gamma M}
	$\enspace,
  \item $\conf{[l\mapsto\epsilon]}{}{\ltor j l \Delta M}
	\wreduce
	\conf{[l\mapsto M]}{}{\ltor j l \Delta M}
	$\enspace.
 \end{itemize}
\end{definition}

\begin{definition}[Read Reduction]
 \label{read}
 The read reduction $\rreduce$ is the smallest congruence
 containing the
 followings:
\begin{itemize}
 \item  $\conf{[l\mapsto {N}]}{[l\mapsto M']}{\rtol i l\Gamma M}\rreduce
	\conf{[l\mapsto {N}]}{[l\mapsto M']}{N}$
 \item  $\conf{[l\mapsto \epsilon]}
	{[l\mapsto M']}{\rtol i l\Gamma M}\rreduce
	\conf{[l\mapsto \epsilon]}{[l\mapsto M']}{\abort}$
 \item  $\conf{[l\mapsto M']}{[l\mapsto {N}]}{\ltor i l \Delta M}\rreduce
	\conf{[l\mapsto M']}{[l\mapsto {N}]}{N}$
 \item  $\conf{[l\mapsto M']}{[l\mapsto \epsilon]}{\ltor i l \Delta M}\rreduce
	 \conf{[l\mapsto M']}{[l\mapsto \epsilon]}{\abort}$\enspace .
\end{itemize}
\end{definition}

\begin{definition}[Abort Propagation Reduction]
 The abort propagation reduction $\areduce$ is the smallest
 congruence containing the
 followings:
\begin{itemize}
 \item  $\conf{}{}{\cotuple{\abort, M}}\areduce
 \conf{}{}{M}$, and
   $\conf{}{}{\cotuple{M,\abort}}\areduce
 \conf{}{}{M}$
 \item  $\conf{}{}{C[\abort]}\areduce
 \conf{}{}{\abort}$
\end{itemize}
 where $C[\bullet]$ is 
$\bullet N$, 
${M \bullet}$,
$\ltor i l \Delta \bullet$,
$\rtol i l \Gamma \bullet$,
$\sinl \bullet$,
$\sinr \bullet$,
$\spair {\bullet, N}$,
$\spair {M, \bullet}$,
$\pi^\square_i \bullet$.
$\smat M x N y \bullet$,
$\smat  \bullet x N y O$, or  \\
$\smat  M x \bullet y O$ 
\end{definition}
In order to obtain subformula property
 via proof normalization
we add yet another kind of reduction rules.
\begin{definition}[Permutative Reduction]
 The permutative reduction~$\preduce$ is the smallest congruence
 containing the followings:
\begin{itemize}
 \small
 \item $\conf{}{}{ \left(\smat  M x N y O\right) P }\preduce$ \\
       $\conf{}{}{ \smat M x {N P} y {O P} }$
 \item $\conf{}{}{ \pi^\square_d \left(\bsmat M x N y
       O\right)}\preduce$\\
       $\conf{}{}{ \bsmat M x
       {\pi^\square_d N} y {\pi^\square_d O} }$
 \item {
       $\conf{}{}{ \smat
                          {\left(\bsmat  M x N y O\right)}
                          u P v Q
                      }\preduce$ \\
       $(\lstore, \rstore, 
        \mathsf{match}^{\blacksquare}\,{M}\,\mathsf{of}\, \bsinl{x}. {
                          {\left(\smat N u P v Q\right)}
       } /$ \\ \phantom{mmmmmmmmmmm}$
       \bsinr{y}. {\left(\smat  O u P v Q\right)}
                      )
       $}
 \item $\conf{}{}{ \cotuple{M, N} P }\preduce
        \conf{}{}{ \cotuple{MP, NP} }$
 \item $\conf{}{}{ \pi^\square_d\cotuple{M,N} }\preduce
        \conf{}{}{ \cotuple{\pi^\square_d M, \pi^\square_d N} }$
 \item $\conf{}{}{ \smat {\cotuple{M,N}} x P y Q }\preduce$\\
       $\conf{}{}{ \cotuple{
                          \smat  M x P y Q,
                          \smat N x P y Q
                        } }$
\end{itemize}
\end{definition}

We define $\reduce$ to be the union of $\breduce$, $\wreduce$, $\rreduce$,
$\areduce$ and $\preduce$.
The reflexive transitive closure of $\reduce$ is
written as~$\reduction$.
A \textit{redex} is a subterm that can be rewritten by a reduction.
A configuration~$\mathcal{C}$ is \textit{normal} when there is no configuration
$\mathcal{D}$ with $\mathcal{C}\reduce \mathcal{D}$.
A term~$M$ is \textit{normal} when the configuration $\conf{}{}{M}$ is
normal (the choice of $\lstore$ and $\rstore$ is irrelevant).

\subsection{Properties}

An important property of
\lgd is \textit{strong normalization}:
every typed hyperterm has a maximal number of reductions it can
take.
Another is \textit{non-abortfullness}: although some reductions yield
$\abort$ terms, a typed hyperterm never reduces to a hyperterm that only
contains $\abort$'s.  We show this first for its simpler proof.

\begin{theorem}[Non-abortfullness]
 \label{nab}
 All normal forms of a typed configuration contain at least one term
 that is not $\abort$.
\end{theorem}
\begin{proof}
 When a reduction sequence is fixed, for any location~$l$, depending on
 whether the right or the left store is filled first, 
 either:
 (i) no ${\ltor i l \Delta M} \reduce {\abort}$ occurs for any~$i$, or
 (ii) no ${\rtol i l\Gamma M} \reduce {\abort}$ occurs for any~$i$.

If the former is the case, we can rewrite
a communication rule occurrence
\begin{center}
 \BinaryRule
 {$\hypert_0\hmid  \Gamma,\Delta\tr \tj M{[i]\psi}$}
 {$\hypert_1\hmid \Gamma,\Delta\tr \tj N{[j]\tau}$}
 {}
 {$\cotuple{\hypert_0,\hypert_1}\hmid \Gamma\tr \tj
   {\ltor i l \Delta M}{[i]\tau}\hmid
   \Delta\tr \tj{\rtol i l\Gamma N}{[j]\psi}$}
\end{center}
into successive external weakening occurrences
\begin{center}
 \AxiomC
 {$\hypert_0\hmid  \Gamma^j, \Delta^j\tr \tj M{[j]\psi}$}
\doubleLine
 \UnaryInfC
 {$\hypert_0\hmid \tr \tj \abort
 {[i]\tau}\hmid
   \Gamma^j,\Delta^j\tr \tj{M}{[j]\psi}$}
 \DisplayProof
\end{center}
 where $\Gamma^j$ and $\Delta^j$ can be obtained from the originals
 by changing every
 modality~$[k]$ to $[j]$.
In the lattar case, we can do the symmetric.

After these rewritings for all appearing locations,
we obtain a derivation not containing
$\overrightarrow{l}$ or $\overleftarrow{l}$.
Moreover, the end hypersequent of the resulting derivation has a component
not containing $\abort$.
The reductions of the original hyperterm can be simulated by the
resulting hyperterm.  And, even after reductions, the resulting
hyperterm has a component not containing $\abort$.
\end{proof}

\begin{theorem}[Strong Normalization]
 \lgd\, is strongly normalizing.
\end{theorem}
\begin{proof}
For proving this, we consider the \textit{local fragment} that does not contain
$\ltor i l \Delta M$, $\rtol j l\Gamma N$ or any construct with $\g$.
We first reduce the strong
normalization of the \lgd\, to that of the local fragment, and 
ultimately to that of de Groote's
natural deduction with permutation-conversion~\cite{Philippe2002js}%
\footnote{
To the 
same effect, we might be able to use other strong normalization
 results for lambda calculi with commutative conversions, like Balat,
 Di~Cosmo
 and Fiore~\cite{bdf}.
}%
.

We assume an infinite sequence of reductions
$
\conf{_0}{_0}{\hypert_0}
\reduce
\conf{_1}{_1}{\hypert_1}
\reduce
\conf{_2}{_2}{\hypert_2}
\reduce\cdots 
$.  From this, we are going to construct an infinite sequence of
reductions in the local fragment.

For that, we first
build an infinite reduction sequence with constant stores. 
Using the original infinite sequence, we define a pair of stores called the
\textit{store prophecy} $(\lstore_\infty, \rstore_\infty)$ where
$ \lstore_\infty(l)= \epsilon$ if $\lstore_k(l)=\epsilon$ for all
 $k\in\omega$ and
$ \lstore_\infty(l)=M $ if $\lstore_k(l)=M$ for some $k\in\omega$
; and $\rstore_\infty(l)$ is symmetrically defined.
Since store contents are never overwritten,
$\lstore_\infty$ and $\rstore_\infty$ are well-defined.
Moreover,
$\lstore_i(l)$ and $\lstore_\infty(l)$ coincide unless
$\lstore_i(l)=\epsilon$.

We build another reduction sequence
$
\conf{_\infty}{_\infty}{\hypert_0}
\reduce^\ast
\conf{_\infty}{_\infty}{\hypert'_1}
\reduce^\ast
\conf{_\infty}{_\infty}{\hypert'_2}
\reduce^\ast\cdots
$
with the following invariant:
$\mathcal M'_i$ can be obtained by replacing some $\abort$ occurrences
in $\mathcal M_i$ with some terms.
More specifically, we translate each reduction as follows, keeping the
invariant inductively on the number of steps
(the base case is satisfied by $\mathcal M'_0 = \mathcal M_0$ immediately):
\begin{itemize}
 \item a read reduction $\conf{_k}{_k}{\hypc{}{\rtol i l\Delta M}}
       \rreduce
       \conf{_{k+1}}{_{k+1}}{\hypc{}{O}}$ is translated into
       $\conf{_\infty}{_\infty}{\hypc'{\rtol i l\Delta M}} \rreduce
       \conf{_{k+1}}{_{k+1}}{\hypc'{O'}}$.
       If $\lstore_i(l)$ is a term,
       $\lstore_\infty(l)$ and $O'$ are also identical to the term.
       Otherwise, $O'$ must be $\abort$.
       Thus, the invariant
       holds for $k+1$.
 \item a write reduction disappears;
 \item an $\abort$ propagation
       $\hypc{}{C[\abort]} \areduce \hypc{}{\abort}$ can be translated
       either to a similar reduction or no reduction if the $\abort$ in
       the redex is replaced by another term in the $\mathcal{M'}_k$.
       Note that even in that case, the result $\mathcal{M'}_{k+1}$ can
       be obtained by replacing some $\abort$ occurrences in
       $\mathcal{M}_{k+1}$ with other terms;
 \item any other reduction $\conf{_k}{_k}{\hypc{}{M}} \bpreduce
       \conf{_{k+1}}{_{k+1}}{\hypc{}{N}}$
       is translated into one similar reduction
       $\conf{_\infty}{_\infty}{\hypc{'}{M'}}\bpreduce
        \conf{_\infty}{_\infty}{\hypc{'}{N'}}$.
\end{itemize}
Here, we have to show that the translated sequence is infinite.
For that, we can use the facts that
 there are only finite
number of usedlocations each of which allows only one write, and that
an $\abort$ propagation always
strictly shortens the term under operation. 
 
 After that, we can replace
 every ${\rtol i l\Gamma M}$ with
 $\rstore_\infty(l)$.
 Since $\rtol i l\Gamma M$ either reduces to $\rstore_\infty(l)$ or $\abort$,
 replacing it with $\rstore_\infty(l)$ will only ``shorten'' the reduction
 sequence for at most one read step.
 We can do the same for $\ltor j l \Gamma N$.
 Replacing every such occurrences
 makes an infinite reduction sequence where every occurring term is
 in the local fragment.
 Moreover, 
 the result of the translation is also well-typed.
 A typing derivation of the resulting hyperterm can be obtained by
 replacing com' rules with EW rules and changing the process number in
 types of some variables (c.f. the proof of Thm.~\ref{nab}).

We are aiming at reducing the problem to the strong normalization result
by de Groote~\cite{Philippe2002js}.
Since we have eliminated $\ltor i l \Delta M$ or $\rtol i l\Gamma N$ occurrences,
the remaining difference is small: some $\abort$ propagation reductions
 and some permutative reductions involving $\cotuple{\term,\term'}$.
We just have to make sure that there are no infinite reduction sequences
that consist of these two kinds of reductions only.
We can deal with the permutative reductions following de
 Groote~\cite{Philippe2002js}'s strategy for introducing~$\bot$.
For $\abort$ propagation, we can apply the previous argument.
\end{proof}

\section{Typed Waitfreedom}
\label{waitfreedom}

Waitfreedom~\cite{Herlihy88,Saks:1993vq} is a class of protocols
that can solve
some of the input-output problems~\cite{Moran:1987ep,Biran:1988hh}.
We define the typed version of waitfreedom.

\subsection{Typed Input-Output Problem}

Saks and Zaharoglou~\cite{Saks:1993vq} formulated waitfreedom as a class
of input-output
problems.
Given inputs for all processes and outputs of all
processes, an input-output problem decides whether the processes have
succeeded or not.
We change the standard definition and have typed terms as inputs and
outputs.

For that, we let $\lterm(\varphi)$ denote the set of closed, local terms of
type~$\varphi$,
and $\lval(\varphi)$ denote the set of normal terms in $\lterm(\varphi)$.
For a finite set of processes~$\processes$, 
a \textit{typed input-output problem} consists of each process's input type
$(\iota_i)_{i\in \processes}$, each process's output type $(o_i)_{i\in
\processes}$, and a
task $R\subseteq \prod_{i\in \processes}\left(\lterm(\iota_i)\right)\times
 \prod_{i\in \processes}\left(\lval(o_i)\right)$.

\subsection{Typed Protocol}

We assume a finite set~$\processes$
of processes and a countably infinite
set of program variables $\ProV =\{\p x, \p y, \p z, \ldots\}$.
We assume an injection from variables to program variables $x\mapsto
\p{x}_x$, whose image leaves infinitely many unused program variables.

A \textit{program} is defined by BNF:
\[
 p ::= \epsilon\mid
 \p x\leftarrow E; p \mid
 l \leftarrow E; p
\]
where an \textit{expression} is
\begin{align*}
 E
 ::=\,\,
 &x\mid \p x \mid l \mid (EE)\mid \lambda
 x.E\mid \tuple{E,E}\mid \linl{E}\mid \linr{E}\mid \\
 &\lpil{E}\mid\lpir{E}\mid  \lmat E x {E} y {E}\mid \epsilon\enspace.
\end{align*}

\newcommand{\Wg}{W_{\mathrm g}}
\newcommand{\Wd}{W_{\mathrm d}}
A program is \textit{well-formed} when
a program variable (resp. location) first appears in a $\p x\leftarrow E$
(resp. $l\leftarrow E$)
sentence, and
after that, only appears in expressions.
For a contexted type $t = (\Gamma\tr\m\varphi)$,
we write $\tj{M}{t}$ for
$\Gamma\tr\tj{M}{\m\varphi}$.
For input types $(\iota_i)_{i\in\processes}$
and output types $(o_i)_{i\in\processes}$, 
a \textit{typed protocol} has:
\begin{itemize}
 \item two program variables
      $\p i_i$ and $\p o_i$ for each process~$i$;
 \item a finite set of locations~$L$;
 \item two functions $g\colon L\rightarrow \processes$
       and $d\colon L\rightarrow
       \processes$ (specifying the left side writer and the right side writer of
       each location);
       $g(l)$ might read what $d(l)$ writes and vice versa;
 \item $\Wg, \Wd$: each maps a location in $L$ to a contexted type;
       $g(l)$ writes a term of $\Wg(l)$ and $d(l)$ writes a term of $\Wd(l)$;
 \item a function $t_i$ for each $i\in \processes$;
       that maps a program variable to a contexted type
       $(\tj{x_k}{\varphi_k})_k \tr[i]\varphi$ with a special condition
       $t_i(\p i_i)= \iota_i$;
 \item a typed program~$p_i$ for each $i\in \processes$,
       where
a \textit{typed program} is a well-formed program where all
sentences are typed according to $(t,g,d,i,\Wg, \Wd)$.
A sentence $\p x \leftarrow E$ is typed  iff $E\colon t(\p x)$ is derivable with
assumptions of the form $\tr\tj{\p y}{t(\p y)}$,\quad
$\tr\tj{l}{W_{\mathrm d}}(l)$ and
$\tr\tj{l}{W_{\mathrm g}}(l)$.
\end{itemize}

\subsection{Typed Waitfree Computation}

We define when a protocol solves a typed
input-output problem.
These definitions are transferred from \cite{Saks:1993vq}.

Let $\processes$ be $\{0,\ldots, n-1\}$ and fix
a typed protocol.
A \textit{program variable content} $m$ for $i\in\processes$ is a
partial
function
that maps a program variable to a term of $t_i(\p x)$.
A term~$M$ \textit{is of} a contexted type $\Gamma\tr\varphi$ when
$\Gamma\tr
\tj M\varphi$ is derivable.
A \textit{process snapshot} of $i\in\processes$ is a tuple
$\tuple{p,m}$ where $p$ is either a program or $\abort$ and $m$ is a
program variable content for $i$.
We let $S_i$ denote the set of process snapshots for~$i$.
A \textit{system snapshot}
is a pair $\tuple{\vec s, \vec v}$, where $\vec s = \tuple{s_0,
{s_1,{\ldots,s_{n-1}}}} \in
\prod_{i\in \processes}\left(S_i\right)
$
and
$\vec v =
\left(\tuple{\vg{v}{l}, \vd{v}{l}}\right)_{l\in L} \in \prod_{l\in
L}\left((\val(\Wg(l))\cup\{\epsilon\})\times (\val(\Wd(l))\cup\{\epsilon\})\right)
$.

For a nonempty subset~$J$ of $\processes$, we define an operator $\update J$ that
takes a system snapshot and produces a system snapshot.
This operator depicts a computation step where the processes in~$J$
are fired.

We define $
(\vec s, \vec v) \update J = (\vec u, \vec m)
$ by defining
$u_i$ and $m_i$
where $s_i = \tuple{p,x}$:
\begin{align*}
 u_i & =
 \begin{cases}
 \tuple{p',x}  & (\text{if } p = l
 \leftarrow E; p' \text{ and }\sem{E}_{x,\vec v} \neq \epsilon)
 \\
 \tuple{\epsilon,x}  & (\text{if } p = l
 \leftarrow E; p' \text{ and }\sem{E}_{x,\vec v} = \epsilon)
 \\
 \tuple{p', x[\p x \mapsto \sem{E}_{x, \vec v}]}&
                       (\text{if } p = \p x \leftarrow E; p', \quad
 x(\p x) = \epsilon  \text{ and } \sem{E}_{x, \vec v} \neq \epsilon) \\
 \tuple{\epsilon, x}&
                      (\text{if } p = \p x \leftarrow E; p',  \quad
 x(\p x) = \epsilon  \text{ and } \sem{E}_{x, \vec v} = \epsilon) \\
 \tuple{\epsilon, x} & (\text{if } p = \p x \leftarrow E; p' \text{
 and }
 x(\p x) \neq \epsilon) \\
 s_i & (\text{if } p = \epsilon)
 \end{cases}\\
 \vg m l & =
 \begin{cases}
 \sem{E}_{x, \vec v} & (\text{if } p = l \leftarrow E; p',\quad g(l)= i \text{
 and } \vg v l = \epsilon) \\
 \vg v l &(\text{otherwise})
 \end{cases}\\
 \vd m l &=
 \begin{cases}
\sem{E}_{x, \vec v} &
  (\text{if } p = l \leftarrow E; p',\quad d(l)= i \text{
 and } \vd v l = \epsilon) \\
 \vd v l &(\text{otherwise})
 \end{cases}
\end{align*}
with the following notations.
We let $i(l)$ to be $\vg v l$ if $d(l)=i$ and
$\vd v l$ if $g(l) = i$.
The term
$\sem{E}_{x, \vec v}$ is defined as the unique normal form
%{show, show, show}
of $E[x(\vec{\p y}) / \vec{\p y}][\vec{i(l)}/\vec l]$, where
every program variable~$\p y$ is replaced by $x(\p y)$ and the
uniqueness is guaranteed by the absence of $\overleftarrow l$ or
$\overrightarrow l$.
If any of the substitutes is $\epsilon$,
$\sem{E}_{x, \vec v}$ is $\epsilon$.

A \textit{schedule} is an infinite sequence of nonempty subsets of~$\processes$,
which looks like $\sigma = \sigma_0\sigma_1\sigma_2\cdots$.
We say $i$ is \textit{nonfaulty} in $\sigma$
if it appears infinitely often.
When every process is nonfaulty, the schedule is \textit{fair}.

A \textit{run} is a triple $\tuple{\Pi, \vec x, \sigma}$,
where $\Pi$ is a typed protocol,
$\vec x \in \prod_{i\in \processes} \lterm(\iota_i)$ is the input,
and $\sigma$ is a schedule.
The \textit{execution} associated to the run
is defined as the infinite sequence of system snapshots
$C_0C_1C_2\cdots$, where $C_0 = \tuple{\vec{s^0}, \vec{v^0}}$ is
defined by $\vec{s^0_i} = \tuple{p_i, [\p i_i\mapsto x_i]}$ and
$\vg v l  = \vd v l = \epsilon$,
and $C_{k+1} = C_{k}\update
\sigma_{i+1}$.

Process~$i$'s \textit{output}~$\hat{o_k}$ at step~$k$ is
$M$ if the $i$-th process snapshot of $C_k$ is
$(p, x)$ and the $x[\p{o}_i] = M$, which can be $\epsilon$.
The decision value of $i$ on the run $\tuple{\Pi,\vec x,\sigma}$,
denoted~$d_i \in \lval(o_i)\cup\{\epsilon\}$
 is the first non-$\epsilon$ element in the sequence
 $\left(\hat{o_k}\right)_{k\in\omega}$,
 or
$\epsilon$ if such element does not exist.
The $n$-tuple~$\vec d$ is defined by $d_i$'s.

A vector $\vec b\in \prod_{i\in \processes}(\lval(o_i))$
is \textit{compatible with} $\vec d \in \prod_{i\in
\processes}\left(\lval(o_i)\cup\{\epsilon\}\right)$ iff
$d_i = b_i$ or $d_i = \epsilon$ holds for any process~$i$.
An input~$\vec x\in \prod_{i\in \processes}\lterm(\iota_i)$
is \linebreak[2] $R$-\textit{permissible} iff there is at least one
vector $\vec d\in \prod_{i\in \processes}(\lval(o_i))$ with $(\vec x, \vec b)\in R$.
A typed protocol~$\Pi$ \textit{solves} the typed input-output problem
  $\tuple{(\iota_i)_{i\in \processes}, (o_i)_{i\in \processes}, R}$ on
schedule~$\sigma$ iff for all $R$-permissible inputs~$\vec x$ and a
schedule~$\sigma$,
 the decision value of every nonfaulty process~$i$ is a term
       $M$ not $\epsilon$, and
 there is a vector $\vec b\in \prod_{i\in \processes}(\lval (o_i))$
with $\tuple{\vec x, \vec b} \in R$ which is compatible with the
 decision vector~$\vec d$.
A typed protocol is \textit{waitfree} iff it solves
the problem on every schedule $\sigma$.
In that case, the typed input-output problem is 
\textit{waitfreely solvable}.

\section{Characterization of Waitfreedom and \lgd}
\label{comparison}

We compare the ability of the waitfree protocols and \lgd\,.
\begin{definition}
 A typed input-output problem
 $\tuple{(\iota_i)_{i\in \processes}, (o_i)_{i\in \processes}, R}$ is
 solvable by a term
 $M$ of contexted type
 $\left(\tj{x_i}{[i]\iota_i}\right)_{i\in\processes}
 \tr\left(\wwedge_{i\in
 \processes}[i]o_i\right)$ 
 iff
 for any closed $(N_i)_{i\in \processes}$ of $\iota_i$,
 all normal forms of $M[\vec{N_i}/\vec{x_i}]$
 are in the form
 $\tuple{{V_0}, \tuple{{V_1},
 \cdots\tuple{{V_{n-2}},\tuple{{V_{n-1}},\bullet}}\cdots}}$
 where $\tuple{(N_i)_{i\in \processes}, (V_i)_{i\in \processes}}\in R$.
 % looks like we assume subformula property
\end{definition}

\begin{theorem}[Soundness]
If a typed input-output problem is solvable by a term,
there exists a typed protocol that solves the problem.
\end{theorem}

We are going to translate a typed hyperterm into a protocol inductively
on the type derivation.
To make induction work, we use the following auxiliary notions.
An \textit{investigator} $\tuple{i, \p x}$ is a pair of a process and a program
variable.
For a local formula~$\varphi$, a system snapshot $\tuple{\vec s,\vec v}$
satisfies
$\tuple{i,\p x}(\varphi)$ iff
$s_i(\p x)$ is an expression of $\varphi$.
For a set of investigators~$I$,
a system snapshot satisfies
$I([i]\varphi)$ iff it satisfies
$\tuple{i, \p x}(\varphi)$ for some $\p x$ with
$\tuple{i,\p x}\in I$.
This can be extended to all global formulae, as
$I(\m\varphi\wedge\m\psi)$ iff $I(\m\varphi)$ and $I(\m\psi)$;
$I(\m\varphi\vee\m\psi)$ iff $I(\m\varphi)$ or $I(\m\psi)$.
A \textit{system snapshot satisfies a global formula}~$\m\varphi$
iff there exists a
finite set of
investigators~$I$ such that the system snapshot satisfies $I(\m\varphi)$.
A \textit{system snapshot satisfies a context} iff it
satisfies every global formula in the context.
A \textit{protocol} $p$ \textit{realizes a hypersequent}~$
\left(\Gamma_0\vdash
\m\varphi_0 \hmid \cdots\hmid\Gamma_{k}\vdash \m\varphi_{k}\right)$
iff
for any initial system snapshot satisfying
every~$\Gamma_{k'}$,
there exists a family of investigator sets
$(I_{k'})_{k'\in\{0,\ldots,k\}}$ and,
when $p$ is executed with any fair schedule,
the resulting system snapshots eventually always satisfies at least one of
$\varphi_{k'}^+$.

For a typed 
hyperterm~$\hypert$,
we will give $\sem{\hypert}$, which is a tuple of programs indexed
by~$\processes$.
Also, we define $\semi{\hypert}$ at the same time as
$\sem{\hypert}$, where
$\semi{\hypert}$ is a sequence of finite sets of investigators whose
length is the same as that of $\hypert$.
We refer to the last element of $\semi{\hypert\hmid M}$ as
$\semi{\hypert\hmid \hat{M}}$, the second to last element of
$\semi{\hypert\hmid M\hmid N}$ as 
$\semi{\hypert\hmid \hat M\hmid N}$ and so on.
We denote the right projection of $\semi{\hypert\hmid \hat{M}}$ as
$\semi{\hypert\hmid \hat{M}}'$.
If two sequents of investigator sets $\semi{\hypert}$ and $\semi{\hypert'}$
have the same length, we define $\semi{\hypert}\cup \semi{\hypert'}$ to
be the elementwise union.

We let $\epsilon$ denote $(p_i)_{i\in\processes}$ where $p_i=\epsilon$
for all $i\in\processes$.
Also, $(p_i)_{i\in\processes}; (q_i)_{i\in\processes}$ denotes
$(p_i; q_i)_{i\in\processes}$ where the
same program variable does not have multiple substitutions
(we rename variables in the original typing derivation to satisfy this).
And $(p)_j$ denotes $(q_i)_{i\in\processes}$ where $q_j = p$ and $q_i =
\epsilon$ for all $i\neq j$.
Below, we always choose fresh program variables.
The definition is inductive over the type derivation.
{\footnotesize
\begin{align*}
 \sem{\cotuple{\hypert_0,\hypert_1}\hmid \ltor j l \Delta M\hmid \rtol i l\Gamma N}
 =& \sem{\hypert_0\hmid M};
 \sem{\hypert_1\hmid N};\\
 &(l\leftarrow \semi{\hypert_0\hmid\hat M}'; \p
 y\leftarrow l;)_j; \\
 &(l\leftarrow \semi{\hypert_1\hmid\hat N}'; \p
 x\leftarrow l;)_i\enspace,\\
 \semi{\cotuple{\hypert_0,\hypert_1}\hmid\ltor j l \Delta M\hmid \rtol i l\Gamma N} =&
 \semi{\hat \hypert_0\hmid M} \cup \semi{\hat \hypert_1\hmid N} \hmid\\& \tuple{\{j,\p
 y\}}\hmid \{\tuple{i,\p x}\}\enspace,\\
 \sem{\hypert\hmid \abort}=\sem{\hypert}\enspace,\quad
 \semi{\hypert\hmid\abort}=&\semi{\hypert}\hmid \emptyset\enspace,\quad
 \sem{x}= \epsilon \enspace,\\
 \semi{x}=& \{\tuple{i,\p x_x}\} \text{ where $[i]\varphi$ is the type
 of $x$}\enspace,\\
 \sem{\hypert\hmid \gpair{M,N}}=&
 \sem{\hypert\hmid M}; \sem{\hypert\hmid N}\enspace,\\
 \semi{\hypert\hmid \gpair{M,N}} =&
 \semi{\hypert\hmid M}\cup \semi{\hypert\hmid N}\enspace,\\
 \sem{\hypert\hmid \pi_a^\g(M)}=&\sem{\hypert\hmid M}\enspace,\\
 \semi{\hypert\hmid\pi_a^\g(M)}=&\semi{\hypert\hmid M}\enspace,\\
  \sem{\cotuple{\cotuple{\hypert_0,\hypert_1},\hypert_2}\hmid
   \gmat  M x {N_0} y {N_1}}
 =&\sem{\hypert_0\hmid M}; \\
  \p{x}_x \leftarrow \lmat {\semi{\hypert_0\hmid \hat M}'} {x} {x} {y} {\epsilon}; &\sem{\hypert_1 \hmid N_0}; \\
  \p{x}_y \leftarrow \lmat {\semi{\hypert_0\hmid \hat M}'} {x} {\epsilon} {y} {y}; &\sem{\hypert_2 \hmid N_1}\enspace,\\
  \semi{\cotuple{\cotuple{\hypert_0,\hypert_1},\hypert_2}\hmid \gmat  M x {N_0} y {N_1}}
 =&\semi{\hypert_1 \hmid N_0}\cup \semi{\hypert_2 \hmid N_1}\enspace,\\
 \sem{\hypert\hmid \lambda x.M}=& \sem{\hypert\hmid M}; \p z\leftarrow
 \lambda x. \semi{\hypert\hmid\hat M}' \enspace,\\
 \sem{\cotuple{\hypert_0,\hypert_1}\hmid MN}=& \sem{\hypert_0\hmid M}; \sem{\hypert_1\hmid N}; \\&
 \p z\leftarrow \semi{\hypert_0\hmid \hat M}'\semi{\hypert_1\hmid \hat N}'\enspace,\\
 \semi{\cotuple{\hypert_0,\hypert_1}\hmid MN} =& (\semi{\hat \hypert_0 \hmid M}\cup
 \semi{\hat\hypert_1\hmid N})\hmid \{\tuple{i,\p z}\}\enspace, \\
 \sem{\hypert\hmid \lpil M} =& \sem{\hypert\hmid M}; \p z \leftarrow
 \semi{\hypert\hmid\hat M}'\enspace, \\
 \semi{\hypert\hmid \lpil M}=& \semi{\hat \hypert\hmid M}\hmid
 \{\tuple{i, \p z}\}\enspace.
\end{align*} }
We omitted translations of some constructs $\pi_{\mathrm r}$, $\mathsf{inl}$,
$\mathsf{inr}$, but they are defined in the same way
as $\pi_{\mathrm
l}$ case.
When $(\tj{x_i}{[i]\iota_i})_{i\in\processes}
\tr\tj{M}(\wwedge_{i\in \processes}[i]o_i)$ is
derivable,
we can define a protocol using the above translation.
We set $\mathtt i_i$ to be ${\p x}_{x_i}$, ${\p o}_i$ to be arbitrarily
chosen fresh program variables, $L$ to be the set of locations
occurring in the derivation, we set the family of programs to be
$\sem{M}; ({\p o}_i\leftarrow \pi_i(\semi{\hat M}'))_{i\in\processes}$,
where $\pi_i$ is obtained by composing $i$~times $\pi_{\mathrm r}$ to
$\pi_{\mathrm l}$.
We set $g,d,t_i$ accordingly so that the program is typed.
We can simulate a reduction sequence of
the hyperterm using a fair execution of the protocol.


And, since the protocol solves a problem for any fair schedule, it 
solves the problem waitfreely.
If we deny the claim, there must be an execution where a nonfaulty
process
either (a)~gives a
wrong answer or
 (b)~never gives an answer.
 Either case, there is a step~$k$ when
 such a failure is inevitable.
We can modify the schedule after step $k$ to a fair one,
keeeping the failing behavior of
the process.

\begin{theorem}[Completeness]
If there exists a typed protocol that solves a typed input-output
 problem, 
the problem is solvable by a term.
\end{theorem}

Saks and Zaharoglou~\cite{Saks:1993vq} showed that a finite repetition of the participating set
problem universally solves any waitfreely solvable problem.
Also, $n$-party participating problem can be solved by a tournament of
the two-party participating set problem.
It suffices to show a \lgd\, term solving the two-party problem.


In the \textit{participating set problem}~\cite{borowsky},
each process~$i$ receives an id $c_i$ and
returns a set of id's $S_i$.
The outputs must satisfy (i)~$i\in S_i$; (ii)~either $S_i\subseteq S_j$
or $S_j\subseteq S_i$; and (iii)~$S_i\subseteq S_j$  if $i\in S_j$ for any
$i,j\in\processes$.
For two processes,
$\tuple{S_0, S_1}$ can be $\tuple{\{c_0\}, \{c_0, c_1\}}$, $\tuple{\{c_0, c_1\}, \{c_1\}}$
or
$\tuple{\{c_0, c_1\}, \{c_0, c_1\}}$.

We are going to encode the participating set problem in \lgd.
For this, we introduce a base type called $\Id$ for process id's.
Let there be an injection that maps a natural number~$i$ to a constant
$C_i\colon\Id$.
The additional typing rules involving $\Id$ are as follows, where $2 = (\bot\supset\bot)\vee(\bot\supset\bot)$:
\begin{center}
 \UnaryRule{}{}
 {$\tr \tj{c_n}{[i]\Id}$}
 \hfill
 \BinaryRule
 {$\Gamma\tr \tj{M_0}[i]\Id$}
 {$\Gamma\tr \tj{M_1}[i]\Id$}
 {}
 {$\Gamma \tr \tj{\compare{M_0}{M_1}}{[i]2}$}\enspace.
\end{center}
The additional reduction is
\[
 c_m == c_n \reduce 
\begin{cases}
 \linl{\lambda x.x}& (\text{if } m = n)\\
 \linr{\lambda x.x}& (\text{otherwise})\enspace.
\end{cases}
\]
Also, 
${\ifte M {N_0} {N_1}}$
is an abbreviation for
${\lmat M x {N_0} y {N_1}}$.

We represent a finite set of id's as a
typed lambda term, whose type is $[i](\Id\supset 2)$.  Intuitively, a
set takes an id and decides whether it is \textit{in} or \textit{out}.
The emptyset is represented by a term $\lambda x. \linr {\bullet}$.  
When a finite set~$S$ is represented by a term~$M$,
the set $S \cup \{c\}$ is represented by a term
$\lambda x.\left(\ifte{x==c}{\linl {\bullet}}{Mx}\right)$.
With the above construction, we define abbreviations
like $\{c_0, c_1, c_2\}$.

Now, we are ready to construct a hyperterm solving the two-party
participating set problem.
We can  obtain a derivation of:
\begin{center}
 \small
$
 \tj{x}{[0]\Id},
 \tj{y}{[1]\Id}
 \tr
 \tj{\cotuple{\gpair{\{\ltor 0 l \epsilon x, x\}, \{y\}},
 \gpair{\{x\}, \{\rtol 1 l\epsilon y, y\}}
 }}
 {[0](\Id\supset 2)\wedge ([1](\Id\supset 2))}\enspace.$
\end{center}

One possible reduction sequence is as follows:
\begin{align*}
 & \conf{[]}{[]}
 {\cotuple{\gpair{\{\ltor 0 l \epsilon {c_0}, {c_0}\}, \{{c_1}\}},
 \gpair {\{{c_0}\}, \{\rtol 1 l\epsilon {c_1}, {c_1}\}}}} \\
 \reduction &
 \conf{[l\mapsto {c_0}]}{[]}
 {
 \cotuple{
 \gpair{\{\abort, {c_0}\}, \{{c_1}\}},
 \gpair{\{{c_0}\}, \{\rtol 1 l\epsilon {c_1}, {c_1}\}}
 }
 }
 \\
 \reduction &
 \concreteconf{[l\mapsto {c_0}]}{[l\mapsto {c_1}]}{\gpair{\{{c_0}\}, \{c_0, c_1\}}}\enspace.
\end{align*}
Moreover, the same initial configuration can reduce to
\begin{equation*}
 \concreteconf{[l\mapsto c_0]}{[l\mapsto c_1]}{\gpair{\{c_1,c_0\},
 \{c_1\}}}\text{ or }
 \concreteconf{[l\mapsto c_0]}{[l\mapsto c_1]}{\gpair{\{c_1,c_0\},
 \{c_0, c_1\}}}\enspace. 
\end{equation*}
There are no other normal forms.
These three normal forms correspond to the three answers for the
two-party participating set problem.

\section{Related Work}
\label{related}
Avron~\cite{avron91} formulates a
hypersequent calculus for G\"odel--Dummett logic and proves
cut-elimination theorem using a method
similar to Gentzen~\cite{gentzen}.
Also, he explains the intuition behind the communication rule as
``the inputs through the ports in $\Gamma_2'$ are transmitted to the
component with output of type $A_1.$  The inputs through $\Gamma_1'$ are
treated similarly.''  He did not mention the possibility of
any transmission failures, which we exploited
in order to characterize waitfreedom.
Ciabattoni, Galatos and Terui~\cite{alg} gives a class of logics
that have
hypersequent calculi with
cut-elimination.
Their cut-elimination proof is general but it does not
obviously reveal the computational content.

Baaz, Ciabattoni and Ferm\"uller~\cite{natural} propose a 
hypersequent-style natural deduction for G\"odel--Dummett logic, but
did not define reduction.
Ferm\"uller~\cite{parallel} gives a game semantics for G\"odel--Dummett
logic, which is based on Lorenzen game~\cite{curryhoward} and essentially
proof searching bottom-to-up.

Among numerous typed programming languages with parallelism,
to our knowledge, none exhibits
the connection of G\"odel--Dummett logic and waitfreedom.
Abramsky~\cite{abramsky1993computational}'s calculus $\mathsf{PE}_2$
for classical linear logic is
deterministic
\cite[Theorem~7.9]{abramsky1993computational} so that it is
impossible to model
waitfreedom using $\mathsf{PE}_2$.
The $\pi$-calculus~\cite{milner1999communicating}, 
Join calculus~\cite{join},
and even asynchronous
$\pi$-calculus \cite{hondatokoro}
have too strong synchronization abilities to model waitfreedom because
a process can wait for an input.

Hirai~\cite{hirailpar} compares the temporal order of waitfree
computation and the Kripke models of a modal logic similar to
G\"odel--Dummett logic.  The current
work witnesses the constructive content of
his model theoretic comparison.

\section{Future Work}
\label{future}

As a programming language, \lgd\, allows efficient execution because it
requires no synchronization among processes.
We implemented a calculus similar to \lgd\, in a programming language
Haskell%
\footnote{Given Haskell Platform, a command \texttt{cabal
waitfree} installs the implementation.}.
A possible extension is adding synchronization primitives.
It would be interesting to compare different synchronization primitives
and different intermediate logics, generalizing waitfreedom and
G\"odel--Dummett logic.

We are also planning to develop a waitfree protocol verification mechanism in Coq
because it is valuable to
remove unnecessary synchronization while keeping the program correct
in high performance computing.

An anonymous refree pointed out that the introduction of
modalities is interesting on its own.
We have not investigated the semantics of these modalities.

In \lgd, the source of nondeterminism can be explicitly expressed as the
store prophecy.
If we can find a semantic counterpart $\mathsf{Sch}$ of the store
prophecy, possibly, we
can obtain a denotation $\mathcal{D}^\mathsf{Sch}$ of terms
using a denotation $\mathcal{D}$ for normal forms.
If that succeeds for classical logic, it will be interesting%
\footnote{Kazushige Terui suggested the potential impact for classical logic.}%
.

\section{Conclusion}
\label{conc}
We proposed \lgd, a lambda calculus
based on hypersequent calculus of 
G\"odel--Dummett logic.
We proved normalization and non-abortfullness.
The calculus characterizes
the typed version of waitfree computation.
Our result 
hints broader correspondence between
proof theory and distributed computation.


\paragraph{Acknowledgement.}

\appendix

\bibliographystyle{plain}
\bibliography{hirai-thesis}
     

\end{document}
