\chapter{The Logic of Information Exchange}
\label{ch:exchange}

\subsection{Summary}

After studying $(\phi\limp\psi)\oplus (\psi\limp\phi)$,
it is natural to change the additive disjunction $\oplus$ into
multiplicative conjunction $\otimes$ and see what happens%
\footnote{Takeuti Izumi asked what about conjunctions.}.
A natural way to add $(\phi\limp\psi)\otimes(\psi\limp\phi)$ as an axiom
is adding a pair of primitives $c,\co c$ so that
$\cdots ct \cdots \co c u \cdots$ reduces to
$\cdots u  \cdots t \cdots$: in words,
$c$ outputs $\co c$'s input and vice versa.
We can obtain the send-receive communication when we specialize the
axiom as $(\phi\limp \one)\otimes(\one\limp\phi)$.  The left hand side
$\tj{c}{\phi\limp\one}$ is the sending primitive and
the right hand side $\tj{\co c}{\one \limp\phi}$ is the receiving
primitive.

When we want to use these primitives anywhere in lambda terms,
there is one problem: what happens to $\co c(c t)$?
In this case, we do not know the output of $c$ because we only have an
equality between $\co c$'s input and $c$'s output.
Fortunately, we just want to know the output of $\co c$, which is the
input of $c$, that is, $t$.
In a more complicated case $\co c(\co d(c (d t)))$,
we can reason the output of $\co c$ as the input of $c$ as the output of
$d$ as the input of $\co d$ as the output of $c$ as the input of $\co c$
as the output of $\co d$ as the input of $d$, which is $t$.

We have more questions.
\begin{itemize}
 \item How does it generalize over more channels?
 \item Due to addition of the axiom, is it the case that
       every type is inhabited?  In other words,
      is the resulting type system consistent?
 \item Can we implement process calculi using the aforementioned primitives?
\end{itemize}
\fix{how does it generalize?}

\section{Definitions}

\subsection{Types}
For a set $S$, we define $\phi\in\form(S)$ by BNF:
\[
 \phi::=s\mid \one \mid X \mid \phi\otimes\phi\mid \phi\limp\phi\mid
 \phi\oplus\phi\mid \phi\with\phi\mid \bang\phi\mid \forall X.\phi
\]
where $s$ is an element of $S$ and $X$ is a propositional variable.
The propositional variable in the last clause is binding.
A \textit{type}\index{type} is an element of $\form(\emptyset)$.

\subsection{Terms and Free Variables}

Following Abramsky's linear lambda calculus
LF~\citep{abramsky1993computational}, we first defne patterns
binding sets of variables:
\begin{itemize}
 \item $\ast$ and $\_$ are patterns binding $\emptyset$,
 \item $\lpair{x,\_}$, $\lpair{\_,x}$ and $\bang x$ are patterns binding
       $\{x\}$,
 \item $x\otimes y$ and $x@y$ are patterns binding $\{x,y\}$.
\end{itemize}
Using patterns, we define a term $t$ with free variables~$S$.
We assume countably infinitely many \textit{channels}\index{channel}
with involution
satisfying $\co c\neq c$ and $\co{\co c} = c$.
\fix{not good, follow Abramsky}
\begin{itemize}
 \item a variable $x$ is a term with free variables $\{x\}$,
 \item if $t$ is a term with free variables~$S$, $u$ is a term with
       free variables~$S'$ and $S$ and $S'$ are disjoint, $t\otimes u$ and
       $tu$ are terms with free variables $S\cup S'$,
 \item if $t$ and $u$ are terms with free variables $S$, then
       $\lpair{t,u}$ is a term with free variables~$S$,
 \item if $t$ is a term with free variables~$S$, then
       $\inl x, \inr t$ and $\bang t$ are terms with free variables~$S$
 \item if $t$ is a term with free variables $S\cup \{x\}$ and $x$ is not
       in $S$, then $\lambda x.t$ is a term with free variables~$S$,
 \item if $t$ is a term with free variables~$S$, $p$ is a pattern
       binding $S'$, $u$ is a term with free variables $S'\cup S''$ and
       $S\cap S'' = S'\cap S'' = \emptyset$, then,
       $\letin t p u$ is a term with free variables $S\cup S''$,
 \item if $t$ is a term with free variables $S$,
       $u$ is a term with free variables $S''\cup \{x\}$,
       $v$ is a term with free variables $S''\cup \{y\}$,
       $x,y\notin S''$ and $S\cap S'' = \emptyset$,
       $\mat t x u y v$ is a term with free variables $S\cup S''$, and
 \item channels are terms with free variables~$\emptyset$.
\end{itemize}
Note that a term with free variables $S$ is not a term with free
variables $S'$ when $S\neq S'$.  Only the last clause is original,
introducing channels, which are our communication primitives.
We introduce an abbreviation
\begin{align*}
 \ign \epsilon t   & \equiv t\\
 \ign {x,\vec y} t & \equiv \letin x \ast {\ign {\vec y} t}
\end{align*}
inductively for a sequence of variables $\vec y$.
$\epsilon$ stands for the empty sequence.
The symbol $\mathsf{ign}$ is intended to be pronounced ``ignore''.

\subsection{Typing Derivations}

On top of Abramsky's~\citep{abramsky1993computational} we add a rule to
make $(\phi\limp\psi)\otimes(\psi\limp\phi)$ derivable.
A \textit{context}\index{context}~$\G$ is a possibly empty sequence of
variables associated with
types where the same variable appears at most once.
\fix{give an example}
A \textit{hypersequent}\index{hypersequent} is inductively defined as
\begin{align*}
 \hypert ::=\, &\G\tr\tj{t}{\phi}
 \mid\, (\hypert\hmid \hypert)
\end{align*}
where $\G$ is a context.

The \textit{type}\index{type!--- of a hypersequent} of a hypersequent is
defined inductively.
\begin{align*}
 \type{(\G\tr\tj{t}\phi)}&= \G\tr\phi \\
 \type{(\hypert \hmid \hypert')}&= \type(\hypert)\hmid\type{(\hypert')}
\end{align*}
The last clause is not natural because we ignore the type of $\hypert'$.
Actually, later, we will only allow the construction
$\lpair{\hypert,\hypert'}^n$ for hypersequents satisfying
$\type(\hypert) = \type(\hypert')$.

\fix{definition of terms contains natural number?}
Differently from the previous chapters,
here, the hypersequent $\G\tr\phi\hmid \D\tr\psi$ is interpreted as the
conjunction of components:
$(\bigotimes\G\limp\phi)\otimes (\bigotimes\D\limp\psi)$.

The typing rules are in Figure~\ref{fig:exchange:rules}.
 \begin{figure}
  \centering
  % axiom
  \AxiomC{}
  \LL{Ax}
  \UnaryInfC{$\tj{x}{\phi}\tr\tj{x}{\phi}$}
  \DisplayProof
  %
  \hfill
  \AxiomC{$\hypert$}
  \AxiomC{$\hypert'$}
  \LL{merge}
  \BinaryInfC{$\hypert\hmid\hypert'$}
  \DisplayProof
  % cut XXX is this necessary?; yes
  \hfill
  \AxiomC{$\hypert\hmid\G\tr\tj{t}{\phi}\hmid\tj{x}{\phi},\D\tr\tj{u}{\psi}$}
  \LL{Cut}
  \UnaryInfC{$\hypert\hmid\G,\D\tr\tj{u[t/x]}{\psi}$}
  \DisplayProof
  \ruleskip
  % exchange
  \AxiomC{$\hypert\hmid\G,\tj{x}{\phi},\tj{y}{\psi},\D\tr\tj{t}{\theta}$}
  \LL{IE}
  \UnaryInfC{$\hypert\hmid\G,\tj{y}{\psi},\tj{x}{\phi},\D\tr\tj{t}{\theta}$}
  \DisplayProof
  %
  \hfill
  \AxiomC{$\hypert\hmid \G \tr\tj t\phi \hmid \D \tr\tj u\psi\hmid \hypert'$}
  \LL{EE}
  \UnaryInfC{$\hypert\hmid \D \tr\tj u\psi \hmid \G \tr\tj t\phi \hmid \hypert'$}
  \DisplayProof
  \ruleskip
  %
  \ruleskip
  % 1R
  \AxiomC{}
  \LL{$\one$R}
  \UnaryInfC{$\tr\tj{\ast}{\one}$}
  \DisplayProof
  %
  \hfill
  % 1L
  \AxiomC{$\hypert\hmid\G\tr\tj{t}{\phi}$}
  \LL{$\one$L}
  \UnaryInfC{$\hypert\hmid\G,\tj{z}{\one}\tr\tj{\ign z t}{\phi}$}
  \DisplayProof
  %
  \hfill
  % otimes R
  \AxiomC{$\hypert\hmid\G\tr\tj{t}{\phi}\hmid\D\tr\tj{u}{\psi}$}
  \LL{$\otimes$R}
  \UnaryInfC{$\hypert\hmid\G,\D\tr\tj{t\otimes u}{\phi\otimes \psi}$}
  \DisplayProof
  %
  \ruleskip
  % sync
  \AxiomC{$\hypert\hmid\G\tr\tj{t}{\phi}\hmid \D\tr\tj{u}{\psi}$}
  \LL{sync}
  \UnaryInfC{$\hypert\hmid
  \G\tr\tj{ct}{\psi}\hmid \D\tr\tj{\co cu}{\phi}$}
  \DisplayProof
  %
  \hfill
  % otimes L
  \AxiomC{$\hypert\hmid\G,\tj{x}{\phi},\tj{y}{\psi}\tr\tj{t}{\theta}$}
  \LL{$\otimes$L}
  \UnaryInfC{$\hypert\hmid\G,\tj{z}{\phi\otimes\psi}\tr\tj{\letin{z}{x\otimes
  y}{t}}{\theta}$}
  \DisplayProof
  %
  \ruleskip
  % limp R
  \AxiomC{$\hypert\hmid\G,\tj{x}{\phi}\tr\tj{t}{\psi}$}
  \LL{$\limp$R}
  \UnaryInfC{$\hypert\hmid\G\tr\tj{\lambda x.t}{\phi\limp \psi}$}
  \DisplayProof
  %
  \hfill
  % limp L
  \AxiomC{$\hypert\hmid\G\tr\tj{t}{\phi}\hmid\tj{x}{\psi},\D\tr\tj{u}{\theta}$}
  \LL{$\limp$L}
  \UnaryInfC{$\hypert\hmid\G,\tj{f}{\phi\limp\psi},\D\tr \tj{u[(ft)/x]}{\theta}$}
  \DisplayProof
  %
  \ruleskip
  % andR
  \AxiomC{$\G\tr\tj{t}{\phi}$}
  \AxiomC{$\G\tr\tj{u}{\psi}$}
  \LL{$\with$R}
  \BinaryInfC{$\G\tr\tj{\lpair{t,u}_n}{\phi\with\psi}$}
  \DisplayProof \\
  %
  \ruleskip
  % andL0
  \AxiomC{$\hypert\hmid\G,\tj{x}{\phi}\tr\tj{t}{\theta}$}
  \LL{$\with$L$_0$}
  \UnaryInfC{$\hypert\hmid\G,\tj{z}{\phi\with\psi}\tr\tj{\letin{z}{\lpair{x,\_}}{t}}{\theta}$}
  \DisplayProof
  %
  \ruleskip
  % andL1
  \AxiomC{$\hypert\hmid\G,\tj{y}{\psi}\tr\tj{t}{\theta}$}
  \LL{$\with$L$_1$}
  \UnaryInfC{$\hypert\hmid\G,\tj{z}{\phi\with\psi}\tr\tj{\letin{z}{\lpair{\_,y}}{t}}{\theta}$}
  \DisplayProof
  %
  \ruleskip
  % oplus R0
  \AxiomC{$\hypert\hmid\G\tr\tj{t}{\phi}$}
  \LL{$\oplus$R$_0$}
  \UnaryInfC{$\hypert\hmid\G\tr\tj{\inl{t}}{\phi\oplus\psi}$}
  \DisplayProof
  %
  \hfill
  % oplus R1
  \AxiomC{$\hypert\hmid\G\tr\tj{u}{\psi}$}
  \LL{$\oplus$R$_1$}
  \UnaryInfC{$\hypert\hmid\G\tr\tj{\inr{u}}{\phi\oplus\psi}$}
  \DisplayProof
  %
  \ruleskip
  % oplus L
  \AxiomC{$\hypert \hmid \G,\tj{x}{\phi}\tr\tj{u}{\theta}\hmid
  \G,\tj{y}{\psi}\tr\tj{v}{\theta}$}
  \LL{$\oplus$L}
  \UnaryInfC{$\hypert\hmid\G,\tj{z}{\phi\oplus\psi}\tr\tj{\mat{z}{x}{u}{y}{v}}{\theta}$}
  \DisplayProof
  %
  \ruleskip
  % !R
  \AxiomC{$\bang\hypert\hmid\bang\G\tr\tj{t}{\phi}$}
  \LL{$\bang$R}
  \UnaryInfC{$\bang\hypert\hmid\bang\G\tr\tj{\bang t}{\bang \phi}$}
  \DisplayProof
  where $\bang\hypert$ contains only components typed $\bang\D\tr \bang\psi$.
  %
  \ruleskip
  % dereliction
  \AxiomC{$\hypert\hmid\G,\tj{x}{\phi}\tr\tj{t}{\psi}$}
  \LL{Dereliction}
  \UnaryInfC{$\hypert\hmid\G,\tj{z}{\bang\phi}\tr\tj{\letin{z}{\bang x}{t}}{\psi}$}
  \DisplayProof
  %
  \ruleskip
  % contraction
  \AxiomC{$\hypert\hmid\G,\tj{x}{\bang\phi},\tj{y}{\bang\phi}\tr\tj{t}{\psi}$}
  \LL{Contraction}
  \UnaryInfC{$\hypert\hmid\G,\tj{z}{\bang\phi}\tr\tj{\letin{z}{x@y}{t}}{\psi}$}
  \DisplayProof
  %
  \ruleskip
  % weakening
  \AxiomC{$\hypert\hmid\G\tr\tj{t}{\psi}$}
  \LL{Weakening}
  \UnaryInfC{$\hypert\hmid\G,\tj{z}{\bang\phi}\tr\tj{\letin{z}{\_}{t}}{\psi}$}
  \DisplayProof
  %
  \ruleskip
  % forall R
  \AxiomC{$\hypert\hmid\G\tr\tj{t}{\phi}$}
  \LL{$\forall$R}
  \UnaryInfC{$\hypert\hmid\G\tr\tj{t}{\forall X.\phi}$}
  \DisplayProof (No free $X$ appears in $\G$ or $\hypert$)
  %
  \hfill
  % forall L
  \AxiomC{$\hypert\hmid\G,\tj{x}{\phi[\psi/X]}\tr\tj{t}{\phi}$}
  \LL{$\forall$L}
  \UnaryInfC{$\hypert\hmid\G,\tj{x}{\forall X.\phi}\tr\tj{t}{\phi}$}
  \DisplayProof
  %
  \ruleskip
  %
  \caption{Most rules are taken from Abramsky~\citep{abramsky1993computational}.
  The sync rule is original.}
  \label{fig:exchange:rules}
 \end{figure}
For example,
the formula $(\phi\limp\psi)\otimes(\psi\limp\phi)$ is realized by
the following derivation.
 \begin{center}
  \AxiomC{}
  \UnaryInfC{$\tj{x}{\phi}\tr\tj{x}{\phi}$}
  \AxiomC{}
  \UnaryInfC{$\tj{y}{\psi}\tr\tj{y}{\psi}$}
  \BinaryInfC{$\tj{x}{\phi}\tr\tj{x}{\phi} \hmid
  \tj{y}{\psi}\tr\tj{y}{\psi}$}
  \UnaryInfC{$ \tj{x}{\phi}\tr\tj{cx}{\psi} \hmid \tj{y}{\psi}
  \tr\tj{\co c y}{\phi}$}
  \UnaryInfC{$ \tr\tj{\lambda x.cx}{\phi\limp\psi} \hmid \tj{y}{\psi}
  \tr\tj{\co c y}{\phi}$}
  \UnaryInfC{$ \tr\tj{\lambda x.cx}{\phi\limp\psi} \hmid
  \tr\tj{\lambda y.\co c y}{\phi\limp\phi}$}
  \UnaryInfC{$ \tr\tj{{(\lambda x.cx) \otimes (\lambda y.\co c
  y)}}{(\phi\limp\psi)\otimes(\phi\limp\phi)}$}
  \DisplayProof
 \end{center}
Another example shows how we can type the term $\co c(c x)$.
 \begin{center}
\AxiomC{$\tj{x}{\phi}\tr\tj{x}{\phi}$}
\AxiomC{$\tj{y}{\psi}\tr\tj{y}{\psi}$}
\BinaryInfC{$\tj{x}{\phi}\tr\tj{x}{\phi} \hmid
\tj{y}{\psi}\tr\tj{y}{\psi} $}
\UnaryInfC{
$\tj{x}{\phi}\tr\tj{cx}{\psi} \hmid
\tj{y}{\psi}\tr\tj{\co cy}{\phi} $
}
\LL{(Cut)}
\UnaryInfC{
$\tj{x}{\phi}\tr\tj{\co c(cx)}{\phi}$
}
\DisplayProof
 \end{center}

\subsection{Evaluation Relation}

The set of canonical forms remains the same as Abramsky's
system~\citep{abramsky1993computational}:
\[
 \lpair{t,u}\qquad \bang t\qquad \ast\qquad v\otimes w\qquad \lambda
 x.t\qquad \inl{v}\qquad\inr{w}
\]
where $v$ and $w$ are canonical forms.

An evaluation hypersequent $\hypere$ is defined by the following
grammar:
\[
 \hypere ::= t\eval t\mid (\hypere\hmid \hypere)
\]

Now we define evaluation as a set of evaluation hypersequents
(Figure~\ref{fig:eval}).
Most rules are the same as Abramsky's~\citep{abramsky1993computational}.
We add the semantics for channels.
 \begin{figure}
  \centering
  % ast
  \AxiomC{}
  \UnaryInfC{$\ast\eval\ast$}
  \DisplayProof
  \hfill
  % ast elim
  \AxiomC{$\hypere\hmid t\eval \ast \hmid u\eval v$}
  \UnaryInfC{$\hypere\hmid u\eval v$}
  \DisplayProof
  \hfill
  % otimes
  \AxiomC{$\hypere\hmid t\eval v\hmid u\eval w$}
  \UnaryInfC{$\hypere\hmid t\otimes u\eval v\otimes w$}
  \DisplayProof
  \ruleskip
  % otimes elim
  \AxiomC{$\hypere\hmid t\eval v\otimes w\hmid u[v/x,w/y]\eval v'$}
  \UnaryInfC{$\hypere\hmid \letin t {x\otimes y} u \eval v'$}
  \DisplayProof
  \hfill
  \AxiomC{$\hypere$}
  \AxiomC{$\hypere'$}
  \BinaryInfC{$\hypere\hmid \hypere'$}
  \DisplayProof
  \hfill
  \AxiomC{}
  \UnaryInfC{$\lambda x.t\eval \lambda x.t$}
  \DisplayProof
  \ruleskip
  \AxiomC{$\hypere\hmid t\eval \lambda x.t'\hmid u\eval v\hmid
  t'[v/x]\eval w$}
  \UnaryInfC{$\hypere\hmid tu\eval w$}
  \DisplayProof
  \hfill
  \AxiomC{$\hypere\hmid t\eval v\hmid u\eval w$}
  \UnaryInfC{$\hypere\hmid ct\eval w\hmid \co cu\eval v$}
  \DisplayProof
  \ruleskip
  \AxiomC{}
  \UnaryInfC{$
  \lpair{t, u}_n\eval
  \lpair{t, u}_n$}
  \DisplayProof
  \ruleskip
  \AxiomC{$\hypere\hmid
  t\eval\lpair{t_0,t_1}_n\hmid t_0\eval v_0
  \hmid  u[v_0/x]\eval w$}
  \UnaryInfC{$\hypere \hmid
  \letin t {\lpair{x,\_}} u\eval w$}
  \DisplayProof
  \ruleskip
  \AxiomC{$\hypere
  \hmid t\eval\lpair{t_0,t_1}_n\hmid t_1\eval v_1
  \hmid  u[v_1/y]\eval w$}
  \UnaryInfC{$\hypere \hmid
  \letin t {\lpair{\_,y}} u\eval w$}
  \DisplayProof
  \ruleskip
  \AxiomC{$\hypere\hmid t\eval v$}
  \UnaryInfC{$\hypere\hmid \inl{t}\eval \inl{v}$}
  \DisplayProof
  \hfill
  \AxiomC{$\hypere\hmid u\eval w$}
  \UnaryInfC{$\hypere \hmid \inr{u}\eval \inr{w}$}
  \DisplayProof
  \ruleskip
  \AxiomC{$\hypere\hmid t\eval \inl{v}\hmid u[v/x]\eval w$}
  \UnaryInfC{$\hypere\hmid \mat t x u y {u'}\eval w$}
  \DisplayProof
  \ruleskip
  \AxiomC{$\hypere\hmid t\eval \inr{v}\hmid u'[v/y]\eval w$}
  \UnaryInfC{$\hypere\hmid \mat t x u y {u'}\eval w$}
  \DisplayProof
  \ruleskip
  \AxiomC{}
  \UnaryInfC{$\bang t\eval \bang t$}
  \DisplayProof
  \hfill
  \AxiomC{$\hypere\hmid t\eval \bang s\hmid s\eval v\hmid u[v/x]\eval w$}
  \UnaryInfC{$\hypere \hmid \letin t {\bang x} u\eval w$}
  \DisplayProof
  \ruleskip
  \AxiomC{$\hypere\hmid t\eval \bang s\hmid u\eval v$}
  \UnaryInfC{$\hypere \hmid \letin t {\_} u\eval v$}
  \DisplayProof
  \hfill
  \AxiomC{$\hypere\hmid t\eval\bang s\hmid u[\bang s/x,\bang s/y]\eval v$}
  \UnaryInfC{$\letin t {x@y} u\eval v$}
  \DisplayProof
  \ruleskip
  \AxiomC{$\hypere\hmid t\eval v\hmid u[v/x]\eval w$}
  \LL{eval-subst}
  \UnaryInfC{$ \hypere\hmid u[t/x] \eval w $}
  \DisplayProof
  \ruleskip
  % let expansion
  % \AxiomC
  % {$\hypere\hmid t[\letin u p {(u_0 \otimes u_1)}/x] \eval w$}
  % \UnaryInfC
  % {$\hypere\hmid t[(\letin u p {u_0})\otimes u_1/x] \eval w$}
  % \DisplayProof \\
  % if $u_1$ does not have free variables bound by $p$.
  % \ruleskip
  % \AxiomC
  % {$\hypere\hmid t[\letin u p {(u_0 \otimes u_1)}/x] \eval w$}
  % \UnaryInfC
  % {$\hypere\hmid t[u_0\otimes (\letin u p {u_1})/x] \eval w$}
  % \DisplayProof \\
  % if $u_0$ does not have free variables bound by $p$.
  \caption{The definition of evaluation relation.  $\with$R only
  applicable to singleton hypersequents.}
  \label{fig:eval}
 \end{figure}


\section{Convergence}

Convergence states that if
$\tr\tj t \phi$ is derivable,
there exists a canonical form~$v$ so that $t\eval v$ is derivable.
Since the proof of convergence is inductive over
the typing derivations, we have to generalize the statement.

For that we first assign a set of closed terms to each type.
\newcommand{\terms}{\mathcal{T}}
\fix{use of $v$ is ambiguious...?}
We denote by $\terms$ the set of closed terms.
Given $\sem{X}_0\in 2^\terms$ for each propositional variable~$X$,
we define $\sem{\cdot}\colon \form{2^\terms}\rightarrow \form{2^\terms}$
as follows:
\begin{align*}
 \sem{\mathcal X} &= \mathcal X\\
 \sem{X} &= \sem{X}_0\\
 \sem{\one} &= \{t\in \terms \mid t\eval \ast\} \\
 \sem{\phi\otimes \psi}&= \{t\in\terms \mid t\eval v\otimes w,\quad
 v\in\sem{\phi},\quad w\in \sem{\psi}\}\\
 \sem{\phi\limp\psi}&= \{t\in\terms \mid t\eval \lambda x.v,\quad
 \forall u\in\sem{\phi}.(tu\in\sem{\psi})\}\\
 \sem{\phi\with\psi}&= \{t\in\terms \mid t\eval\lpair{v,w},\quad
 v\in\sem{\phi}, w\in\sem{\psi}\}\\
 \sem{\phi\oplus\psi}&= \{t\in\terms\mid (t\eval \inl{v}, v\in
 \sem{\phi})\text{ or }(t\eval\inr{w}, w \in \sem{\psi})\}\\
 \sem{\bang \phi}&= \{t\in\terms \mid t\eval \bang u, \quad u\in\sem{\phi}\}\\
 \sem{\forall X.\phi}&= \bigcap\{\sem{\phi[\mathcal X/X]}\mid \psi\in
 2^\terms\}\enspace.
\end{align*}

For a context~$\G = \tj{x_0}{\phi_0},\ldots,\tj{x_n}{\phi_n}$,
$\semo{\G}$ denotes the set of sequences $u_0,\ldots,u_n$ of closed terms
such that each $u_i$ is in $\sem{\phi_i}$.
\fix{define semoi hyperterm}

 \begin{proposition}[General Convergence]
  \label{thm:generalconvergence}
  If
  $\G_0\tr\tj{t_0}{\phi_0}\hmid\cdots\hmid \G_n\tr\tj{t_n}{\phi_0}$
  is derivable,
  for any $(\vec{u^i}) \in \semo{\G_i}$ for ${0\le i \le n}$,
  there exist canonical forms $(v_i\in\semo{\phi_i})_{0\le i\le n}$ so
  that $t_0[\vec{u^0}/ \G_0]\eval v_0\hmid\cdots\hmid
  t_n[\vec{u^n}/\G_n]\eval v_n$ is derivable.
 \end{proposition}
  \begin{proof}
   By induction on the type derivation.
   \begin{description}
    \item[($\limp$L)] The derivation ends as
	  \begin{center}
	   \AxiomC{$\hypert\hmid \G\tr\tj{t}{\phi}\hmid \tj{x}{\psi},
	   \D\tr\tj{u}{\theta}$}
	   \UnaryInfC{$\hypert\hmid
	   \G,\tj{f}{\phi\limp\psi},\D\tr\tj{u[(ft)/x]}{\theta}$}
	   \DisplayProof\enspace.
	  \end{center}
	 Take any $O\in\semo{\hypert}$, $\vec g\in\semo{\G}$, $\vec
	 d\in\semo{\D}$ and $v\in\semo{\phi\limp\psi}$.
	 By induction hypothesis,
	 \[
	  \hypert\eval \vec{w'}\hmid t[\vec g/\G]\eval
	   w_0\hmid u[w/x][\vec d/\D]\eval w
	 \]
	 is derivable for any $w \in \semo{\psi}$.
	 Since $w_0$ is in $\semo{\phi}$ and $v$ is in
	 $\semo{\phi\limp\psi}$,
	 $fw_0$ is in $\psi$.
	 Thus,
	 \[
	 \hypert\eval\vec{w'}\hmid t[\vec g/\G]\eval w_0\hmid
	 u[(fw_0)/x][\vec d/\D]\eval w_1
	 \]
	 is derivable.
	 The last term $u[(fw_0)/x][\vec d/\D]$ is identical to
	 $u[fy/x][w_0/y][\vec d/\D]$.
	 Thus, by rule eval-subst in Figure~\ref{fig:eval},
	 \[
	  \hypert\eval\vec{w'}\hmid u[fy/x][t/y][\vec d/\D]\eval w_1
	 \]
	 is derivable.
    \item[(Cut)] Essentically the same as and simpler than ($\limp$L).
    \item[(Sync)]
	 The derivation ends as
	 \AxiomC{$\hypert\hmid \G\tr\tj{t}{\phi}\hmid \D\tr\tj{u}{\psi}$}
	 \UnaryInfC{$\hypert\hmid \G\tr\tj{ct}{\psi}\hmid \D\tr\tj{\co
	 cu}{\phi}$}
	 \DisplayProof\enspace.
	 Take any $O\in\semo{\hypert}$, $\vec g\in \semo{\G}$ and $\vec
	 d\in\semo{\D}$.
	 By induction hypothesis, the hyper evaluation
	 \[
	  O\eval \vec{v'}\hmid t[\vec g/\G] \eval v\hmid u[\vec
	 d/\D]\eval w
	 \]
	 is derivable.
	 Thus,
	 \[
	  O\eval \vec{v'}\hmid (ct)[\vec g/\G] \eval w\hmid (\co cu)[\vec
	 d/\D]\eval v
	 \]
	 is also derivable.
    \item[(Contraction)]
	 The derivation ends as
	  \begin{center}
	   \AxiomC{$\hypert\hmid\G,\tj{x}{\bang \phi},\tj{y}{\bang \phi}\tr\tj{t}{\psi}$}
	   \UnaryInfC{$\hypert\hmid \G,\tj{z}{\bang\phi}\tr\tj{\letin z
	   {x@y} t}{\psi}$}
	   \DisplayProof
	  \end{center}
	 Take any $O\in\semo{\hypert}$, $\vec{g}\in\semo{\G}$ and
	 $u\in\semo{\bang\phi}$.
	 Since $u$ is in $\semo{\bang\phi}$, there exists a term $u'$ in
	 $\semo{\phi}$
	 where $u\eval \bang u'$.
	 Moreover, by induction hypothesis,
	 \[
	  \hypert\eval\vec{o}\hmid t[\vec g/\G][\bang u'/x][\bang u'/y]\eval t'
	 \]
	 is derivable for some $\vec{o}$ and $t'\in\semo{\psi}$.
	 By merge,
	 \[
	  \hypert\eval\vec{o}\hmid t[\vec g/\G][\bang u'/x][\bang u'/y]\eval
	 t'\hmid u\eval \bang u'
	 \]
	 is derivable and then
	 \[
	  \hypert\eval\vec{o}\hmid
	 (\letin{z}{x@y}{t})[\vec g/\G][\bang u'/z]\eval t'
	 \]
	 is also derivable.
    \item[($\with$L$_0$)]
	 The derivation ends in
	  \begin{center}
	   \AxiomC{$\hypert\hmid\G,\tj{x}{\phi}\tr\tj{t}{\theta}$}
	   \UnaryInfC{$\hypert\hmid\G,\tj{z}{\phi\with\psi}\tr\tj{
	   \letin z {\lpair{x,\_}} t
	   }{\theta}$}
	   \DisplayProof
	  \end{center}
	 Take any $\vec g\in\semo{\G}$, $s\in\semo{\phi\with\psi}$
	 and $O\in\semo{\hypert}$
	 By definition of $s$, $s\eval \lpair{v_0,v_1}$ is derivaboe
	 for some
	 $v_0\in\semo{\phi}$ and $v_1\in\semo{\psi}$.
	 By induction hypothesis,
	 \[
	 O\eval \vec{o} \hmid t[\vec g/\G][v_0/x]\eval w
	 \]
	 is derivable for some $\vec o$ and $w\in\semo{\theta}$.
	 Thus,
	 \[
	  O\eval \vec o\hmid \letin z {\lpair{x,\_}} t \eval w
	 \]
	 is also derivable.
    \item[($\with$L$_1$)] Symmetric to above.
    \item[($\with$R)]
	 The derivation ends as
	  \begin{center}
	   \AxiomC{$\G\tr\tj{t}{\phi}$}
	   \AxiomC{$\G\tr\tj{u}{\psi}$}
	   \BinaryInfC{$\G\tr\tj{\lpair{t,u}}{\phi\with\psi}$}
	   \DisplayProof
	  \end{center}
	 By induction hypothesis,
	 $t[\vec g/\G]\eval v$ and
	 $u[\vec g/\G]\eval w$
	 are derivable for some
	 $v\in\semo{\phi}$ and $w\in\semo{\psi}$.
	 Thus, $t[\vec g/\G]\in\semo{\phi}$ and
	 $u[\vec g/\G]\in\semo{\psi}$ hold.
	 We now conclude $\lpair{t,u}[\vec g/\G]$ is in
	 $\semo{\phi\with\psi}$ because
	 \[
	  \lpair{t,u}[\vec g/\G]\eval \lpair{t,u}[\vec g/\G]
	 \]
	 is derivable.
    \item[($\forall$R)]
	 Since the induction hypothesis holds regardless of $|X|_0$.
    \item[Other rules]
	 Other cases are easier.
   \end{description}
   \fix{complete}
  \end{proof}

   \begin{corollary}[Convergence]
    \label{convergence}
   \end{corollary}

   \begin{corollary}[Consistency of \fix{name of logic}]
    $\tr\tj{t}{\forall X.X}$ is not derivable for any term~$t$.
   \end{corollary}
    \begin{proof}
     Assume $\tr\tj{t}{\forall X.X}$ is derivable.
     Then, by \thref{thm:generalconvergence},
     $t\eval t'$ is derivable for some $t'$ in $\semo{\forall X.X}$.
     However, $\semo{\forall X.X}$ is empty.
    \end{proof}

    \fix{say something about church-rosser}

    \section{Sessions and Processes}

    \subsection{Session Types as Abbreviations}

    As abbreviation, we introduce \textit{session
    types}\index{type!session}\index{session type|see{type}}.
    Instead of the standard notation $\bang\phi.\psi$, we use
    $\sendtype{\phi}{\psi}$ in order to avoid the confusion with
    $\bang\phi$.
    For symmetry, we use $\recvtype{\phi}\psi$ instead of $?\phi.\psi$.
    The definitions and the descriptions are modification from
    \citet{wadler2012propositions}'s translations and descriptions.
    \begin{align*}
     \sendtype\phi\psi&\equiv \phi\limp\psi &\text{output value of type $\phi$ then behave as $\psi$} \\
     \recvtype\phi\psi&\equiv \phi\otimes\psi &\text{input value of type $\phi$ then behave as $\psi$}\\
     \oplus\{l_i\colon \phi_i\}_{i\in I} &\equiv {\phi_0}\with
     \cdots \with {\phi_n}, \quad I = \{0,\ldots,n\} & \text{select from behaviours
     $\phi_i$ with label $l_i$}\\
     \with\{l_i\colon \phi_i\}_{i\in I} &\equiv {\phi_0}\oplus
     \cdots \oplus {\phi_n}, \quad I = \{0,\ldots,n\}& \text{offer choice of
     behaviours $\phi_i$ with label $l_i$}
     \\
     \terminate &\equiv \one &\text{terminator}
    \end{align*}
    where $I$ is a finite downward-closed set of natural numbers like
    $\{0,1,2,3\}$.


    The grammar
    \[
     \phi,\psi ::= \terminate\mid X \mid \sendtype\phi\psi \mid
     \recvtype\phi\psi
     \mid \oplus\{l_i\colon\phi_i\}_{i\in I}
     \mid \with\{l_i\colon\phi_i\}_{i\in I}
     \mid \bang\phi
    \]
    covers all types.

    A linear type ($\phi^\ell$ possibly with subscript) is generated by
    this grammar:
    \[
     \phi^\ell ::= \terminate\mid
     \sendtype{\psi}{\phi^\ell} \mid
     \recvtype{\psi}{\phi^\ell}
     \mid \oplus\{l_i\colon\phi^\ell_i\}_{i\in I}
     \mid \with\{l_i\colon\phi^\ell_i\}_{i\in I}
    \]

    We define duals of linear types.
    Again the definition is almost the
    same as \citet{wadler2012propositions}'s except that $\terminate$ is
    self-dual.
    \begin{align*}
     \overline{\sendtype\psi{\phi^\ell}}&= \,\recvtype\psi{\overline{\phi^\ell}}\\
     \overline{\recvtype\psi{\phi^\ell}}&= \,\sendtype\psi{\overline{\phi^\ell}}\\
     \overline{\oplus\{l_i\colon \phi^\ell_i\}_{i\in I}} &=
     \with\{l_i\colon \overline{\phi^\ell_i}\}_{i\in I} \\
     \overline{\with\{l_i\colon \phi^\ell_i\}_{i\in I}} &=
     \oplus\{l_i\colon \overline{\phi^\ell_i}\}_{i\in I} \\
     \overline{\terminate} &= \terminate\enspace.
    \end{align*}
    \fix{see other literature as well for the definition of session
    types}

    \subsection{Processes as Abbreviations}

    \subsubsection{Process Abrreviations}
    We define the sending and receiving as abbreviations:
    \begin{align*}
     \sendterm x u t &\equiv t[(xu) /x] &\text{send $u$ through channel
     $x$ and then use $x$ in $t$} \\
     \recvterm x y t &\equiv \letin x {y\otimes x} t & \text{receive
     $y$ through channel $x$ and use $x$ and $y$ in $t$} \\
     0 &\equiv \ast &\text{do nothing}
    \end{align*}
    We have to be careful about substitution combined with process
    abbreviations.
    For example, $(\sendterm x u t)[s/x]$ is not $\sendterm s u t$
    because the later is not defined.  Following the definition,
    $(\sendterm x u t)[s/x]$ is actually $(t[xu/x])[s/x] = t[su/x]$.
    We are going to introduce the name restriction $\nu x.t$ after
    implementing channels.

    \subsubsection{Typing Rules for Process Abbreviations}
    The session type abbreviation and the processes abbreviation are
    consistent as the next proposition shows.
     \begin{proposition}
      \label{typing_process}
      These rules are admissible.
       \begin{center}
      \AxiomC{$\hypert\hmid\tj{y}{\psi}, \tj{x}{\chi}\tr\tj{t}{\phi}$}
      \UnaryInfC{$\hypert\hmid\tj{x}{\recvtype\psi\chi}\tr\tj{\recvterm x y
      t}{\phi}$}
      \DisplayProof
      \hfill
      \AxiomC{$\hypert\hmid \G,\tj{x}{\chi}\tr\tj{t}{\phi}\hmid \D\tr\tj{u}\psi$}
      \UnaryInfC{$\hypert\hmid \G,\D,\tj{x}{\sendtype
      \psi\chi}\tr\tj{\sendterm x u t}{\phi}$}
      \DisplayProof
      \ruleskip
      \AxiomC{$\hypert\hmid \G\tr\tj{t}{\phi}$}
      \UnaryInfC{$\hypert\hmid \G,\tj{x}{\terminate}\tr\tj{\ign x
      t}{\phi}$}
      \DisplayProof
	\hfill
	\AxiomC{}
	\UnaryInfC{$ \tr\tj 0 \ast $}
	\DisplayProof
       \end{center}
     \end{proposition}
     Before entering the proof, we note that the types of $x$ change in
     the rules.  This reflects the intuition of session types: the
     session type of a channel changes after some communication occurs
     through the channel.
      \begin{proof}
       Without abbreviations, the first rule is actually one of the
       original rules:
	\begin{center}
	 \AxiomC{$\hypert\hmid\tj{y}{\psi}, \tj{x}{\chi}\tr\tj{t}{\phi}$}
	 \UnaryInfC{$\hypert\hmid\tj{x}{\psi\otimes\chi}\tr\tj{\letin x
	 {y\otimes x} t}{\phi}$}
	 \DisplayProof\enspace.
	\end{center}
       Without abbreviations, the second rule is also one of the
       original rules:
	\begin{center}
	 \AxiomC{$\hypert\hmid \G,\tj{x}{\chi}\tr\tj{t}{\phi}\hmid \D\tr\tj{u}\psi$}
	 \UnaryInfC{$\hypert\hmid \G,\D,\tj{x}{
      \psi\limp\chi}\tr\tj{t[(xu)/x]}{\phi}$}
	 \DisplayProof\enspace.
	\end{center}
       The third and the fourth rule are more evidently one of the orignal rules.
      \end{proof}

    \begin{example}[Typed communicating terms]
     \label{ex:typed-processes}
     Using \thref{typing_process}, we can type processes.
     Here is one process, which sends a channel $y$ through $x$ and then
     wait for input in a channel~$y'$.
      \begin{center}
       \small
       \AxiomC{}
       \UnaryInfC{$\tj{z}{\two} \tr\tj z \two$}
       \UnaryInfC{$\tj{z}{\two},\tj{y}{\terminate}\tr\tj{\ign y z}\two$}
       \UnaryInfC{$\tj{z}{\two},\tj{x}{\terminate},
       \tj{y}{\terminate}\tr\tj{\ign {x,y} z}\two$}
       \UnaryInfC{$\tj{x}{\terminate},\tj{y}{\recvtype\two\terminate}\tr
       \tj{\recvterm y z
       {\ign {x,y}  z}}{\two}$}
       \AxiomC{}
       \UnaryInfC{$\tj{y'}{\sendtype{\two}{\terminate}}\tr\tj{y'}{\sendtype\two\terminate}$}
       \BinaryInfC{$\tj{y}{\recvtype\two\terminate},\tj{x}{\sendtype{\sendtype
       \two \terminate}\terminate}, \tj{y'}{\sendtype \two
       \terminate}\tr\tj
       {\sendterm x y{\recvterm {y'}z{\ign {x,y} z}}}\two$}
       \DisplayProof
      \end{center}
     Here is another process that takes an input~$w'$ from channel~$x'$, where
     the input $w'$ itself is expected to be a channel.
     After receiving $w'$, the process puts $\inl{\ast}$ in $w'$.
      \begin{center}
       \AxiomC{}
       \UnaryInfC{$\tr\tj\ast\one$}
       \UnaryInfC{$\tj{w'}\terminate\tr\tj{\ign{w'}\ast}\one$}
       \AxiomC{}
       \UnaryInfC{$\tr\tj\ast\one$}
       \UnaryInfC{$\tr\tj{\inl{\ast}}{\two}$}
       \BinaryInfC{$\tj{w'}{\sendtype\two\terminate}\tr\tj{\sendterm{w'}{\inl\ast}{\ign
       {w'}\ast}}{\one}$}
       \UnaryInfC{$\tj{w'}{\sendtype\two\terminate},\tj{x'}\terminate\tr\tj{\ign{x'}{\sendterm{w'}{\inl\ast}{\ign{w'}\ast}}}{\one}$}
       \UnaryInfC{$\tj{x'}{\recvtype{\sendtype\two\terminate}\terminate}\tr\tj{
       \recvterm{x'}{w'}{\ign{x'}{\sendterm{w'}{\inl\ast}{\ign{w'}\ast}}}}\one$}
       \DisplayProof
      \end{center}
     We intend these two processes to communicate when we connect the channels $x$
     and $x'$.
     For that, we have to implement complicated channels as in the
     following subsection.
    \end{example}


    \subsection{Implementing Channels}
    We introduced primitives $\lpair{c,\co c}$ implementing
    $(\one\limp\phi)\otimes(\phi\limp\one)$.
    These can be seen as channels of session types
    $\recvtype\phi\terminate$ and $\sendtype\phi\terminate$.
    Indeed, $\recvtype\phi\terminate$ is $\phi\otimes\one$ (which is
    coerceable to $\one\limp\phi$) and $\sendtype\phi\terminate$ is
    $\phi\limp \one$.
    We can generalize this phenomenon to the more complicated session
    types.
     \begin{theorem}[Session Realizers]
      For any linear type~$\phi^\ell$\kern -2pt, the hypersequent
      $\tr\tj{t}{\phi^\ell}\hmid \tr\tj{u}{\overline{\phi^\ell}}$
      is derivable for some terms $t$ and $u$.
     \end{theorem}
      \begin{proof}
       Induction on $S$.
       \begin{description}
	\item[(end)] \AxiomC{} \UnaryInfC{$\tr\tj\ast\one$}
	     \AxiomC{} \UnaryInfC{$\tr\tj\ast\one$}
	     \BinaryInfC{$\tr\tj\ast\one\hmid\tr\tj\ast\one$}
	     \DisplayProof is what we seek.
	\item[($\sendtype{\psi}{\phi^\ell}$)]
	     By induction hypothesis,
	     $\tr\tj{t'}{\phi^\ell}\hmid \tr \tj{u'}{\overline{\phi^\ell}}$ is
	     derivable.  Using this, we can make the following
	     derivation:
	      \begin{center}
	      \AxiomC{}
	       \UnaryInfC{$\tj{x}{\psi}\tr\tj{x}{\psi}$}
	       \AxiomC{$\tr\tj{t'}{\phi^\ell}\hmid \tr
	       \tj{u'}{\overline{\phi^\ell}}$}
	       \BinaryInfC{$\tj{x}{\psi}\tr\tj{x}{\psi}\hmid
	       \tr\tj{t'}{\phi^\ell}\hmid \tr
	       \tj{u'}{\overline{\phi^\ell}}$}
	       \UnaryInfC{$\tj{x}{\psi}\tr\tj{cx}{\phi^\ell}\hmid
	       \tr\tj{(\co ct')\otimes u'}{\psi\otimes \overline{\phi^\ell}}$}
	       \UnaryInfC{$\tr\tj{\lambda x.cx}{\psi\limp\phi^\ell}\hmid
	       \tr\tj{(\co ct')\otimes u'}{\psi\otimes \overline{\phi^\ell}}$}
	       \DisplayProof\enspace.
	      \end{center}
	\item[($\recvtype\psi\phi$)]
	     Symmetric to above.
	\item[($\oplus\{l_i\colon \phi_i\}$)]
	     By induction hypothesis,
	     for each $i\in I$, we have
	     \[
	      \tr\tj{t_i}{{\phi_i}}\hmid \tr\tj{u_i}{{\overline{\phi_i}}}
	     \]
	     derived.  Hence derivable is
	     \[
	      \tr\tj{t_i}{{\phi_i}}\hmid \tr\tj{i(u_i)}{\oplus_{j\in
	     I}
	     {\overline{\phi_j}}}\enspace.
	     \]
	     Combining $|I|$ such derivations, we can derive
	     \[
	     \tr\tj{\tuple{t_i}_{i\in I}^n}{\with_{i\in I}{\phi_i}}
	     \hmid
	     \tuple{\tr\tj{i(u_i)}{\oplus_{j\in
	     I}{\overline{\phi_j}}}}_{i\in I}^n
	     \]
	     for a fresh natural number~$n$.
	     \fix{define and explain about this form of hypersequents}
	\item[($\with\{l_i\colon \phi_i\}$)]
	     Symmetric to above.
       \end{description}
      \end{proof}
      We call the pair $t,u$ the session realizers of $\phi^\ell$ and
      denote them by $\leftside{\phi^\ell}, \rightside{\phi^\ell}$.
      Moreover, we use $\bothside{\phi^\ell}$ to denote the pair
      $\leftside{\phi^\ell}\otimes\rightside{\phi^\ell}$.
      If have two terms that uses free variables of type $\phi^\ell$ and
      $\overline{\phi^\ell}$,
      we can replace those free variables by session realizers.
       \begin{corollary}
	If
	$\hypert_0\hmid \G,\tj{x}{\phi^\ell}\tr\tj{t}{\psi}$ and
	$\hypert_1\hmid \D,\tj{y}{\overline{\phi^\ell}}\tr\tj{u}{\theta}$
	are derivable,
	\[
	\hypert_0\hmid \G\tr\tj{t[\leftside{\phi^\ell}/ x]}{\psi}
	\hmid \hypert_1\hmid \D\tr\tj{u[\rightside{\phi^\ell}/ y]}{\theta}
	\]
	is also derivable.
       \end{corollary}

       We can define name restriction as an abbreviation:
       \[
	\nu \tj{x}{\phi^\ell}. t \equiv
	\letin{\bothside{\phi^\ell}}{x_L\otimes x_R} t\enspace.
       \]

       Then, in addition to \thref{typing_process},
       more typing rules are available.
	\begin{proposition}
	 The following typing rule is admissible.
	  \begin{center}
	   \AxiomC   {$\hypert\hmid
	   \G,\tj{x}{\phi^\ell},\tj{y}{\overline{\phi^\ell}}\tr\tj t \psi$}
	   \UnaryInfC{$\hypert\hmid
	   \G\tr\tj{\nu\tj{x}{\phi^\ell}.t[x_L/x][x_R/y]}{\psi}$}
	   \DisplayProof
	  \end{center}
	\end{proposition}

	\begin{example}[Connecting processes using the session realizers]
	 Using the session realizers, we can connect the processes typed
	 in \thref{ex:typed-processes}.  Indeed,
	 \begin{align*}
	  \tr &
	  \nu(\tj{x}{\recvtype{\sendtype{\two}\terminate}\terminate}).
	  \nu(\tj{y}{\sendtype\two\terminate}).
	  \\ & {\left(
	 \sendterm {x_R}{y_L}{\recvterm {y_R} z {\ign{x_R,y_R}z}}
	 \right)}
	 \otimes
	  \left(
	 \recvterm{x_L}{w'}{\ign{x_L}{\sendterm{w'}{\inl\ast}{\ign
	  {w'}\ast}}}
	  \right)
	  \\&
	 \colon{(\two)\otimes\one}
	 \end{align*}
	 is derivable.
	 Now we have to check the evaluation of this term.
	 For that we prepare a lemma.
	\end{example}


      \subsubsection{Evaluation of Processes}

      The intention of defining $\sendterm x u {t_0}$ and $\recvterm y z {t_1}$
      is mimicking communication in process calculi.
      When we substitute $x$ and $y$ with session type realizers,
      these terms actually make communication.

  \begin{lemma}
   \label{processtype}
   Let $t_0$ be a term containing free variable $x$ and
   $t_1$ be a term containing free variables
   $y$ and $z$.
   The rule \fix{too much width}
   \begin{center}
    \footnotesize
    \AxiomC{$\hypere\hmid \leftside{\phi^\ell}\eval v'\hmid
    \rightside{\phi^\ell}\eval w'\hmid t_0[v'/x]\eval v\hmid u\eval
    u'\hmid
    t_1[u'/z][w'/y]\eval w$}
    \UnaryInfC{$
    \hypere\hmid
    \leftside{\sendtype\psi{\phi^\ell}}\eval \lambda x.cx
    \hmid
    \rightside{\sendtype\psi{\phi^\ell}}\eval u'\otimes w'
    \hmid
    (\sendterm x u {t_0})[\lambda x.cx / x]\eval v
    \hmid
    (\recvterm y z {t_1})[u'\otimes w'/y] \eval w
    $}
    \DisplayProof
   \end{center}
   \fix{add symmetric rule}
   is admissible.  \fix{define admissible somewhere}
  \end{lemma}
  \begin{proof} By the derivation in Figure~\ref{fig:processtype}
    \begin{sidewaysfigure}
     \centering
    \AxiomC{}
    \UnaryInfC{$\lambda x.cx\eval \lambda x.cx$}
    \AxiomC{}
    \UnaryInfC{$\lambda x.cx\eval \lambda x.cx$}
    \AxiomC{}
    \UnaryInfC{$\hypere\hmid \leftside{\phi^\ell}\eval v'\hmid
    \rightside{\phi^\ell}\eval w'\hmid t_0[v'/x]\eval v\hmid u\eval
    u'\hmid
    t_1[u'/z][w'/y]\eval w$}
     \doubleLine
    \UnaryInfC{$\hypere\hmid \leftside{\phi^\ell}\eval v'
    \hmid
    \rightside{\phi^\ell}\eval w'\hmid t_0[v'/x]\eval v\hmid u\eval
    u'\hmid \letin{u'\otimes w'}{z\otimes y}{t_1}\eval w$}
    \BinaryInfC{
    $\hypere\hmid \leftside{\phi^\ell}\eval v'
    \hmid
    \rightside{\phi^\ell}\eval w'\hmid t_0[v'/x]\eval v\hmid \lambda
    x.cx\eval \lambda x.cx\hmid u\eval
    u'\hmid \letin{u'\otimes w'}{z\otimes y}{t_1}\eval w$
    }
     \UnaryInfC{
     $
     \hypere\hmid \co c(\leftside{\phi^\ell})\eval u'
    \hmid
    \rightside{\phi^\ell}\eval w'\hmid t_0[v'/x]\eval v\hmid \lambda
    x.cx\eval \lambda x.cx\hmid cu\eval
    v'\hmid \letin{u'\otimes w'}{z\otimes y}{t_1}\eval w
     $
     }
     \UnaryInfC{
     $
     \hypere\hmid \co c(\leftside{\phi^\ell})\eval u'
    \hmid
    \rightside{\phi^\ell}\eval w'\hmid t_0[v'/x]\eval v\hmid (\lambda
    x.cx)u\eval v'\hmid \letin{u'\otimes w'}{z\otimes y}{t_1}\eval w
     $
     }
     \UnaryInfC{
     $
     \hypere\hmid \co c(\leftside{\phi^\ell})\eval u'
    \hmid
    \rightside{\phi^\ell}\eval w'\hmid t_0[(\lambda
    x.cx)u /x]\eval v\hmid \letin{u'\otimes w'}{z\otimes y}{t_1}\eval w
     $
     }
     \UnaryInfC{
     $
     \hypere\hmid
     \co c(\leftside{\phi^\ell})\otimes \rightside{\phi^\ell} \eval u' \otimes  w'
     \hmid t_0[(\lambda
    x.cx)u /x]\eval v\hmid \letin{u'\otimes w'}{z\otimes y}{t_1}\eval w
     $
     }
     \BinaryInfC{$
     \hypere\hmid \lambda x.cx \eval \lambda x.cx \hmid
     \co c(\leftside{\phi^\ell})\otimes \rightside{\phi^\ell} \eval u' \otimes  w'
     \hmid t_0[(\lambda
    x.cx)u /x]\eval v\hmid \letin{u'\otimes w'}{z\otimes y}{t_1}\eval w
     $}
    \DisplayProof
     \caption{Proof of \thref{processtype}.    The conclusion is
     identical to our goal up to abbreviations. }
     \label{fig:processtype}
    \end{sidewaysfigure}
  \end{proof}

  \begin{example}[Evaluation of communicating processes]
   \fix{from report pad}
   \begin{center}
    \AxiomC{}
    \UnaryInfC{$\nu(\tj{x}{\sendtype{\one\oplus\one}{\terminate}}).
    \left(\sendterm{x_L}{\inl\ast}{\ign{x_L}\ast}\right)\otimes
    \left(\recvterm{x_R}{z}{\ign {x_R}z}\right)\eval \ast\otimes\inl\ast$}
    \DisplayProof
   \end{center}
  \end{example}

  \subsection{Copycatting}
  \begin{theorem}
   For any linear type~$\phi^\ell$,
   we can derive
   $\tj{x}{\phi^\ell},\tj{y}{\overline{\phi^\ell}}\tr
   \tj{t}{\one}$
   for some term~$t$.
  \end{theorem}
  \begin{proof}
   By induction on $\phi^\ell$.
   \begin{description}
    \item[($\terminate$)]
	 Since $\overline{\terminate} =\terminate$, the derivation
	  \begin{center}
	   \AxiomC{}
	   \UnaryInfC{$\tr\tj{\ast}\one$}
	   \UnaryInfC{$\tj{y}{\terminate}\tr\tj{\ign y \ast}\one$}
	   \UnaryInfC{$\tj{x}{\terminate},\tj{y}{\terminate}\tr\tj{\ign{x,y}\ast}\one$}
	   \DisplayProof
	  \end{center}
	 suffices.
    \item[($\sendtype\psi{\phi^\ell}$)]
	 Using the induction hypothesis (IH.), we obtain a derivation:
	  \begin{center}
	   \AxiomC{$\vdots$ (IH.)}
	   \UnaryInfC{$\tj{x}{\phi^\ell},\tj{y}{\overline{\phi^\ell}}\tr\tj{t}{\one}$}
	   \AxiomC{}
	   \UnaryInfC{$\tj{z}{\psi}\tr\tj{z}{\psi}$}
	   \BinaryInfC{$\tj{x}{\sendtype{\psi}{\phi^\ell}},\tj{y}{\overline{\phi^\ell}},\tj{z}{\psi}\tr\tj{\sendterm
	   x z t}{\one}$}
	   \UnaryInfC{$\tj{x}{\sendtype{\psi}{\phi^\ell}}\tr\tj{y}{\recvtype
	  \psi {\overline{\phi^\ell}}}\tr\tj{\recvterm y z {\sendterm x
	   z t}}{\one}$}
	   \DisplayProof
	  \end{center}
    \item[($\recvtype\psi{\phi^\ell}$)]
	 Symmetric to above.
    \item[($\oplus\{l_i\colon\phi^\ell_i\}$)]
	 \fix{fill}
    \item[($\with\{l_i\colon\phi^\ell_i\}$)]
	 Symmetric to above.
   \end{description}
  \end{proof}
 \begin{example}
  \fix{Give evaluation}
  Figure~\ref{fig:eval}
 \end{example}

  \begin{sidewaysfigure}
   \centering
   \AxiomC{}
   \UnaryInfC{$\leftside\terminate\eval \ast\hmid
   \rightside\terminate\eval\ast$}
   \AxiomC{}
   \UnaryInfC{$\ast\eval\ast$}
   \UnaryInfC{$\inl\ast\eval\inl\ast$}
   \AxiomC{}
   \UnaryInfC{$\ast\eval\ast$}
   \BinaryInfC{$\inl\ast\eval\inl\ast\hmid\ast\eval\ast$}
   \BinaryInfC{$
   \leftside\terminate\eval \ast\hmid
   \rightside\terminate\eval\ast
   \hmid
   \inl\ast\eval\inl\ast\hmid\ast\eval\ast
   $}
   \UnaryInfC{$
   \leftside{\sendtype\two\terminate}\eval \lambda x. cx\hmid
   \rightside{\sendtype\two\terminate}\eval \inl\ast\otimes \ast \hmid
   (\sendterm{y'}{\inl\ast}\ast)[\lambda x.cx/y']\eval\ast\hmid
   (\recvterm y z z)[\inl\ast\otimes\ast / y]\eval\inl\ast
   $}
   \AxiomC{}
   \UnaryInfC{$\leftside\terminate\eval\ast\hmid
   \rightside\terminate\eval \ast$}
   \BinaryInfC{$
   \leftside{\sendtype\two\terminate}\eval \lambda x. cx\hmid
   \rightside{\sendtype\two\terminate}\eval \inl\ast\otimes \ast \hmid
   (\sendterm{y'}{\inl\ast}\ast)[\lambda x.cx/y']\eval\ast\hmid
   (\recvterm y z z)[\inl\ast\otimes\ast / y]\eval\inl\ast
   \hmid
   \leftside\terminate\eval\ast\hmid
   \rightside\terminate\eval \ast
   $}
   \UnaryInfC{\small $
   \leftside{\sendtype\two\terminate}\eval \lambda x. cx\hmid
   \rightside{\sendtype\two\terminate}\eval \inl\ast\otimes \ast \hmid
   \leftside{\terminate}\eval\ast\hmid
   \rightside{\terminate}\eval\ast\hmid
   (\sendterm{y'}{\inl\ast}\ast)[\lambda x.cx/y']\eval\ast\hmid
   (\recvterm y z z)[\inl\ast\otimes\ast / y]\eval\inl\ast
   \hmid
   \leftside\terminate\eval\ast\hmid
   \rightside\terminate\eval \ast
   $}
   \UnaryInfC{$
   \rightside{\sendtype\two\terminate}\eval \inl\ast\otimes \ast \hmid
   \leftside{\recvtype{\sendtype\two\terminate}\terminate}\eval \lambda
   x.dx\hmid
   \rightside{\recvtype{\sendtype\two\terminate}\terminate}\eval\lambda
   x.cx\otimes \ast\hmid
   $}
   \noLine
   \UnaryInfC{$
   (\recvterm{x'}z{\sendterm{z}{\inl\ast}\ast})[\lambda x.cx\otimes \ast/y']\eval\ast\hmid
   (\sendterm{x}{\leftside{\sendtype\two\terminate}}{\recvterm y z
   z})[\lambda x.dx / x][\inl\ast\otimes\ast / y]\eval\inl\ast
   $}
   \doubleLine
   \UnaryInfC{$
   (\recvterm{x'}{z}{\sendterm z{\inl\ast}{\ast}})
   [\rightside{\recvtype{\sendtype{\two}{\terminate}}{\terminate}}/x']
   \eval \ast
   \hmid
   (\sendterm{x}{\leftside{\sendtype\two\terminate}}{\recvterm y z z})
   [\leftside{\recvtype{\sendtype\two\terminate}\terminate}/x]
   [\rightside{\sendtype\two\terminate}/y]
   \eval \inl\ast
   $}
   \UnaryInfC{$
   (\recvterm{x'}{z}{\sendterm z{\inl\ast}{\ast}})
   [\rightside{\recvtype{\sendtype{\two}{\terminate}}{\terminate}}/x']
   \otimes
   (\sendterm{x}{\leftside{\sendtype\two\terminate}}{\recvterm y z z})
   [\leftside{\recvtype{\sendtype\two\terminate}\terminate}/x]
   [\rightside{\sendtype\two\terminate}/y]
   \eval \ast\otimes \inl\ast
   $}
   \UnaryInfC{$
   \letin{\bothside{\recvtype{\sendtype{\two}{\terminate}}{\terminate}}}{x'\otimes
   x}{
   \letin{\bothside{\sendtype\two\terminate}}{y'\otimes y}{
   (\recvterm{x'}{z}{\sendterm z{\inl\ast}{\ast}})
   \otimes
   (\sendterm{x}{y'}{\recvterm y z z})
   }
   }
   \eval \ast\otimes \inl\ast
   $}
   \DisplayProof
   \caption{An example of evaluation relation.}
  \end{sidewaysfigure}

% \section{Toward Determinacy}

% Determinancy states that if $t\eval v$ and $t\eval w$ are derivable,
% then, $v$ and $w$ are identical.
% Since the proof of dterminacy goes inductively over evaluation
% derivations\fix{define
% evaluation derivations},
% we have to generalize the statement.
%  \begin{proposition}[General Determinacy]
%   If
%   $t_0\eval v_0\hmid \cdots \hmid t_n\eval v_n$ and
%   $t_0\eval w_0\hmid \cdots \hmid t_n\eval w_n$ are
%   derivable,
%   then each $v_i$ is identical to $w_i$.
%  \end{proposition}
%   \begin{proof}
%    By induction on the length of the first derivation.
%    \fix{complete}
%   \end{proof}

\section{Proof Nets}

\fix{talk about proof nets}

\section{Related Work}

\subsection{Pfenning}

\citet{pfenning2010} provide a type system for a fragment of $\pi$-calculus.
The type system of \citet{pfenning2010} imposes too strong a descipline
than necessary to provide deadlock freedom.
While the escrowing process $P$ is not typeable in their type
system, where
\[
 P = \sendterm x y{\recvterm x a {\recvterm y b {\sendterm x b
 {\sendterm y a 0}}}}\enspace.
\]
The process first emits a channel~$y$ through channel~$x$ and then
exchanges inputs from $x$ and $y$ into outputs to $y$ and $x$.
Following the informal description of types in \citep{pfenning2010},
the process~$P$ should be typeable as
\[
 \vdash P::x:(A\limp B)\otimes(B\limp A)\enspace.
\]
However, such typing is not possible because $(A\limp B)\otimes (B\limp
A)$ is not a theorem of \fix{name} (DILL), the logic their type system
is based on.
In our type system, the following sequent is derivable
\begin{align*}
&
\tj{x}{\sendtype{\sendtype{B}{\recvtype{A}\terminate}}{\recvtype B
{\sendtype A \terminate}}}
\tr\\
&\tj{
\letin{\bothside{\sendtype{B}{\recvtype{A}{\terminate}}}}{y'\otimes y}
{\sendterm x{y'}{\recvterm x a {\recvterm y b {\sendterm x b {\sendterm
y a {\ign{x,y}0}}}}}}
}{\one}
\end{align*}
The resulting sequent indicates that the process is typeable with one
open channel~$x$ that emits
a channel to/from which one can send~$B$ and receivie~$A$, receives a
value of $B$ and
sends a value of $A$.
This example shows that our type system is strictly more flexible than
the type system in \citet{pfenning2010}.
Moreover, we still ensure deadlock freedom in the sense that all typed
processes reduce to the canonical form~(\thref{convergence}).

\subsection{Wadler}

\subsection{Beffara}

\section{Conclusion}


\section{Discussion}

It is tempting to add modalities to types so that the
modalities show agents and then study the relationship with the
multiparty session types \fix{cite}.

\fix{give rationale for giving up determinacy.. channel inside lambda}
