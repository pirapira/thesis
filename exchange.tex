\chapter{A Hyper-Lambda-Calculus for Sychronous Communication}
\label{ch:exchange}

\subsection{Motivation}

We propose a way to unify ML-style programming languages \fix{cite} and
$\pi$-calculus \fix{cite}, which are two of Robin Milner's achievements.
``Well-typed expressions do not go wrong,'' said \citet{milner1978}.
However, when communication is involved, how to maintain the principle
is not yet settled.
For example, Haskell, which is a ML-style programming language,
allows different threads to communicate using
putMVar and getMVar commands.
However, if programmers make mistakes, these commands can
causes deadlock in execution time even the program passes the type checking.
This is because the type system of Haskell allows programmers to
use only one of $\phi$ and $(\phi\imp \one)$.
We can try to provide a pair of putMVar and corresponding getMVar,
but we have no way to enforce the programmers to use both of them once
each.
Fundamentally, this is because the type system of Haskell
is based on intuitionistic logic, which allows throwing away proofs.

\fix{mention join calculus here or in related work}

As a remedy, we invent a typed lambda calculus where
the user is forced to use both of sending and receiving primitives.
For that we use the technique of linear types:
linear types can specify a portion of program to be used
just once.

One promising approach is session types.
Sesison types aims at typing channels and processes in $\pi$-calculus so
that the process execution is deterministic and not ending in deadlock.
In general session type systems are not based on well-known logic.

We show that it is still possible to build
a type system which is based on a logic.
Wadler and Pfenning did that, but our type system allows more.

From the standard intuitionistic linear logic,
the only change is adding an axiom
$(\phi\limp\psi)\oplus(\psi\limp\phi)$.
Here, we can express $\pi$-calculus-like processes as macros.

However, our initial motivation was just studying the axiom
$(\phi\limp\psi)\otimes(\psi\limp\phi)$%
\footnote{Takeuti Izumi asked about conjunctions
after the author talked about $(\phi\limp\psi)\oplus (\psi\limp\phi)$.}.
A natural way to add $(\phi\limp\psi)\otimes(\psi\limp\phi)$ as an axiom
is adding a pair of primitives $c,\co c$ so that
$\cdots ct \cdots \co c u \cdots$ reduces to
$\cdots u  \cdots t \cdots$: in words,
$c$ outputs $\co c$'s input and vice versa.
We can obtain the send-receive communication when we specialize the
axiom as $(\phi\limp \one)\otimes(\one\limp\phi)$.  The left hand side
$\tj{c}{\phi\limp\one}$ is the sending primitive and
the right hand side $\tj{\co c}{\one \limp\phi}$ is the receiving
primitive.

When we want to use these primitives anywhere in lambda terms,
there is one problem: what happens to $\co c(c t)$?
In this case, we do not know the output of $c$ because we only have an
equality between $\co c$'s input and $c$'s output.
Fortunately, we just want to know the output of $\co c$, which is the
input of $c$, that is, $t$.
In a more complicated case $\co c(\co d(c (d t)))$,
we can reason the output of $\co c$ as the input of $c$ as the output of
$d$ as the input of $\co d$ as the output of $c$ as the input of $\co c$
as the output of $\co d$ as the input of $d$, which is $t$.

We have more questions.
\begin{itemize}
 \item How does it generalize over more channels?
 \item Due to addition of the axiom, is it the case that
       every type is inhabited?  In other words,
      is the resulting type system consistent?
 \item Can we implement process calculi using the aforementioned primitives?
\end{itemize}
\fix{how does it generalize?}

\section{Definitions}

\subsection{Types}
For a set $S$, we define $\phi\in\form(S)$ by BNF:
\[
 \phi::=s\mid \one \mid X \mid \phi\otimes\phi\mid \phi\limp\phi\mid
 \phi\oplus\phi\mid \phi\with\phi\mid \bang\phi\mid \forall X.\phi
\]
where $s$ is an element of $S$ and $X$ is a propositional variable.
The propositional variable in the last clause is binding.
A \textit{type}\index{type} is an element of $\form(\emptyset)$.

\subsection{Terms and Free Variables}

Following Abramsky's linear lambda calculus
LF~\citep{abramsky1993computational}, we first defne patterns
binding sets of variables:
\begin{itemize}
 \item $\ast$ and $\_$ are patterns binding $\emptyset$,
 \item $\lpair{x,\_}$, $\lpair{\_,x}$ and $\bang x$ are patterns binding
       $\{x\}$,
 \item $x\otimes y$ and $x@y$ are patterns binding $\{x,y\}$.
\end{itemize}
We write $BV(p)$ for the set of bound variables of pattern~$p$.
Using patterns, we define a term $t$ with free variables~$S$.
We assume countably infinitely many \textit{channels}\index{channel}
with involution
satisfying $\co c\neq c$ and $\co{\co c} = c$.
\fix{not good, follow Abramsky}
\begin{itemize}
 \item a variable $x$ is a term with free variables $\{x\}$,
 \item if $t$ is a term with free variables~$S$, $u$ is a term with
       free variables~$S'$ and $S$ and $S'$ are disjoint, $t\otimes u$ and
       $tu$ are terms with free variables $S\cup S'$,
 \item if $t$ and $u$ are terms with free variables $S$, then
       $\lpair{t,u}$ is a term with free variables~$S$,
 \item if $t$ is a term with free variables~$S$, then
       $\inl x, \inr t$ and $\bang t$ are terms with free variables~$S$
 \item if $t$ is a term with free variables $S\cup \{x\}$ and $x$ is not
       in $S$, then $\lambda x.t$ is a term with free variables~$S$,
 \item if $t$ is a term with free variables~$S$, $p$ is a pattern
       binding $S'$, $u$ is a term with free variables $S'\cup S''$ and
       $S\cap S'' = S'\cap S'' = \emptyset$, then,
       $\letin t p u$ is a term with free variables $S\cup S''$,
 \item if $t$ is a term with free variables $S$,
       $u$ is a term with free variables $S''\cup \{x\}$,
       $v$ is a term with free variables $S''\cup \{y\}$,
       $x,y\notin S''$ and $S\cap S'' = \emptyset$,
       $\mat t x u y v$ is a term with free variables $S\cup S''$, and
 \item channels are terms with free variables~$\emptyset$.
\end{itemize}
Note that a term with free variables $S$ is not a term with free
variables $S'$ when $S\neq S'$.  Only the last clause is original,
introducing channels, which are our communication primitives.
We introduce an abbreviation
\begin{align*}
 \ign \epsilon t   & \equiv t\\
 \ign {s_0,\vec s} t & \equiv \letin {s_0} \ast {\ign {\vec s} t}
\end{align*}
inductively for a sequence of terms~$\vec s$.
$\epsilon$ stands for the empty sequence.
The symbol $\mathsf{ign}$ is intended to be pronounced ``ignore''.

\subsection{Typing Derivations}

On top of Abramsky's~\citep{abramsky1993computational} we add a rule to
make $(\phi\limp\psi)\otimes(\psi\limp\phi)$ derivable.
A \textit{context}\index{context}~$\G$ is a possibly empty sequence of
variables associated with
types where the same variable appears at most once.
\fix{give an example}
A \textit{hypersequent}\index{hypersequent} is inductively defined as
\begin{align*}
 \hypert ::=\, &\G\tr\tj{t}{\phi}
 \mid\, (\hypert\hmid \hypert)
\end{align*}
where $\G$ is a context.

The \textit{type}\index{type!--- of a hypersequent} of a hypersequent is
defined inductively.
\begin{align*}
 \type{(\G\tr\tj{t}\phi)}&= \G\tr\phi \\
 \type{(\hypert \hmid \hypert')}&= \type(\hypert)\hmid\type{(\hypert')}
\end{align*}
The last clause is not natural because we ignore the type of $\hypert'$.
Actually, later, we will only allow the construction
$\lpair{\hypert,\hypert'}^n$ for hypersequents satisfying
$\type(\hypert) = \type(\hypert')$.

\fix{definition of terms contains natural number?}
Differently from the previous works \fix{cite},
here, the hypersequent $\G\tr\phi\hmid \D\tr\psi$ is interpreted as the
conjunction of components:
$(\bigotimes\G\limp\phi)\otimes (\bigotimes\D\limp\psi)$.

The typing rules are in Figure~\ref{fig:exchange:rules}.
 \begin{figure}
  \centering
  % axiom
  \AxiomC{}
  \LL{Ax}
  \UnaryInfC{$\tj{x}{\phi}\tr\tj{x}{\phi}$}
  \DisplayProof
  %
  \hfill
  \AxiomC{$\hypert$}
  \AxiomC{$\hypert'$}
  \LL{merge}
  \BinaryInfC{$\hypert\hmid\hypert'$}
  \DisplayProof
  % cut XXX is this necessary?; yes
  \hfill
  \AxiomC{$\hypert\hmid\G\tr\tj{t}{\phi}\hmid\tj{x}{\phi},\D\tr\tj{u}{\psi}$}
  \LL{Cut}
  \UnaryInfC{$\hypert\hmid\G,\D\tr\tj{u[t/x]}{\psi}$}
  \DisplayProof
  \ruleskip
  % exchange
  \AxiomC{$\hypert\hmid\G,\tj{x}{\phi},\tj{y}{\psi},\D\tr\tj{t}{\theta}$}
  \LL{IE}
  \UnaryInfC{$\hypert\hmid\G,\tj{y}{\psi},\tj{x}{\phi},\D\tr\tj{t}{\theta}$}
  \DisplayProof
  %
  \hfill
  \AxiomC{$\hypert\hmid \G \tr\tj t\phi \hmid \D \tr\tj u\psi\hmid \hypert'$}
  \LL{EE}
  \UnaryInfC{$\hypert\hmid \D \tr\tj u\psi \hmid \G \tr\tj t\phi \hmid \hypert'$}
  \DisplayProof
  \ruleskip
  %
  \ruleskip
  % 1R
  \AxiomC{}
  \LL{$\one$R}
  \UnaryInfC{$\tr\tj{\ast}{\one}$}
  \DisplayProof
  %
  \hfill
  % 1L
  \AxiomC{$\hypert\hmid\G\tr\tj{t}{\phi}$}
  \LL{$\one$L}
  \UnaryInfC{$\hypert\hmid\G,\tj{z}{\one}\tr\tj{\ign z t}{\phi}$}
  \DisplayProof
  %
  \hfill
  % otimes R
  \AxiomC{$\hypert\hmid\G\tr\tj{t}{\phi}\hmid\D\tr\tj{u}{\psi}$}
  \LL{$\otimes$R}
  \UnaryInfC{$\hypert\hmid\G,\D\tr\tj{t\otimes u}{\phi\otimes \psi}$}
  \DisplayProof
  %
  \ruleskip
  % Sync
  \AxiomC{$\hypert\hmid\G\tr\tj{t}{\phi}\hmid \D\tr\tj{u}{\psi}$}
  \LL{Sync}
  \UnaryInfC{$\hypert\hmid
  \G\tr\tj{ct}{\psi}\hmid \D\tr\tj{\co cu}{\phi}$}
  \DisplayProof
  %
  \hfill
  % otimes L
  \AxiomC{$\hypert\hmid\G,\tj{x}{\phi},\tj{y}{\psi}\tr\tj{t}{\theta}$}
  \LL{$\otimes$L}
  \UnaryInfC{$\hypert\hmid\G,\tj{z}{\phi\otimes\psi}\tr\tj{\letin{z}{x\otimes
  y}{t}}{\theta}$}
  \DisplayProof
  %
  \ruleskip
  % limp R
  \AxiomC{$\hypert\hmid\G,\tj{x}{\phi}\tr\tj{t}{\psi}$}
  \LL{$\limp$R}
  \UnaryInfC{$\hypert\hmid\G\tr\tj{\lambda x.t}{\phi\limp \psi}$}
  \DisplayProof
  %
  \hfill
  % limp L
  \AxiomC{$\hypert\hmid\G\tr\tj{t}{\phi}\hmid\tj{x}{\psi},\D\tr\tj{u}{\theta}$}
  \LL{$\limp$L}
  \UnaryInfC{$\hypert\hmid\G,\tj{f}{\phi\limp\psi},\D\tr \tj{u[(ft)/x]}{\theta}$}
  \DisplayProof
  %
  \ruleskip
  % andR
  \AxiomC{$\G\tr\tj{t}{\phi}$}
  \AxiomC{$\G\tr\tj{u}{\psi}$}
  \LL{$\with$R}
  \BinaryInfC{$\G\tr\tj{\lpair{t,u}_n}{\phi\with\psi}$}
  \DisplayProof \\
  %
  \ruleskip
  % andL0
  \AxiomC{$\hypert\hmid\G,\tj{x}{\phi}\tr\tj{t}{\theta}$}
  \LL{$\with$L$_0$}
  \UnaryInfC{$\hypert\hmid\G,\tj{z}{\phi\with\psi}\tr\tj{\letin{z}{\lpair{x,\_}}{t}}{\theta}$}
  \DisplayProof
  %
  \ruleskip
  % andL1
  \AxiomC{$\hypert\hmid\G,\tj{y}{\psi}\tr\tj{t}{\theta}$}
  \LL{$\with$L$_1$}
  \UnaryInfC{$\hypert\hmid\G,\tj{z}{\phi\with\psi}\tr\tj{\letin{z}{\lpair{\_,y}}{t}}{\theta}$}
  \DisplayProof
  %
  \ruleskip
  % oplus R0
  \AxiomC{$\hypert\hmid\G\tr\tj{t}{\phi}$}
  \LL{$\oplus$R$_0$}
  \UnaryInfC{$\hypert\hmid\G\tr\tj{\inl{t}}{\phi\oplus\psi}$}
  \DisplayProof
  %
  \hfill
  % oplus R1
  \AxiomC{$\hypert\hmid\G\tr\tj{u}{\psi}$}
  \LL{$\oplus$R$_1$}
  \UnaryInfC{$\hypert\hmid\G\tr\tj{\inr{u}}{\phi\oplus\psi}$}
  \DisplayProof
  %
  \ruleskip
  % oplus L
  \AxiomC{$\hypert \hmid \G,\tj{x}{\phi}\tr\tj{u}{\theta}\hmid
  \G,\tj{y}{\psi}\tr\tj{v}{\theta}$}
  \LL{$\oplus$L}
  \UnaryInfC{$\hypert\hmid\G,\tj{z}{\phi\oplus\psi}\tr\tj{\mat{z}{x}{u}{y}{v}}{\theta}$}
  \DisplayProof
  %
  \ruleskip
  % !R
  \AxiomC{$\bang\hypert\hmid\bang\G\tr\tj{t}{\phi}$}
  \LL{$\bang$R}
  \UnaryInfC{$\bang\hypert\hmid\bang\G\tr\tj{\bang t}{\bang \phi}$}
  \DisplayProof
  where $\bang\hypert$ contains only components typed $\bang\D\tr \bang\psi$.
  %
  \ruleskip
  % dereliction
  \AxiomC{$\hypert\hmid\G,\tj{x}{\phi}\tr\tj{t}{\psi}$}
  \LL{Dereliction}
  \UnaryInfC{$\hypert\hmid\G,\tj{z}{\bang\phi}\tr\tj{\letin{z}{\bang x}{t}}{\psi}$}
  \DisplayProof
  %
  \ruleskip
  % contraction
  \AxiomC{$\hypert\hmid\G,\tj{x}{\bang\phi},\tj{y}{\bang\phi}\tr\tj{t}{\psi}$}
  \LL{Contraction}
  \UnaryInfC{$\hypert\hmid\G,\tj{z}{\bang\phi}\tr\tj{\letin{z}{x@y}{t}}{\psi}$}
  \DisplayProof
  %
  \ruleskip
  % weakening
  \AxiomC{$\hypert\hmid\G\tr\tj{t}{\psi}$}
  \LL{Weakening}
  \UnaryInfC{$\hypert\hmid\G,\tj{z}{\bang\phi}\tr\tj{\letin{z}{\_}{t}}{\psi}$}
  \DisplayProof
  %
  \ruleskip
  % forall R
  \AxiomC{$\hypert\hmid\G\tr\tj{t}{\phi}$}
  \LL{$\forall$R}
  \UnaryInfC{$\hypert\hmid\G\tr\tj{t}{\forall X.\phi}$}
  \DisplayProof (No free $X$ appears in $\G$ or $\hypert$)
  %
  \hfill
  % forall L
  \AxiomC{$\hypert\hmid\G,\tj{x}{\phi[\psi/X]}\tr\tj{t}{\phi}$}
  \LL{$\forall$L}
  \UnaryInfC{$\hypert\hmid\G,\tj{x}{\forall X.\phi}\tr\tj{t}{\phi}$}
  \DisplayProof
  %
  \ruleskip
  %
  \caption{Most rules are taken from Abramsky~\citep{abramsky1993computational}.
  The Sync rule is original.   $\with$R only
  applicable to singleton hypersequents.}
  \label{fig:exchange:rules}
 \end{figure}
For example,
the formula $(\phi\limp\psi)\otimes(\psi\limp\phi)$ is realized by
the following derivation.
 \begin{center}
  \AxiomC{}
  \UnaryInfC{$\tj{x}{\phi}\tr\tj{x}{\phi}$}
  \AxiomC{}
  \UnaryInfC{$\tj{y}{\psi}\tr\tj{y}{\psi}$}
  \BinaryInfC{$\tj{x}{\phi}\tr\tj{x}{\phi} \hmid
  \tj{y}{\psi}\tr\tj{y}{\psi}$}
  \UnaryInfC{$ \tj{x}{\phi}\tr\tj{cx}{\psi} \hmid \tj{y}{\psi}
  \tr\tj{\co c y}{\phi}$}
  \UnaryInfC{$ \tr\tj{\lambda x.cx}{\phi\limp\psi} \hmid \tj{y}{\psi}
  \tr\tj{\co c y}{\phi}$}
  \UnaryInfC{$ \tr\tj{\lambda x.cx}{\phi\limp\psi} \hmid
  \tr\tj{\lambda y.\co c y}{\phi\limp\phi}$}
  \UnaryInfC{$ \tr\tj{{(\lambda x.cx) \otimes (\lambda y.\co c
  y)}}{(\phi\limp\psi)\otimes(\phi\limp\phi)}$}
  \DisplayProof
 \end{center}
Another example shows how we can type the term $\co c(c x)$.
 \begin{center}
\AxiomC{$\tj{x}{\phi}\tr\tj{x}{\phi}$}
\AxiomC{$\tj{y}{\psi}\tr\tj{y}{\psi}$}
\BinaryInfC{$\tj{x}{\phi}\tr\tj{x}{\phi} \hmid
\tj{y}{\psi}\tr\tj{y}{\psi} $}
\UnaryInfC{
$\tj{x}{\phi}\tr\tj{cx}{\psi} \hmid
\tj{y}{\psi}\tr\tj{\co cy}{\phi} $
}
\LL{(Cut)}
\UnaryInfC{
$\tj{x}{\phi}\tr\tj{\co c(cx)}{\phi}$
}
\DisplayProof
 \end{center}

\subsection{Evaluation Relation}

The set of canonical forms remains the same as Abramsky's
LF~\citep{abramsky1993computational}:
\[
 \lpair{t,u}\qquad \bang t\qquad \ast\qquad v\otimes w\qquad \lambda
 x.t\qquad \inl{v}\qquad\inr{w}
\]
where $v$ and $w$ are canonical forms.

An evaluation hypersequent $\hypere$ is defined by the following
grammar:
\[
 \hypere ::= t\eval t\mid (\hypere\hmid \hypere)
\]

Now we define evaluation as a set of evaluation hypersequents
(Figure~\ref{fig:eval}).
Most rules are similar to those of Abramsky's
LF~\citep{abramsky1993computational}.
We add the semantics for channels.

For some reasons, we have to evaluate the subterm~$s$ in $\lambda
x.t[s/y]$ if $s$ is closed while Abramsky never evaluated
anything inside lambda.
In order to keep track of that, we annotate the $\eval$ relation with
involved free variables~$S$.

 \begin{proposition}
  If evaluation hypersequent $\hypere\hmid t\eval_S v$
  is derivable, $S$ is identical to the set of free variables of $t$.
 \end{proposition}

 \begin{figure}
  \centering
  % ast
  \AxiomC{}
  \UnaryInfC{$\ast\eval_\emptyset \ast$}
  \DisplayProof
  \hfill
  \AxiomC{}
  \UnaryInfC{$x\eval_{\{x\}} x$}
  \DisplayProof
  \hfill
  % ast elim
  \AxiomC{$\hypere\hmid t\eval_\emptyset \ast \hmid u\eval_S v$}
  \UnaryInfC{$\hypere\hmid \ign t u\eval_S v$}
  \DisplayProof
  \hfill
  % otimes
  \AxiomC{$\hypere\hmid t\eval_S v\hmid u\eval_{S'} w$}
  \UnaryInfC{$\hypere\hmid t\otimes u\eval_{S\sqcup S'} v\otimes w$}
  \DisplayProof
  \ruleskip
  % ign_not yet
  \AxiomC{$\hypere\hmid t\eval_S t'\hmid u\eval_{S'} u'$}
  \UnaryInfC{$\hypere\hmid \ign t u \eval_{S\sqcup S'} \ign{t'}{u'}$}
  \DisplayProof
  \hfill
  % otimes elim
  \AxiomC{$\hypere\hmid t\eval_\emptyset v\otimes w\hmid u[v/x,w/y]\eval_{S} v'$}
  \UnaryInfC{$\hypere\hmid \letin t {x\otimes y} u \eval_{S} v'$}
  \DisplayProof
  \ruleskip
  \AxiomC{$\hypere\hmid t\eval_S {t'}\hmid u\eval_{S'\sqcup\{x,y\}} {u'}$}
  \UnaryInfC{$\hypere\hmid \letin t {x\otimes y} u \eval_{S\sqcup S'} \letin {t'}
  {x\otimes y} {u'}$}
  \DisplayProof if $S$ is not empty
  \ruleskip
  \AxiomC{$\hypere$}
  \AxiomC{$\hypere'$}
  \BinaryInfC{$\hypere\hmid \hypere'$}
  \DisplayProof
  \hfill
  \AxiomC{$\hypere\hmid t\eval_{S\sqcup \{x\}} t'$}
  \UnaryInfC{$\hypere\hmid \lambda x.t\eval_{S} \lambda x.t'$}
  \DisplayProof
  \hfill
  \AxiomC{$\hypere\hmid t\eval_\emptyset \lambda x.t'\hmid u\eval_\emptyset v\hmid
  t'[v/x]\eval_{S} w$}
  \UnaryInfC{$\hypere\hmid tu\eval_{S} w$}
  \DisplayProof
  \ruleskip
  \AxiomC{$\hypere\hmid t\eval_S t'\hmid u\eval_{S'} u'$}
  \UnaryInfC{$\hypere\hmid tu\eval_{S\sqcup S'} t'u'$}
  \DisplayProof when $S\sqcup S'$ is nonempty
  \hfill
  \AxiomC{$\hypere\hmid t\eval_{\emptyset} v\hmid u\eval_{\emptyset} w$}
  \UnaryInfC{$\hypere\hmid ct\eval_{\emptyset} w\hmid \co cu\eval_{\emptyset} v$}
  \DisplayProof
  \ruleskip
  \AxiomC{$t\eval_S t'$}
  \AxiomC{$u\eval_{S'} u'$}
  \BinaryInfC{$
  \hypere\hmid\lpair{t, u}\eval_{S\sqcup S'}
  \hypere\hmid\lpair{t', u'}$}
  \DisplayProof when $S\sqcup S'$ is not empty
  \hfill
  \AxiomC{   $\hypere\hmid t\eval_S t'\hmid s\eval_{S'} s'\hmid
  \hypere'$}
  \LL{ex}
  \UnaryInfC{$\hypere\hmid s\eval_{S'} s'\hmid t\eval_S t'\hmid \hypere'$}
  \DisplayProof
  \ruleskip
  \AxiomC{$\hypere\hmid
  t\eval_\emptyset\lpair{t_0,t_1}\hmid t_0\eval_\emptyset v_0
  \hmid  u[v_0/x]\eval_\emptyset w$}
  \UnaryInfC{$\hypere \hmid
  \letin t {\lpair{x,\_}} u\eval_\emptyset w$}
  \DisplayProof
  \ruleskip
  \AxiomC{$\hypere
  \hmid t\eval_S t'
  \hmid  u\eval_{S'\sqcup \{x\}} u'$}
  \UnaryInfC{$\hypere \hmid
  \letin t {\lpair{x,\_}} u\eval_{S\sqcup S'}
  \letin {t'} {\lpair{x,\_}} {u'}
  $}
  \DisplayProof when $S\sqcup S'$ is not empty
  \ruleskip
  \AxiomC{$\hypere
  \hmid t\eval_\emptyset\lpair{t_0,t_1}\hmid t_1\eval_\emptyset v_1
  \hmid  u[v_1/y]\eval_\emptyset w$}
  \UnaryInfC{$\hypere \hmid
  \letin t {\lpair{\_,y}} u\eval_\emptyset w$}
  \DisplayProof
  \ruleskip
  \AxiomC{$\hypere
  \hmid t\eval_S t'
  \hmid  u\eval_{S'\sqcup \{y\}} u'$}
  \UnaryInfC{$\hypere \hmid
  \letin t {\lpair{\_,y}} u\eval_{S\sqcup S'}
  \letin {t'} {\lpair{\_,y}} {u'}
  $}
  \DisplayProof
  when $S\sqcup S'$ is not empty
  \ruleskip
    % additive or intro
  \AxiomC{$\hypere\hmid t\eval_S v$}
  \UnaryInfC{$\hypere\hmid \inl{t}\eval_S \inl{v}$}
  \DisplayProof
  \hfill
  \AxiomC{$\hypere\hmid u\eval_S w$}
  \UnaryInfC{$\hypere \hmid \inr{u}\eval_S \inr{w}$}
  \DisplayProof
  \ruleskip
  % additive or elim
  \AxiomC{$\hypere\hmid t\eval_\emptyset \inl{v}\hmid u[v/x]\eval_\emptyset w$}
  \UnaryInfC{$\hypere\hmid \mat t x u y {u'}\eval_\emptyset w$}
  \DisplayProof
  \hfill
  \AxiomC{$\hypere\hmid t\eval_\emptyset \inr{v}\hmid u'[v/y]\eval_\emptyset w$}
  \UnaryInfC{$\hypere\hmid \mat t x u y {u'}\eval_\emptyset w$}
  \DisplayProof
  \ruleskip
  \AxiomC{$\hypere\hmid t\eval_S t'\hmid u\eval_{S'\sqcup \{x\}} u'$}
  \AxiomC{$\hypere\hmid t\eval_S t'\hmid s\eval_{S'\sqcup \{y\}} s'$}
  \BinaryInfC{$\hypere\hmid \mat t x u y s\eval_{S\sqcup S'} \mat {t'} x {u'} y {s'}$}
  \DisplayProof \\ when $S$ is nonempty
  \ruleskip
  \AxiomC{$t\eval_S t'$}
  \UnaryInfC{$\bang t\eval_S \bang t'$}
  \DisplayProof
  \hfill
  \AxiomC{$\hypere\hmid t\eval_\emptyset \bang v\hmid u[v/x]\eval_\emptyset w$}
  \UnaryInfC{$\hypere \hmid \letin t {\bang x} u\eval_\emptyset w$}
  \DisplayProof
  \hfill
  \AxiomC{$\hypere\hmid t\eval_\emptyset \bang s\hmid u\eval_S v$}
  \UnaryInfC{$\hypere \hmid \letin t {\_} u\eval_S v$}
  \DisplayProof
  \ruleskip
  \AxiomC{$\hypere\hmid t\eval_\emptyset \bang s\hmid u[\bang s/x,\bang
  s/y]\eval_S v$}
  \UnaryInfC{$\hypere\hmid\letin t {x@y} u\eval_S v$}
  \DisplayProof
  \hfill
  \AxiomC{$\hypere\hmid t\eval_S t'\hmid u\eval_{BV(p)} u'$}
  \UnaryInfC{$\hypere\hmid\letin t p u\eval_{S\sqcup S'} \letin {t'} p {u'}$}
  \DisplayProof \\
  \fix{define BV}
  \ruleskip
  \AxiomC{$\hypere\hmid t[w/x]\eval_\emptyset w\hmid u\eval_S v$}
  \LL{nested-channel}
  \UnaryInfC{$\hypere\hmid ct[\co c u/x]\eval_S v$}
  \DisplayProof

  \caption{The definition of evaluation relation.
  $\hypere$ is possibly empty evaluation hypersequence.
  The subscripts~$\bullet$ of $\eval_\bullet$ is introduced for keeping
  determinacy while
  having eval-subst rule (\thref{eval-subst}) admissible.
  The whole system is based on Abramsky's LF
  \citep{abramsky1993computational}, but differently from it,
  we evaluate closed subterms even when they are in the scope of $\lambda$.
  }
  \label{fig:eval}
 \end{figure}

 \fix{add a proposition saying we can move a rule application upwards
 relative to a component
 unless it is a sync rule with that component}
 \fix{this is why the rule sync is named after synchronization}

 \begin{lemma}
   \label{eval-subst}
  \AxiomC{$\hypere\hmid t\eval_\emptyset v\hmid u[v/x]\eval_\emptyset w$}
  \LL{eval-subst}
  \UnaryInfC{$ \hypere\hmid u[t/x] \eval_\emptyset w $}
  \DisplayProof
   is admissible.
 \end{lemma}
 \begin{proof}
  By induction on the height of derivation, but we classify the
  situation by the form of $u$.
  \begin{description}
   \item[($u$ is $x$)]
	Since $\hypere\hmid t\eval_\emptyset v\hmid v\eval_\emptyset w$
	is derivable, $w$ must be identical to $v$.
	Also, since canonical form~$v$ does not contain channels,
	$\hypere\hmid t\eval_\emptyset v$ is derivable and so is
	$\hypere\hmid t\eval_\emptyset w$.
   \item[($u$ is $cu'$)]
	$\hypere\hmid t\eval v\hmid cu'[v/x]\eval w$ \fix{annotate eval}
	is derivable.  If the last rule touches components in $\hypere$,
	our statement follows from the induction hypothesis.
	If the last rule touches $t$ but $t$ is not $\co c t'$, then
	we can still use the induction hypothesis\fix{why?}.
	Otherwise, when the last rule introduces the channel pair $c,\co c$,
	there are three possibilities for how the pair
	$c, \co c$ is introduced.
	\begin{description}
	 \item[(with $\hypere$)]
	       \begin{center}
		\AxiomC{$\hypere\hmid s\eval w\hmid t\eval v\hmid
		u'[v/x]\eval w'$}
		\UnaryInfC{$\hypere \hmid \co c s\eval w'\hmid t\eval v
		\hmid cu'[v/x]\eval w$}
		\DisplayProof
	       \end{center}
	      By induction hypothesis,
	       \begin{center}
		$\hypere\hmid s\eval w\hmid u'[t/x]\eval w'$
	       \end{center}
	      is derivable so is
	       \begin{center}
		$\hypere\hmid \co c s\eval w'\hmid cu'[t/x]\eval w$\enspace.
	       \end{center}
	 \item[(with $t$)]
	       \begin{center}
		\AxiomC{$\hypere\hmid t'\eval w\hmid u'[v/x]\eval v$}
		\UnaryInfC{$\hypere \hmid \co ct'\eval v\hmid
		cu'[v/x]\eval w$}
		\DisplayProof
	       \end{center}
	      By nested-channel, $\hypere\hmid cu'[\co c t'/x]\eval v$
	      is derivable.
	 \item[(with $u'$)]
	       \begin{center}
		\AxiomC{$\hypere\hmid t\eval v\hmid
		u''[w'/y]\eval_\emptyset w'\hmid u'''[v/x]\eval w$}
		\UnaryInfC{$\hypere\hmid t\eval v\hmid cu''[\co
		cu'''[v/x]/y]\eval w$}
		\DisplayProof
	       \end{center}
	      By induction hypothesis,
	      $\hypere\hmid u''[w'/y]\eval_\emptyset w'\hmid
	      u'''[t/x]\eval w$
	      is derivable and so is
	      $\hypere\hmid cu''[\co cu'''[t/x]/y]\eval w$.
	      \fix{annotate eval}
	\end{description}
   \item[other] \fix{fill}
  \end{description}
 \end{proof}

\begin{example}
 \label{inner-something}
 The rule eval-subst in \thref{eval-subst} is not in Abramsky's
 LF~\citep{abramsky1993computational}.  However, it is necessary to give
 the following evaluation.
  \begin{center}
   \AxiomC{}
   \UnaryInfC{$\ast\eval\ast$}
   \AxiomC{$t\eval v$}
   \BinaryInfC{$\ast\eval\ast\hmid t\eval v$}
   \UnaryInfC{$c\ast\eval\ast\hmid \co ct\eval v$}
   \LL{eval-subst}
   \UnaryInfC{$\co c(c t)\eval v$}
   \DisplayProof
  \end{center}
\end{example}

\section{Convergence}

Convergence states that if
$\tr\tj t \phi$ is derivable,
there exists a canonical form~$v$ so that $t\eval v$ is derivable.
Since the proof of convergence is inductive over
the typing derivations, we have to generalize the statement.

For that we first assign a set of closed terms to each type.
\newcommand{\terms}{\mathcal{T}}
\fix{use of $v$ is ambiguious...?}
We denote by $\terms$ the set of closed terms.
Given $\semo{X}_0\in 2^\terms$ for each propositional variable~$X$,
we define $\semo{\cdot}\colon \form{2^\terms}\rightarrow {2^\terms}$
as follows:
\begin{align*}
 \semo{\mathcal X} &= \mathcal X\\
 \semo{X} &= \semo{X}_0\\
 \semo{\one} &= \{t\in \terms \mid t\eval \ast\} \\
 \semo{\phi\otimes \psi}&= \{t\in\terms \mid t\eval v\otimes w,\quad
 v\in\semo{\phi},\quad w\in \semo{\psi}\}\\
 \semo{\phi\limp\psi}&= \{t\in\terms \mid t\eval \lambda x.v,\quad
 \forall u\in\semo{\phi}.(tu\in\semo{\psi})\}\\
 \semo{\phi\with\psi}&= \{t\in\terms \mid t\eval\lpair{v,w},\quad
 v\in\semo{\phi}, w\in\semo{\psi}\}\\
 \semo{\phi\oplus\psi}&= \{t\in\terms\mid (t\eval \inl{v}, v\in
 \semo{\phi})\text{ or }(t\eval\inr{w}, w \in \semo{\psi})\}\\
 \semo{\bang \phi}&= \{t\in\terms \mid t\eval \bang u, \quad u\in\semo{\phi}\}\\
 \semo{\forall X.\phi}&= \bigcap\{\semo{\phi[\mathcal X/X]}\mid \psi\in
 2^\terms\}\enspace.
\end{align*}

For a context~$\G = \tj{x_0}{\phi_0},\ldots,\tj{x_n}{\phi_n}$,
$\semo{\G}$ denotes the set of sequences $u_0,\ldots,u_n$ of closed terms
such that each $u_i$ is in $\semo{\phi_i}$.
For a sequent $\G\tr\tj{t}{\phi}$, $\semo{\G\tr\tj{t}{\phi}}$ denotes
the set consisting of terms $t[\vec g/G]$ for some $\vec g\in\semo{\G}$.
For a hypersequent with terms $\hypert$,
$\semo\hypert$ is defined in a componentwise way:
$\semo{\hypert\hmid\G\tr\tj t\phi}$ contains any $\hmid$-delimited
sequence of terms
$\vec O \hmid u$ such that $\vec O\in\semo{\hypert}$ and
$u\in\semo{\G\tr\tj t\phi}$.

 \begin{proposition}[General Convergence]
  \label{thm:generalconvergence}
  If
  $\G_0\tr\tj{t_0}{\phi_0}\hmid\cdots\hmid \G_n\tr\tj{t_n}{\phi_n}$
  is derivable,
  for any $(\vec{u^i}) \in \semo{\G_i}$ for ${0\le i \le n}$,
  there exist canonical forms $(v_i\in\semo{\phi_i})_{0\le i\le n}$ so
  that $t_0[\vec{u^0}/ \G_0]\eval_\emptyset v_0\hmid\cdots\hmid
  t_n[\vec{u^n}/\G_n]\eval_\emptyset v_n$ is derivable.
 \end{proposition}
  \begin{proof}
   By induction on the type derivation.  We use $\eval$ for $\eval_\emptyset$.
   \begin{description}
    \item[(IE)]
	 Since terms in $\semo{\phi}$ or $\semo{\psi}$ do not contain
	 free variables.
    \item[($\limp$L)] The derivation ends as
    \begin{center}
     \AxiomC{$\hypert\hmid \G\tr\tj{t}{\phi}\hmid \tj{x}{\psi},
     \D\tr\tj{u}{\theta}$}
     \UnaryInfC{$\hypert\hmid
     \G,\tj{f}{\phi\limp\psi},\D\tr\tj{u[(ft)/x]}{\theta}$}
     \DisplayProof\enspace.
    \end{center}
    Take any $O\in\semo{\hypert}$, $\vec g\in\semo{\G}$, $\vec
    d\in\semo{\D}$ and $v\in\semo{\phi\limp\psi}$.
    By induction hypothesis,
    \[
    \hypert\eval \vec{w'}\hmid t[\vec g/\G]\eval
    w_0\hmid u[w/x][\vec d/\D]\eval w
    \]
    is derivable for any $w \in \semo{\psi}$.
    Since $w_0$ is in $\semo{\phi}$ and $v$ is in
    $\semo{\phi\limp\psi}$,
    $fw_0$ is in $\semo\psi$.
    Thus,
    \[
    \hypert\eval\vec{w'}\hmid t[\vec g/\G]\eval w_0\hmid
    u[(vw_0)/x][\vec d/\D]\eval w_1
    \]
    is derivable.
    The last term $u[(vw_0)/x][\vec d/\D]$ is identical to
    $u[vy/x][w_0/y][\vec d/\D]$.
    Thus, by rule subst-eval in \thref{eval-subst},
    \[
    \hypert\eval\vec{w'}\hmid u[fy/x][t/y][\vec d/\D]\eval w_1
    \]
    is derivable.
    \item[(Cut)] Essentically the same as and simpler than ($\limp$L).
    \item[(Sync)]
	 The derivation ends as
	 \AxiomC{$\hypert\hmid \G\tr\tj{t}{\phi}\hmid \D\tr\tj{u}{\psi}$}
	 \UnaryInfC{$\hypert\hmid \G\tr\tj{ct}{\psi}\hmid \D\tr\tj{\co
	 cu}{\phi}$}
	 \DisplayProof\enspace.
	 Take any $O\in\semo{\hypert}$, $\vec g\in \semo{\G}$ and $\vec
	 d\in\semo{\D}$.
	 By induction hypothesis, the hyper evaluation
	 \[
	 O\eval \vec{v'}\hmid t[\vec g/\G] \eval v\hmid u[\vec
	 d/\D]\eval w
	 \]
	 is derivable.
	 Thus,
	 \[
	 O\eval \vec{v'}\hmid (ct)[\vec g/\G] \eval w\hmid (\co cu)[\vec
	 d/\D]\eval v
	 \]
	 is also derivable.
    \item[($\otimes$L)]
	 The derivation ends as
	  \begin{center}
	   \AxiomC{$\hypert\hmid\G,\tj{x}{\phi},\tj{y}{\psi}\tr\tj{t}\theta$}
	   \UnaryInfC{$\hypert\hmid\G,\tj{z}{\phi\otimes
	   \psi}\tr\tj{\letin z {x\otimes y} t}{\theta}$}
	   \DisplayProof
	  \end{center}
	 Take any $v\in \semo{\phi\otimes\psi}$, $\vec g\in \semo{\G}$
	 and $\vec O\in\semo{\hypert}$.
	 By definition of $\semo{\phi\otimes\psi}$,
	 $v\eval v_0\otimes v_1$ is derivable for some
	 $v_0\in\semo{\phi}$
	 and $v_1\in\semo{\psi}$.
	 By induction hypothesis,
	 \[
	  \vec{O}\eval\vec{o}\hmid t[\vec g/\G][v_0/x][v_1/y]\eval w
	 \]
	 is derivable for some $\vec o$ and $w\in\semo{\theta}$.
	 Since
	 \[
	  \vec O\eval \vec o\hmid v\eval v_0\otimes v_1\hmid
	 t[\vec g/\G][v_0/x][v_1/y]\eval w
	 \]
	 is derivable, so is
	 \[
	  \vec O\eval \vec o \hmid (\letin z {x\otimes y} t)[\vec
	 g/\G][v/z] \eval w\enspace.
	 \]
    \item[(Dereliction)]
	 The derivation ends as
	  \begin{center}
	   \AxiomC{$\hypert\hmid\G,\tj{x}{\phi}\tr\tj{t}{\psi}$}
	   \UnaryInfC{$\hypert\hmid\G,\tj{z}{\bang\phi}\tr\tj{\letin z
	   {\bang x} t}\psi$}
	   \DisplayProof\enspace.
	  \end{center}
	 Take any $u\in\semo{\bang\phi}$, $\vec g\in\semo\G$ and $\vec
	 O\in\semo\hypert$.
	 By definition of $\semo{\bang\phi}$,
	 $u\eval\bang v$ is derivable for some $v\in\semo{\phi}$.
	 By induction hypothesis, 
	 \[
	 \vec O\eval \vec o\hmid t[v/x][\vec g/\G]\eval w
	 \]
	 is derivable for some $\vec o$ and $w\in\semo{\psi}$.
	 Since
	 \[
	  \vec O\eval \vec o\hmid u\eval \bang v\hmid t[v/x][\vec
	 g/\G]\eval w
	 \]
	 is derivable, so is
	 \[
	  \vec O\eval \vec o \hmid
	 (\letin z {\bang x} t)[\vec g/\G][u/z] \eval w\enspace.
	 \]
    \item[(Contraction)]
	 The derivation ends as
	 \begin{center}
	  \AxiomC{$\hypert\hmid\G,\tj{x}{\bang \phi},\tj{y}{\bang \phi}\tr\tj{t}{\psi}$}
	  \UnaryInfC{$\hypert\hmid \G,\tj{z}{\bang\phi}\tr\tj{\letin z
	  {x@y} t}{\psi}$}
	  \DisplayProof
	 \end{center}
	 Take any $O\in\semo{\hypert}$, $\vec{g}\in\semo{\G}$ and
	 $u\in\semo{\bang\phi}$.
	 Since $u$ is in $\semo{\bang\phi}$, there exists a term $u'$ in
	 $\semo{\phi}$
	 where $u\eval \bang u'$.
	 Moreover, by induction hypothesis,
	 \[
	 \hypert\eval\vec{o}\hmid t[\vec g/\G][\bang u'/x][\bang u'/y]\eval t'
	 \]
	 is derivable for some $\vec{o}$ and $t'\in\semo{\psi}$.
	 By merge,
	 \[
	 \hypert\eval\vec{o}\hmid t[\vec g/\G][\bang u'/x][\bang u'/y]\eval
	 t'\hmid u\eval \bang u'
	 \]
	 is derivable and then
	 \[
	 \hypert\eval\vec{o}\hmid
	 (\letin{z}{x@y}{t})[\vec g/\G][\bang u'/z]\eval t'
	 \]
	 is also derivable.
    \item[($\with$L$_0$)]
	 The derivation ends in
	 \begin{center}
	  \AxiomC{$\hypert\hmid\G,\tj{x}{\phi}\tr\tj{t}{\theta}$}
	  \UnaryInfC{$\hypert\hmid\G,\tj{z}{\phi\with\psi}\tr\tj{
	  \letin z {\lpair{x,\_}} t
	  }{\theta}$}
	  \DisplayProof
	 \end{center}
	 Take any $\vec g\in\semo{\G}$, $s\in\semo{\phi\with\psi}$
	 and $O\in\semo{\hypert}$
	 By definition of $s$, $s\eval \lpair{v_0,v_1}$ is derivaboe
	 for some
	 $v_0\in\semo{\phi}$ and $v_1\in\semo{\psi}$.
	 By induction hypothesis,
	 \[
	 O\eval \vec{o} \hmid t[\vec g/\G][v_0/x]\eval w
	 \]
	 is derivable for some $\vec o$ and $w\in\semo{\theta}$.
	 Thus,
	 \[
	 O\eval \vec o\hmid \letin z {\lpair{x,\_}} t \eval w
	 \]
	 is also derivable.
    \item[($\with$L$_1$)] Symmetric to above.
    \item[($\with$R)]
	 The derivation ends as
	 \begin{center}
	  \AxiomC{$\G\tr\tj{t}{\phi}$}
	  \AxiomC{$\G\tr\tj{u}{\psi}$}
	  \BinaryInfC{$\G\tr\tj{\lpair{t,u}}{\phi\with\psi}$}
	  \DisplayProof
	 \end{center}
	 By induction hypothesis,
	 $t[\vec g/\G]\eval v$ and
	 $u[\vec g/\G]\eval w$
	 are derivable for some
	 $v\in\semo{\phi}$ and $w\in\semo{\psi}$.
	 Thus, $t[\vec g/\G]\in\semo{\phi}$ and
	 $u[\vec g/\G]\in\semo{\psi}$ hold.
	 We now conclude $\lpair{t,u}[\vec g/\G]$ is in
	 $\semo{\phi\with\psi}$ because
	 \[
	 \lpair{t,u}[\vec g/\G]\eval \lpair{t,u}[\vec g/\G]
	 \]
	 is derivable.
    \item[($\forall$R)]
	 Since the induction hypothesis holds regardless of $\semo{X}_0$.
    \item[Other rules]
	 Other cases are immediate.
   \end{description}
  \end{proof}

   \begin{corollary}[Convergence]
    \label{convergence}
    If $\tr\tj{t}{\phi}$ is derivable,
    $t\eval_{\emptyset} v$ is derivable for some canonical form~$v$.
   \end{corollary}

   \begin{corollary}[Consistency of \fix{name of logic}]
    $\tr\tj{t}{\forall X.X}$ is not derivable for any term~$t$.
   \end{corollary}
    \begin{proof}
     Assume $\tr\tj{t}{\forall X.X}$ is derivable.
     Then, by \thref{thm:generalconvergence},
     $t\eval t'$ is derivable for some $t'$ in $\semo{\forall X.X}$.
     However, $\semo{\forall X.X}$ is empty.
    \end{proof}

    \subsection{Determinacy}

    A sequence of terms $(t_i)_{0\le i \le n}$ is well-formed iff both
    of these conditions are met:
    \begin{itemize}
     \item if a channel~$c$ appears in any of $t_i$,
	   each of $c$ and $\bar c$ appears only once in $(t_i)_{0\le i
	   \le n}$,
     \item if any $t_i$ contains a subterm of the form $ct[\bar cu/x]$,
	   then, $t$ contains no channels.
    \end{itemize}
    The first condition is natural while the second is rather
    cumbersome so that we hope to remove the second condition in the
    future.

    \begin{proposition}
     \label{remove-local}
     If $\hypere\hmid \hypere'$ is derivable and $\hypere'$ does not contain
     containing any channels, $\hypere$ and $\hypere'$ are separately derivable.
    \end{proposition}
    \begin{proof}
     \fix{prove}
    \end{proof}

    \begin{proposition}
     For a well-formed sequence of terms
     $(t_i)_{0\le i\le n}$,
     there exist a unique (if any) sequence of terms $(v_i)_{0\le i \le
     n}$ and a unique (if any) sequence of sets of variables
     $(S_i)_{0\le i \le n}$ such that
     \[
     t_0\eval_{S_0} v_0\hmid \cdots \hmid t_n\eval_{S_n} v_n
     \]
     is derivable.
    \end{proposition}
    \begin{proof}
     First, by induction on evaluation derivation,
     $S_i$ must be identical to the set of free variables in $t_i$.
     Second, all rules of evaluation relation derivations except
     nested-channel and ex (in Figure~\ref{fig:eval})
     have distinct conclusions so that
     the conclusion can determine the last rule
     applied up to the choice of the last-generated component.
     Now we have three things to consider.
     \begin{enumerate}
      \item ex rule can be disregarded if we consider
	    a hypersequent as a finite set of components rather than
	    a finite sequence of components,
      \item In the nested-channel rule application,
	    we cannot immediately determine $w$:
	     \begin{center}
  \AxiomC{$\hypere\hmid t[w/x]\eval_\emptyset w\hmid u\eval_S v$}
  \LL{nested-channel}
  \UnaryInfC{$\hypere\hmid ct[\co c u/x]\eval_S v$}
  \DisplayProof
	     \end{center}
	    because $w$ is contained in both sides of $\eval$.
	    However, by well-formedness, $t$ does not contain channels.
	    Thus, by \thref{remove-local}, a simpler evaluation
	    hypersequent $\hypere
	    \hmid u\eval_S v$ is derivable so that we can determine $v$
	    from induction hypothesis.
      \item From bottom to up, we can choose components in different
	    orders.
	    For example, we have different derivations for the same
	    conclusion as
	     \begin{center}
	      \AxiomC{$v\eval v\hmid \inr w\eval \inr w$}
	      \UnaryInfC{$\inl v\eval \inl v\hmid \inr w\eval \inr w$}
	      \DisplayProof
	     \end{center}
	    and
	     \begin{center}
	      \AxiomC{$\inl v\eval \inl v\hmid w\eval w$}
	      \UnaryInfC{$\inl v\eval \inl v \hmid \inr w\eval \inr w$}
	      \DisplayProof\enspace.
	     \end{center}
	    However, such choices are locally confluent because
	    the only rule touching more than two components
	    in the conclusion is
	     \begin{center}
	      \AxiomC{$\hypere\hmid t\eval_{\emptyset} v\hmid u\eval_{\emptyset} w$}
	      \UnaryInfC{$\hypere\hmid ct\eval_{\emptyset} w\hmid \co cu\eval_{\emptyset} v$}
	      \DisplayProof
	     \end{center}
	    but neither $c$ or $\co c$ appears in $\hypere$ due to well-formedness.
     \end{enumerate}
    \end{proof}

    \begin{corollary}
     If $t\eval_\emptyset v$ and $t\eval_\emptyset w$ are derivable,
     $v$ and $w$ are the same.
    \end{corollary}

    \section{Sessions and Processes}

    \subsection{Session Types as Abbreviations}

    As an abbreviation, we introduce \textit{session
    types}\index{type!session}\index{session type|see{type}}.
    Instead of the standard notation $\bang\phi.\psi$, we use
    $\sendtype{\phi}{\psi}$ in order to avoid the confusion with
    $\bang\phi$.
    For symmetry, we use $\recvtype{\phi}\psi$ instead of $?\phi.\psi$.
    The definitions and the descriptions are modification from
    \citet{wadler2012propositions}'s translations and descriptions.
    \begin{align*}
     \sendtype\phi\psi&\equiv \phi\limp\psi &\text{type of a channel for
     outputting value of type $\phi$ then behave as $\psi$} \\
     \recvtype\phi\psi&\equiv \phi\otimes\psi &\text{type of a channel
     for inputting value of type $\phi$ then behave as $\psi$}\\
     \oplus\{l_i\colon \phi_i\}_{i\in I} &\equiv {\phi_0}\with
     \cdots \with {\phi_n}, \quad I = \{0,\ldots,n\} & \text{select from behaviours
     $\phi_i$ with label $l_i$}\\
     \with\{l_i\colon \phi_i\}_{i\in I} &\equiv {\phi_0}\oplus
     \cdots \oplus {\phi_n}, \quad I = \{0,\ldots,n\}& \text{offer choice of
     behaviours $\phi_i$ with label $l_i$}
     \\
     \terminate &\equiv \one &\text{terminator}
    \end{align*}
    where $I$ is a finite downward-closed set of natural numbers like
    $\{0,1,2,3\}$.


    The grammar
    \[
     \phi,\psi ::= \terminate\mid X \mid \sendtype\phi\psi \mid
     \recvtype\phi\psi
     \mid \oplus\{l_i\colon\phi_i\}_{i\in I}
     \mid \with\{l_i\colon\phi_i\}_{i\in I}
     \mid \bang\phi
    \]
    covers all types.

    A linear type ($\phi^\ell$ possibly with subscript) is generated by
    this grammar:
    \[
     \phi^\ell ::= \terminate\mid
     \sendtype{\psi}{\phi^\ell} \mid
     \recvtype{\psi}{\phi^\ell}
     \mid \oplus\{l_i\colon\phi^\ell_i\}_{i\in I}
     \mid \with\{l_i\colon\phi^\ell_i\}_{i\in I}
    \]

    We define duals of linear types.
    Again the definition is almost the
    same as \citet{wadler2012propositions}'s except that $\terminate$ is
    self-dual.
    \begin{align*}
     \overline{\sendtype\psi{\phi^\ell}}&= \,\recvtype\psi{\overline{\phi^\ell}}\\
     \overline{\recvtype\psi{\phi^\ell}}&= \,\sendtype\psi{\overline{\phi^\ell}}\\
     \overline{\oplus\{l_i\colon \phi^\ell_i\}_{i\in I}} &=
     \with\{l_i\colon \overline{\phi^\ell_i}\}_{i\in I} \\
     \overline{\with\{l_i\colon \phi^\ell_i\}_{i\in I}} &=
     \oplus\{l_i\colon \overline{\phi^\ell_i}\}_{i\in I} \\
     \overline{\terminate} &= \terminate\enspace.
    \end{align*}
    \fix{see other literature as well for the definition of session
    types}

    \subsection{Processes as Abbreviations}

    \subsubsection{Process Abrreviations}
    We define the sending and receiving as abbreviations:
    \begin{align*}
     \sendterm x u t &\equiv t[(xu) /x] &\text{send $u$ through channel
     $x$ and then use $x$ in $t$} \\
     \recvterm x y t &\equiv \letin x {y\otimes x} t & \text{receive
     $y$ through channel $x$ and use $x$ and $y$ in $t$} \\
     0 &\equiv \ast &\text{do nothing}
    \end{align*}
    We have to be careful about substitution combined with process
    abbreviations.
    For example, $(\sendterm x u t)[s/x]$ is not $\sendterm s u t$
    because the later is not defined.  Following the definition,
    $(\sendterm x u t)[s/x]$ is actually $(t[xu/x])[s/x] = t[su/x]$.
    We are going to introduce the name restriction $\nu x.t$ after
    implementing channels.

    \subsubsection{Typing Rules for Process Abbreviations}
    The session type abbreviation and the processes abbreviation are
    consistent as the next proposition shows.
     \begin{proposition}
      \label{typing_process}
      These rules are admissible.
       \begin{center}
      \AxiomC{$\hypert\hmid\tj{y}{\psi}, \tj{x}{\chi}\tr\tj{t}{\phi}$}
      \UnaryInfC{$\hypert\hmid\tj{x}{\recvtype\psi\chi}\tr\tj{\recvterm x y
      t}{\phi}$}
      \DisplayProof
      \hfill
      \AxiomC{$\hypert\hmid \G,\tj{x}{\chi}\tr\tj{t}{\phi}\hmid \D\tr\tj{u}\psi$}
      \UnaryInfC{$\hypert\hmid \G,\D,\tj{x}{\sendtype
      \psi\chi}\tr\tj{\sendterm x u t}{\phi}$}
      \DisplayProof
      \ruleskip
      \AxiomC{$\hypert\hmid \G\tr\tj{t}{\phi}$}
      \UnaryInfC{$\hypert\hmid \G,\tj{x}{\terminate}\tr\tj{\ign x
      t}{\phi}$}
      \DisplayProof
	\hfill
	\AxiomC{}
	\UnaryInfC{$ \tr\tj 0 \one $}
	\DisplayProof
       \end{center}
     \end{proposition}
     Before entering the proof, we note that the types of $x$ change in
     the rules.  This reflects the intuition of session types: the
     session type of a channel changes after some communication occurs
     through the channel.
      \begin{proof}
       Without abbreviations, the first rule is actually one of the
       original rules:
	\begin{center}
	 \AxiomC{$\hypert\hmid\tj{y}{\psi}, \tj{x}{\chi}\tr\tj{t}{\phi}$}
	 \UnaryInfC{$\hypert\hmid\tj{x}{\psi\otimes\chi}\tr\tj{\letin x
	 {y\otimes x} t}{\phi}$}
	 \DisplayProof\enspace.
	\end{center}
       Without abbreviations, the second rule is also one of the
       original rules:
	\begin{center}
	 \AxiomC{$\hypert\hmid \G,\tj{x}{\chi}\tr\tj{t}{\phi}\hmid \D\tr\tj{u}\psi$}
	 \UnaryInfC{$\hypert\hmid \G,\D,\tj{x}{
      \psi\limp\chi}\tr\tj{t[(xu)/x]}{\phi}$}
	 \DisplayProof\enspace.
	\end{center}
       The third and the fourth rule are more evidently one of the orignal rules.
      \end{proof}

    \begin{example}[Typed communicating terms]
     \label{ex:typed-processes}
     Using \thref{typing_process}, we can type processes.
     Here is one process, which sends a channel $y$ through $x$ and then
     wait for input in a channel~$y'$.
      \begin{center}
       \small
       \AxiomC{}
       \UnaryInfC{$\tj{z}{\two} \tr\tj z \two$}
       \UnaryInfC{$\tj{z}{\two},\tj{y}{\terminate}\tr\tj{\ign y z}\two$}
       \UnaryInfC{$\tj{z}{\two},\tj{x}{\terminate},
       \tj{y}{\terminate}\tr\tj{\ign {x,y} z}\two$}
       \UnaryInfC{$\tj{x}{\terminate},\tj{y}{\recvtype\two\terminate}\tr
       \tj{\recvterm y z
       {\ign {x,y}  z}}{\two}$}
       \AxiomC{}
       \UnaryInfC{$\tj{y'}{\sendtype{\two}{\terminate}}\tr\tj{y'}{\sendtype\two\terminate}$}
       \BinaryInfC{$\tj{y}{\recvtype\two\terminate},\tj{x}{\sendtype{\sendtype
       \two \terminate}\terminate}, \tj{y'}{\sendtype \two
       \terminate}\tr\tj
       {\sendterm x y{\recvterm {y'}z{\ign {x,y} z}}}\two$}
       \DisplayProof
      \end{center}
     Here is another process that takes an input~$w'$ from channel~$x'$, where
     the input $w'$ itself is expected to be a channel.
     After receiving $w'$, the process puts $\inl{\ast}$ in $w'$.
      \begin{center}
       \AxiomC{}
       \UnaryInfC{$\tr\tj\ast\one$}
       \UnaryInfC{$\tj{w'}\terminate\tr\tj{\ign{w'}\ast}\one$}
       \AxiomC{}
       \UnaryInfC{$\tr\tj\ast\one$}
       \UnaryInfC{$\tr\tj{\inl{\ast}}{\two}$}
       \BinaryInfC{$\tj{w'}{\sendtype\two\terminate}\tr\tj{\sendterm{w'}{\inl\ast}{\ign
       {w'}\ast}}{\one}$}
       \UnaryInfC{$\tj{w'}{\sendtype\two\terminate},\tj{x'}\terminate\tr\tj{\ign{x'}{\sendterm{w'}{\inl\ast}{\ign{w'}\ast}}}{\one}$}
       \UnaryInfC{$\tj{x'}{\recvtype{\sendtype\two\terminate}\terminate}\tr\tj{
       \recvterm{x'}{w'}{\ign{x'}{\sendterm{w'}{\inl\ast}{\ign{w'}\ast}}}}\one$}
       \DisplayProof
      \end{center}
     We intend these two processes to communicate when we connect the channels $x$
     and $x'$.
     For that, we have to implement complicated channels as in the
     following subsection.
    \end{example}


    \subsection{Implementing Channels}
    We introduced primitives $\lpair{c,\co c}$ implementing
    $(\one\limp\phi)\otimes(\phi\limp\one)$.
    These can be seen as channels of session types
    $\recvtype\phi\terminate$ and $\sendtype\phi\terminate$.
    Indeed, $\recvtype\phi\terminate$ is $\phi\otimes\one$ (which is
    coerceable to $\one\limp\phi$) and $\sendtype\phi\terminate$ is
    $\phi\limp \one$.
    We can generalize this phenomenon to the more complicated session
    types.
     \begin{theorem}[Session Realizers]
      For any linear type~$\phi^\ell$\kern -2pt, the hypersequent
      $\tr\tj{t}{\phi^\ell}\hmid \tr\tj{u}{\overline{\phi^\ell}}$
      is derivable for some terms $t$ and $u$.
     \end{theorem}
      \begin{proof}
       Induction on $S$.
       \begin{description}
	\item[(end)] \AxiomC{} \UnaryInfC{$\tr\tj\ast\one$}
	     \AxiomC{} \UnaryInfC{$\tr\tj\ast\one$}
	     \BinaryInfC{$\tr\tj\ast\one\hmid\tr\tj\ast\one$}
	     \DisplayProof is what we seek.
	\item[($\sendtype{\psi}{\phi^\ell}$)]
	     By induction hypothesis,
	     $\tr\tj{t'}{\phi^\ell}\hmid \tr \tj{u'}{\overline{\phi^\ell}}$ is
	     derivable.  Using this, we can make the following
	     derivation:
	      \begin{center}
	      \AxiomC{}
	       \UnaryInfC{$\tj{x}{\psi}\tr\tj{x}{\psi}$}
	       \AxiomC{$\tr\tj{t'}{\phi^\ell}\hmid \tr
	       \tj{u'}{\overline{\phi^\ell}}$}
	       \BinaryInfC{$\tj{x}{\psi}\tr\tj{x}{\psi}\hmid
	       \tr\tj{t'}{\phi^\ell}\hmid \tr
	       \tj{u'}{\overline{\phi^\ell}}$}
	       \UnaryInfC{$\tj{x}{\psi}\tr\tj{cx}{\phi^\ell}\hmid
	       \tr\tj{(\co ct')\otimes u'}{\psi\otimes \overline{\phi^\ell}}$}
	       \UnaryInfC{$\tr\tj{\lambda x.cx}{\psi\limp\phi^\ell}\hmid
	       \tr\tj{(\co ct')\otimes u'}{\psi\otimes \overline{\phi^\ell}}$}
	       \DisplayProof\enspace.
	      \end{center}
	\item[($\recvtype\psi\phi$)]
	     Symmetric to above.
	\item[($\oplus\{l_i\colon \phi_i\}$)]
	     By induction hypothesis,
	     for each $i\in I$, we have
	     \[
	      \tr\tj{t_i}{{\phi_i}}\hmid \tr\tj{u_i}{{\overline{\phi_i}}}
	     \]
	     derived.  Hence derivable is
	     \[
	      \tr\tj{t_i}{{\phi_i}}\hmid \tr\tj{i(u_i)}{\oplus_{j\in
	     I}
	     {\overline{\phi_j}}}\enspace.
	     \]
	     Combining $|I|$ such derivations, we can derive
	     \[
	     \tr\tj{\tuple{t_i}_{i\in I}^n}{\with_{i\in I}{\phi_i}}
	     \hmid
	     \tuple{\tr\tj{i(u_i)}{\oplus_{j\in
	     I}{\overline{\phi_j}}}}_{i\in I}^n
	     \]
	     for a fresh natural number~$n$.
	     \fix{define and explain about this form of hypersequents}
	\item[($\with\{l_i\colon \phi_i\}$)]
	     Symmetric to above.
       \end{description}
      \end{proof}
      We call the pair $t,u$ the session realizers of $\phi^\ell$ and
      denote them by $\leftside{\phi^\ell}, \rightside{\phi^\ell}$.
      Moreover, we use $\bothside{\phi^\ell}$ to denote the pair
      $\leftside{\phi^\ell}\otimes\rightside{\phi^\ell}$.
      If have two terms that uses free variables of type $\phi^\ell$ and
      $\overline{\phi^\ell}$,
      we can replace those free variables by session realizers.
       \begin{corollary}
	If
	$\hypert_0\hmid \G,\tj{x}{\phi^\ell}\tr\tj{t}{\psi}$ and
	$\hypert_1\hmid \D,\tj{y}{\overline{\phi^\ell}}\tr\tj{u}{\theta}$
	are derivable,
	\[
	\hypert_0\hmid \G\tr\tj{t[\leftside{\phi^\ell}/ x]}{\psi}
	\hmid \hypert_1\hmid \D\tr\tj{u[\rightside{\phi^\ell}/ y]}{\theta}
	\]
	is also derivable.
       \end{corollary}

       We can define name restriction as an abbreviation:
       \[
	\nu \tj{x}{\phi^\ell}. t \equiv
	\letin{\bothside{\phi^\ell}}{x_L\otimes x_R} t\enspace.
       \]

       Then, in addition to \thref{typing_process},
       more typing rules are available.
	\begin{proposition}
	 \label{typing_connection}
	 The following typing rule is admissible.
	  \begin{center}
	   \AxiomC   {$\hypert\hmid
	   \G,\tj{x}{\phi^\ell},\tj{y}{\overline{\phi^\ell}}\tr\tj t \psi$}
	   \UnaryInfC{$\hypert\hmid
	   \G\tr\tj{\nu\tj{x}{\phi^\ell}.t[x_L/x][x_R/y]}{\psi}$}
	   \DisplayProof
	  \end{center}
	\end{proposition}

	\begin{example}[Connecting processes using the session realizers]
	 Using the session realizers, we can connect the processes typed
	 in \thref{ex:typed-processes}.  Indeed,
	 \begin{align*}
	  \tr &
	  \nu(\tj{x}{\recvtype{\sendtype{\two}\terminate}\terminate}).
	  \nu(\tj{y}{\sendtype\two\terminate}).
	  \\ & {\left(
	 \sendterm {x_R}{y_L}{\recvterm {y_R} z {\ign{x_R,y_R}z}}
	 \right)}
	 \otimes
	  \left(
	 \recvterm{x_L}{w'}{\ign{x_L}{\sendterm{w'}{\inl\ast}{\ign
	  {w'}\ast}}}
	  \right)
	  \\&
	 \colon{(\two)\otimes\one}
	 \end{align*}
	 is derivable.
	 Now we have to check the evaluation of this term.
	 For that we prepare a lemma.
	\end{example}


      \subsubsection{Evaluation of Processes}

      The intention of defining $\sendterm x u {t_0}$ and $\recvterm y z {t_1}$
      is mimicking communication in process calculi.
      When we substitute $x$ and $y$ with session type realizers,
      these terms actually make communication.

      A rule\\
      \AxiomC{$\hypere$}
      \UnaryInfC{$\hypere'$}
      \DisplayProof\\
      is \textit{admissible}\index{admissible}
      iff $\hypere'$ is derivable whenever $\hypere$ is.

  \begin{lemma}
   \label{processtype}
   Let $t_0$ be a term containing free variable $x$ and
   $t_1$ be a term containing free variables
   $y$ and $z$.
   The rule
   \begin{center}
    \AxiomC{$\hypere\hmid \leftside{\phi^\ell}\eval v'\hmid
    \rightside{\phi^\ell}\eval w'\hmid t_0[v'/x]\eval v\hmid u\eval
    u'\hmid
    t_1[u'/z][w'/y]\eval w$}
    \UnaryInfC{
    $\hypere\hmid
    \leftside{\sendtype\psi{\phi^\ell}}\eval \lambda x.cx
    \hmid
    \rightside{\sendtype\psi{\phi^\ell}}\eval u'\otimes w'
    \hmid $}
    \noLine
    \UnaryInfC{$
    (\sendterm x u {t_0})[\lambda x.cx / x]\eval v
    \hmid
    (\recvterm y z {t_1})[u'\otimes w'/y] \eval w
    $}
    \DisplayProof
   \end{center}
   is admissible.
  \end{lemma}
  \begin{proof} By the derivation in Figure~\ref{fig:processtype}
    \begin{sidewaysfigure}
     \centering
    \AxiomC{}
    \UnaryInfC{$\lambda x.cx\eval \lambda x.cx$}
    \AxiomC{}
    \UnaryInfC{$\lambda x.cx\eval \lambda x.cx$}
    \AxiomC{}
    \UnaryInfC{$\hypere\hmid \leftside{\phi^\ell}\eval v'\hmid
    \rightside{\phi^\ell}\eval w'\hmid t_0[v'/x]\eval v\hmid u\eval
    u'\hmid
    t_1[u'/z][w'/y]\eval w$}
     \doubleLine
    \UnaryInfC{$\hypere\hmid \leftside{\phi^\ell}\eval v'
    \hmid
    \rightside{\phi^\ell}\eval w'\hmid t_0[v'/x]\eval v\hmid u\eval
    u'\hmid \letin{u'\otimes w'}{z\otimes y}{t_1}\eval w$}
    \BinaryInfC{
    $\hypere\hmid \leftside{\phi^\ell}\eval v'
    \hmid
    \rightside{\phi^\ell}\eval w'\hmid t_0[v'/x]\eval v\hmid \lambda
    x.cx\eval \lambda x.cx\hmid u\eval
    u'\hmid \letin{u'\otimes w'}{z\otimes y}{t_1}\eval w$
    }
     \UnaryInfC{
     $
     \hypere\hmid \co c(\leftside{\phi^\ell})\eval u'
    \hmid
    \rightside{\phi^\ell}\eval w'\hmid t_0[v'/x]\eval v\hmid \lambda
    x.cx\eval \lambda x.cx\hmid cu\eval
    v'\hmid \letin{u'\otimes w'}{z\otimes y}{t_1}\eval w
     $
     }
     \UnaryInfC{
     $
     \hypere\hmid \co c(\leftside{\phi^\ell})\eval u'
    \hmid
    \rightside{\phi^\ell}\eval w'\hmid t_0[v'/x]\eval v\hmid (\lambda
    x.cx)u\eval v'\hmid \letin{u'\otimes w'}{z\otimes y}{t_1}\eval w
     $
     }
     \UnaryInfC{
     $
     \hypere\hmid \co c(\leftside{\phi^\ell})\eval u'
    \hmid
    \rightside{\phi^\ell}\eval w'\hmid t_0[(\lambda
    x.cx)u /x]\eval v\hmid \letin{u'\otimes w'}{z\otimes y}{t_1}\eval w
     $
     }
     \UnaryInfC{
     $
     \hypere\hmid
     \co c(\leftside{\phi^\ell})\otimes \rightside{\phi^\ell} \eval u' \otimes  w'
     \hmid t_0[(\lambda
    x.cx)u /x]\eval v\hmid \letin{u'\otimes w'}{z\otimes y}{t_1}\eval w
     $
     }
     \BinaryInfC{$
     \hypere\hmid \lambda x.cx \eval \lambda x.cx \hmid
     \co c(\leftside{\phi^\ell})\otimes \rightside{\phi^\ell} \eval u' \otimes  w'
     \hmid t_0[(\lambda
    x.cx)u /x]\eval v\hmid \letin{u'\otimes w'}{z\otimes y}{t_1}\eval w
     $}
    \DisplayProof
     \caption{Proof of \thref{processtype}.    The conclusion is
     identical to our goal up to abbreviations. }
     \label{fig:processtype}
    \end{sidewaysfigure}
  \end{proof}

  \begin{example}[Evaluation of communicating processes]
   Here is an example of evaluation.
   \begin{center}
    \AxiomC{}
    \UnaryInfC{$\leftside{\terminate}\eval \ast\hmid
    \rightside{\terminate}\eval \ast$}
    \AxiomC{}
    \UnaryInfC{$\ast\eval\ast$}
    \UnaryInfC{$\inl\ast\eval\inl\ast$}
    \AxiomC{}
    \UnaryInfC{$\ast\eval\ast$}
    \BinaryInfC{$\inl\ast\eval\inl\ast \hmid \ast\eval\ast$}
    \AxiomC{}
    \UnaryInfC{$\ast\eval\ast$}
    \UnaryInfC{$\inl\ast\eval\inl\ast$}
    \TrinaryInfC{$\leftside{\terminate}\eval \ast\hmid
    \rightside{\terminate}\eval \ast
    \hmid
    \inl\ast\eval\inl\ast \hmid \ast\eval\ast
    \hmid
    \inl\ast\eval\inl\ast
    $}
    \LL{$\diamondsuit$}
    \UnaryInfC{$\leftside{\sendtype\two\terminate}\eval \lambda x.cx\hmid
    \rightside{\sendtype \two\terminate}\eval \inl\ast\otimes\ast\hmid
    $}
    \noLine
    \UnaryInfC{\small
    $
    (\sendterm{x_L}{\inl\ast}{\ign {x_L}\ast})[\lambda x.cx/x_L]\eval
    \ast
    \hmid
    (\recvterm{x_R}z{\ign {x_R} z})[\inl\ast\otimes\ast/x_R]\eval\inl\ast
    $
    }
    \UnaryInfC{$\bothside{\sendtype\two\terminate}\eval
    \lambda x.cx\otimes (\inl\ast\otimes \ast) \hmid$}
    \noLine
    \UnaryInfC{\small $
    (\sendterm{x_L}{\inl\ast}{\ign {x_L}\ast})[\lambda x.cx/x_L]
    \otimes
    (\recvterm{x_R}z{\ign {x_R} z})[\inl\ast\otimes\ast/x_R]
    \eval \ast \otimes \inl\ast
    $}
    \UnaryInfC{$\nu(\tj{x}{\sendtype{\one\oplus\one}{\terminate}}).
    \left(\sendterm{x_L}{\inl\ast}{\ign{x_L}\ast}\right)\otimes
    \left(\recvterm{x_R}{z}{\ign {x_R}z}\right)\eval \ast\otimes\inl\ast$}
    \DisplayProof
   \end{center}
   The step $\diamondsuit$ uses \thref{processtype}.
  \end{example}

  \subsection{Copycatting}
  \begin{theorem}
   For any linear type~$\phi^\ell$,
   we can derive
   $\tj{x}{\phi^\ell},\tj{y}{\overline{\phi^\ell}}\tr
   \tj{t}{\one}$
   for some term~$t$.
  \end{theorem}
  \begin{proof}
   By induction on $\phi^\ell$.
   \begin{description}
    \item[($\terminate$)]
	 Since $\overline{\terminate} =\terminate$, the derivation
	  \begin{center}
	   \AxiomC{}
	   \UnaryInfC{$\tr\tj{\ast}\one$}
	   \UnaryInfC{$\tj{y}{\terminate}\tr\tj{\ign y \ast}\one$}
	   \UnaryInfC{$\tj{x}{\terminate},\tj{y}{\terminate}\tr\tj{\ign{x,y}\ast}\one$}
	   \DisplayProof
	  \end{center}
	 suffices.
    \item[($\sendtype\psi{\phi^\ell}$)]
	 Using the induction hypothesis (IH.), we obtain a derivation:
	  \begin{center}
	   \AxiomC{$\vdots$ (IH.)}
	   \UnaryInfC{$\tj{x}{\phi^\ell},\tj{y}{\overline{\phi^\ell}}\tr\tj{t}{\one}$}
	   \AxiomC{}
	   \UnaryInfC{$\tj{z}{\psi}\tr\tj{z}{\psi}$}
	   \BinaryInfC{$\tj{x}{\sendtype{\psi}{\phi^\ell}},\tj{y}{\overline{\phi^\ell}},\tj{z}{\psi}\tr\tj{\sendterm
	   x z t}{\one}$}
	   \UnaryInfC{$\tj{x}{\sendtype{\psi}{\phi^\ell}}\tr\tj{y}{\recvtype
	  \psi {\overline{\phi^\ell}}}\tr\tj{\recvterm y z {\sendterm x
	   z t}}{\one}$}
	   \DisplayProof
	  \end{center}
    \item[($\recvtype\psi{\phi^\ell}$)]
	 Symmetric to above.
    \item[($\oplus\{l_i\colon\phi^\ell_i\}$)]
	 \fix{fill}
    \item[($\with\{l_i\colon\phi^\ell_i\}$)]
	 Symmetric to above.
   \end{description}
  \end{proof}
 \begin{example}
  \fix{Give evaluation}
  Figure~\ref{fig:eval}
 \end{example}

  \begin{sidewaysfigure}
   \centering
   \AxiomC{}
   \UnaryInfC{$\leftside\terminate\eval \ast\hmid
   \rightside\terminate\eval\ast$}
   \AxiomC{}
   \UnaryInfC{$\ast\eval\ast$}
   \UnaryInfC{$\inl\ast\eval\inl\ast$}
   \AxiomC{}
   \UnaryInfC{$\ast\eval\ast$}
   \BinaryInfC{$\inl\ast\eval\inl\ast\hmid\ast\eval\ast$}
   \BinaryInfC{$
   \leftside\terminate\eval \ast\hmid
   \rightside\terminate\eval\ast
   \hmid
   \inl\ast\eval\inl\ast\hmid\ast\eval\ast
   $}
   \UnaryInfC{$
   \leftside{\sendtype\two\terminate}\eval \lambda x. cx\hmid
   \rightside{\sendtype\two\terminate}\eval \inl\ast\otimes \ast \hmid
   (\sendterm{y'}{\inl\ast}\ast)[\lambda x.cx/y']\eval\ast\hmid
   (\recvterm y z z)[\inl\ast\otimes\ast / y]\eval\inl\ast
   $}
   \AxiomC{}
   \UnaryInfC{$\leftside\terminate\eval\ast\hmid
   \rightside\terminate\eval \ast$}
   \BinaryInfC{$
   \leftside{\sendtype\two\terminate}\eval \lambda x. cx\hmid
   \rightside{\sendtype\two\terminate}\eval \inl\ast\otimes \ast \hmid
   (\sendterm{y'}{\inl\ast}\ast)[\lambda x.cx/y']\eval\ast\hmid
   (\recvterm y z z)[\inl\ast\otimes\ast / y]\eval\inl\ast
   \hmid
   \leftside\terminate\eval\ast\hmid
   \rightside\terminate\eval \ast
   $}
   \UnaryInfC{\small $
   \leftside{\sendtype\two\terminate}\eval \lambda x. cx\hmid
   \rightside{\sendtype\two\terminate}\eval \inl\ast\otimes \ast \hmid
   \leftside{\terminate}\eval\ast\hmid
   \rightside{\terminate}\eval\ast\hmid
   (\sendterm{y'}{\inl\ast}\ast)[\lambda x.cx/y']\eval\ast\hmid
   (\recvterm y z z)[\inl\ast\otimes\ast / y]\eval\inl\ast
   \hmid
   \leftside\terminate\eval\ast\hmid
   \rightside\terminate\eval \ast
   $}
   \UnaryInfC{$
   \rightside{\sendtype\two\terminate}\eval \inl\ast\otimes \ast \hmid
   \leftside{\recvtype{\sendtype\two\terminate}\terminate}\eval \lambda
   x.dx\hmid
   \rightside{\recvtype{\sendtype\two\terminate}\terminate}\eval\lambda
   x.cx\otimes \ast\hmid
   $}
   \noLine
   \UnaryInfC{$
   (\recvterm{x'}z{\sendterm{z}{\inl\ast}\ast})[\lambda x.cx\otimes \ast/y']\eval\ast\hmid
   (\sendterm{x}{\leftside{\sendtype\two\terminate}}{\recvterm y z
   z})[\lambda x.dx / x][\inl\ast\otimes\ast / y]\eval\inl\ast
   $}
   \doubleLine
   \UnaryInfC{$
   (\recvterm{x'}{z}{\sendterm z{\inl\ast}{\ast}})
   [\rightside{\recvtype{\sendtype{\two}{\terminate}}{\terminate}}/x']
   \eval \ast
   \hmid
   (\sendterm{x}{\leftside{\sendtype\two\terminate}}{\recvterm y z z})
   [\leftside{\recvtype{\sendtype\two\terminate}\terminate}/x]
   [\rightside{\sendtype\two\terminate}/y]
   \eval \inl\ast
   $}
   \UnaryInfC{$
   (\recvterm{x'}{z}{\sendterm z{\inl\ast}{\ast}})
   [\rightside{\recvtype{\sendtype{\two}{\terminate}}{\terminate}}/x']
   \otimes
   (\sendterm{x}{\leftside{\sendtype\two\terminate}}{\recvterm y z z})
   [\leftside{\recvtype{\sendtype\two\terminate}\terminate}/x]
   [\rightside{\sendtype\two\terminate}/y]
   \eval \ast\otimes \inl\ast
   $}
   \UnaryInfC{$
   \letin{\bothside{\recvtype{\sendtype{\two}{\terminate}}{\terminate}}}{x'\otimes
   x}{
   \letin{\bothside{\sendtype\two\terminate}}{y'\otimes y}{
   (\recvterm{x'}{z}{\sendterm z{\inl\ast}{\ast}})
   \otimes
   (\sendterm{x}{y'}{\recvterm y z z})
   }
   }
   \eval \ast\otimes \inl\ast
   $}
   \DisplayProof
   \caption{An example of evaluation relation.}
  \end{sidewaysfigure}

% \section{Toward Determinacy}

% Determinancy states that if $t\eval v$ and $t\eval w$ are derivable,
% then, $v$ and $w$ are identical.
% Since the proof of dterminacy goes inductively over evaluation
% derivations\fix{define
% evaluation derivations},
% we have to generalize the statement.
%  \begin{proposition}[General Determinacy]
%   If
%   $t_0\eval v_0\hmid \cdots \hmid t_n\eval v_n$ and
%   $t_0\eval w_0\hmid \cdots \hmid t_n\eval w_n$ are
%   derivable,
%   then each $v_i$ is identical to $w_i$.
%  \end{proposition}
%   \begin{proof}
%    By induction on the length of the first derivation.
%    \fix{complete}
%   \end{proof}

\subsection{Dummy Deadlocks and Real Deadlocks}

Using \thref{typing_process} and \thref{typing_connection},
we can build the following type derivation.
\fix{use the translation and use the correct something}
 \begin{center}
  \AxiomC{}
  \UnaryInfC{$\tr\tj 0\one$}
  \UnaryInfC{$\tj{x_R}{\terminate}\tr\tj{\ign {x_R} 0}{\one}$}
  \UnaryInfC{$\tj{x_L}{\terminate},\tj{x_R}{\terminate}
  \tr\tj{\ign{x_L,x_R}{0}}{\one}
  $}
  \AxiomC{}
  \UnaryInfC{$\tj{y}\two\tr\tj y \two$}
  \BinaryInfC{$\tj{y}\two,\tj{x_L}{\terminate},
  \tj{x_R}{\sendtype\two\terminate}\tr
  \tj{\sendterm{x_R}{y}{\ign{x_L,x_R}{0}}}{\one}$}
  \UnaryInfC{
  $\tj{x_L}{\recvtype\two\terminate},\tj{x_R}{\sendtype \two \terminate}
  \tr\tj
  {\recvterm {x_L}{y}{\sendterm{x_R}{y}{\ign {x_L,x_R} 0}}}\one$
  }
  \UnaryInfC{
  $\tr\tj{\nu\tj{x}{\recvtype\two\terminate}.
  \recvterm {x_L}{y}{\sendterm{x_R}{y}{\ign {x_L,x_R} 0}}}{\one}$
  }
  \DisplayProof
 \end{center}
However, the typed process
\[
 \nu x.x(y).\recvterm x y 0
\]
 is deadlocked in the traditional semantics of
process calculi because the process waits for a value from $x$ before
sending a value to $x$.
However, we can give an evaluation to this process.

The situation is essentially similar to $\co c(c)t$ (\thref{inner-something}).
When we want the output of channel $c$, we can look at $\co c$'s input,
which is $t$.  However, when we want the output of $\co c$, we have to
look at the input of $c$, which is again the output of $\co c$.  Thus we
can never know the output of $\co c$.
Similarly, for the process above, we never know what value is passed
along channel~$x$, but we can still evaluate the while process.
We call this situation \textit{dummy deadlocks}\index{deadlock!dummy}.

On the other hand,
the same trick cannot be used for the following process.
\[
 \nu(x\colon \sendtype{\two}\terminate).
 \recvterm{x_R}y{\letin y {y_0@y_1}{\sendterm{x_L}{y_0}{y_1}}}\enspace.
\]
This is an example of real deadlocks.
Indeed, this process is not typable.

\section{Proof Nets}

Proof nets are
graphical representation of proofs.
\fix{Girard, etc etc}

Since the Amida axiom $(\phi\limp\psi)\otimes(\psi\limp\phi)$
does not contain additives ($\with,\oplus$) or exponential ($!$),
we can focus on the multiplicative connectives.
The fragment is called IMLL (intuitionistic multiplicative fragment of
linear logic).  We also use the unit $\one$ for technical reasons.
We first describe the IMLL proof nets and their properties.
Then we add Amida links and see it characterizes the Amida logic.

The Amida links are named after the Amida lottery,
a traditional way to generate permutations on a set%
\footnote{The Amida lottery has been known in Japan since \fix{?}}.

\subsection{IMLL Essential Nets}

We can translate a pair $\tuple{\phi,p}$ of
a polarity $p\in\{+,-\}$ and an IMLL formula~$\phi$ into
a polarized MLL formula as follow (from \fix{cite Ong and Lamarche}).
\begin{align*}
 \imtrans{X}^+ = X^+      \qquad & \imtrans{X}^- = X^- \\
 \imtrans{\phi\limp\psi}^+ = \imtrans{\phi}^-\parr^+\imtrans{\psi}^+
 \qquad & \imtrans{\phi\limp\psi}^- = \imtrans{\phi}^+ \otimes^-
 \imtrans{\psi}^- \\
 \imtrans{\phi\otimes\psi}^+ = \imtrans{\phi}^+\otimes^+\imtrans{\psi}^+
 \qquad & \imtrans{\phi\otimes\psi}^- =
 \imtrans{\phi}^- \parr^- \imtrans{\psi}^-\enspace.
\end{align*}

For example,
\begin{align*}
   &\imtrans{(X\limp Y)\otimes (Y\limp X)}^+ \\
 =\, &\imtrans{X\limp Y}^+ \otimes^+ \imtrans{Y\limp X}^+ \\
 =\, &\left(\imtrans{X}^- \parr^+ \imtrans{Y}^+ \right) \otimes^+
    \left(\imtrans{Y}^- \parr^+ \imtrans{X}^+ \right) \\
 =\, &\left({X}^- \parr^+ {Y}^+ \right) \otimes^+
    \left({Y}^- \parr^+ {X}^+ \right)
\end{align*}

\fix{define essential net structure, add unit}

\fix{state correctness}
Lamarche exibits a common technique of decomposing a net structure from
the bottom.

\fix{who} chose to reduce the problem to sequents of special forms
called regular.

\subsection{Amida Nets}

 \begin{definition}[Amida nets]
For a hypersequent~$\hyper$,
\textit{Amida nets}\index{Amida nets} of $\hyper$ are inductively
  defined as
\begin{itemize}
 \item an essential net of $\hyper$ is an Amida net of $\hyper$
 \item for an Amida net of $\hyper$ with two different $+$~edges,
	\begin{center}
	 % twoedges
	 \includegraphics[scale=0.4]{twoedges.eps}
	\end{center}
       replacing these with
	\begin{center}
	 \includegraphics[scale=0.4]{twoedges_amida.eps}
	\end{center}
       yields an Amida net of $\hyper$,
       where the above component has two paths $e_{0d} e_a e_{1u}$
       and $e_{1d} e_a e_{0u}$.
 \item for an Amida net of $\hyper$ with a $+$~edge,
	\begin{center}
	 \includegraphics[scale=0.4]{oneedge.eps}
	\end{center}
       replacing these with
	\begin{center}
	 \includegraphics[scale=0.4]{oneedge_amida.eps}
	\end{center}
       yields an Amida net of $\hyper$,
       where the above component has
       one finite path $e_de_ae_u$
       and one infinite path $\cdots e_m e_a e_m e_a \cdots$.
\end{itemize}
 \end{definition}

The Amida edge between two edges
 \begin{center}
\includegraphics[scale=0.4]{twoedges_amida_without_label.eps}
 \end{center}
is the same as a pair of crossing edges
 \begin{center}
\includegraphics[scale=0.4]{crossing.eps}
 \end{center}
in terms of reachability between endpoints.
The difference is the induced sequent at the bottom.
Although Amida edges cross the paths,
they do not transmit labelings as seen in the next example.

 \begin{example}
  The Amida net for the Amida axiom.
 \end{example}

\subsection{Correctness}

\fix{define some words below}

We can translate a sequent calculus proof into a correct Amida net.

Inverse, from a correct Amida net, first we move the Amida edges upwards
until they are just below axiom edges.

The moves are as follows.
 \begin{center}
\includegraphics[scale=0.4]{tensor-move.eps}
\\
\includegraphics[scale=0.4]{parr-move.eps}
 \end{center}
These translations have two properties.
\begin{enumerate}
 \item When the original is a correct Amida net, the translation is also
       a correct Amida net.
 \item When the translation corresponds to a hypersequent derivation,
       the original does.
\end{enumerate}
For checking the first condition, it is enough to follow the paths.
The second condition is immediate for the $\otimes^+$ translation, but
not immediate for the $\parr^+$ translation.  The second condition on
the $\otimes^+$ translation can be validated by the following Amida
logic derivation.
\begin{center}
 \AxiomC{$\G,\psi\tr\phi \hmid \D\tr\chi$}
 \AxiomC{}
 \UnaryInfC{$\tr\one$}
 \AxiomC{}
 \UnaryInfC{$\psi\tr\psi$}
 \BinaryInfC{$\tr \psi\hmid \psi\tr\one$}
 \BinaryInfC{$\G\tr\phi\hmid \D\tr\chi\hmid \psi\tr\one$}
 \UnaryInfC{$ \G\tr\phi\hmid \D,\psi\tr\chi\otimes \one $}
 \AxiomC{}
 \UnaryInfC{$\chi\tr\chi$}
 \UnaryInfC{$\chi,\one\tr\chi$}
 \UnaryInfC{$\chi\otimes \one \tr\chi$}
 \BinaryInfC{$\G\tr\phi\hmid \D,\psi\tr\chi$}
 \DisplayProof
\end{center}

Then the whole Amida net is decomposed vertically into three layers.
At the top, there is a layer with only Axiom edges.
In the middle, there is a layer with only vertical edges and Amida
edges.
At the bottom, there is a layer which contains only ordinary
essential net nodes.

Since the middle layer is an Amida lottery, it defines a permutation.
That permutation can be expressed as a product of transpositions, so
that
the original Amida lottery is equivalent to a loop-less Amida lottery.
A loop-less Amida lottery is an encoding of a hypersequent derivation
that consists of only Sync rules.

After we encode the top and the middle layer, encoding the bottom layer
is the same as \fix{Lamarche's theorem which}


We expect that it is possible to add Amida edges to
the full intuitionistic logic following
\citet{groote1999}
\fix{cite de groote / cite Lamarche}


\section{Related Work}

\subsection{Pfenning}

\citet{pfenning2010} provide a type system for a fragment of $\pi$-calculus.
The type system of \citet{pfenning2010} imposes too strong a descipline
than necessary to provide deadlock freedom.
While the escrowing process $P$ is not typeable in their type
system, where
\[
 P = \sendterm x y{\recvterm x a {\recvterm y b {\sendterm x b
 {\sendterm y a 0}}}}\enspace.
\]
The process first emits a channel~$y$ through channel~$x$ and then
exchanges inputs from $x$ and $y$ into outputs to $y$ and $x$.
Following the informal description of types in \citep{pfenning2010},
the process~$P$ should be typeable as
\[
 \vdash P::x:(A\limp B)\otimes(B\limp A)\enspace.
\]
However, such typing is not possible because $(A\limp B)\otimes (B\limp
A)$ is not a theorem of \fix{name} (DILL), the logic their type system
is based on.
In our type system, the following sequent is derivable
\begin{align*}
&
\tj{x}{\sendtype{\sendtype{B}{\recvtype{A}\terminate}}{\recvtype B
{\sendtype A \terminate}}}
\tr\\
&\tj{
\nu(\tj{y}{\sendtype B{\recvtype A \terminate}}).
{\sendterm x{y_L}{\recvterm x a {\recvterm {y_R} b {\sendterm x b {\sendterm
{y_R} a {\ign{x,y}0}}}}}}
}{\one}
\end{align*}
The resulting sequent indicates that the process is typeable with one
open channel~$x$ that emits
a channel to/from which one can send~$B$ and receivie~$A$, receives a
value of $B$ and
sends a value of $A$.
This example shows that our type system is strictly more flexible than
the type system in \citet{pfenning2010}.
Moreover, we still ensure deadlock freedom in the sense that all typed
processes reduce to the canonical form~(\thref{convergence}).

The most complicated example in \citet{pfenning2010} is the following
one, which can be typed and evaluated in our framework as well.

 \begin{example}[Drink server example from \citet{pfenning2010}]
  \begin{align*}
   ServerProto &= (N\limp I \limp (N\otimes \one))\with (N\limp( I
  \otimes \one)) \\
   &= (\sendtype N {\sendtype { I} {\recvtype N \terminate}}) \with
   (\sendtype N {\recvtype { I} \one})
  \end{align*}
  $N$ stands for the type of strings and $I$ stands for the type of
  integers, but following \citet{pfenning2010}, we identify both $N$ and
  $I$ with $\one$.
  Here is the prototype of the server, that serves one client and
  terminates.\\
  \[
   Serv = \lpair{\recvterm s {pn} {\recvterm s {cn} {\sendterm s {rc}
  {\ign {pn, cn, s} 0}}}
  ,\quad
  \recvterm s {pn} {\sendterm s {pr} {\ign{s,pn} 0}}
  }
  \]
  We can derive a sequent $\tj{s}{\overline{SP}}\tr\tj{Serv}\one$.
  \fix{how}

  Using this, we can also implement a server that can replicate itself
  and serve many clients.  Below, $SP$ abbreviates $ServerProto$.
  \begin{center}
   \AxiomC{$\tj{s}{\overline{SP}}\tr\tj {Serv}{\one}$}
   \AxiomC{}
   \UnaryInfC{$\tj{x}{SP}\tr\tj{x}{SP}$}
   \UnaryInfC{$\tj{z}\one,\tj{x}{SP}\tr\tj{\ign z x}{SP}$}
   \BinaryInfC{$\tj{s}{\overline{SP}},\tj{x}{SP}\tr\tj{\ign{Serv}x}{SP}$}
   \UnaryInfC{$\tr\tj{\nu(\tj{s}{SP}).\ign{Serv[s_R/s]}{s_L}}{SP}$}
   \UnaryInfC{$\tr\bang\tj{\nu(\tj{s}{SP}).\ign{Serv[s_R/s]}{s_L}}{\bang
   SP}$}
   \DisplayProof
  \end{center}


  Here is one client:
  \begin{center}
   \AxiomC{}
   \UnaryInfC{$\tr\tj{0}\one$}
   \UnaryInfC{$\tj{s}{\terminate}\tr\tj{\ign s 0}\one$}
   \UnaryInfC{$\tj{s}{\terminate},
   \tj{pr}{I}\tr\tj{\ign{pr,s} 0}\one$}
   \UnaryInfC{
   $ \tj{s}{\recvtype {I} {\terminate}} \tr\tj{
   \recvterm s {pr} {\ign{pr,s} 0}
   }{\one}$
   }
   \AxiomC{}
   \UnaryInfC{$ \tr\tj{tea}{N} $}
   \BinaryInfC{
   $ \tj{s}{\sendtype N {\recvtype {I} \terminate}} \tr\tj{
   \sendterm s {tea}
   {\recvterm s {pr} {\ign{pr,s} 0}}
   }{\one}$
   }
   \UnaryInfC{
   $ \tj{s}{ServerProto} \tr\tj{
   \letin s {\lpair{\_, s}} {
   \sendterm s {tea}
   {\recvterm s {pr} {\ign{pr,s} 0}}}
   }{\one}$
   }
   \DisplayProof
  \end{center}
  We abbreviate the process as $QClnt_s$.
  In words, the client first chooses the server's second protocol, which
  is price quoting, and asks the price of the tea, receives the price
  and terminates.

  Here is another client.
  \begin{center}
   \AxiomC{}
   \UnaryInfC{$ \tr\tj{0}\one $}
   \UnaryInfC{$ \tj{s}{\terminate}\tr\tj{\ign s 0}\one$}
   \UnaryInfC{$ \tj{s}{\terminate},\tj{rc}{N}\tr\tj{
   {\ign {rc,s} 0}}\one$}
   \UnaryInfC{$ \tj{s}{\recvtype{N}\terminate}\tr
   \tj
   {\recvterm{s}{rc}{\ign {rc,s} 0}}
   {\one}$}
   \AxiomC{}
   \UnaryInfC{$\tr\tj{pin}{I}$}
   \BinaryInfC{$ \tj{s}{\sendtype{I}{\recvtype{N}\terminate}}\tr
   \tj
   {\sendterm{s}{pin}{\recvterm{s}{rc}{\ign {rc,s} 0}}}
   {\one}$}
   \UnaryInfC{$ \tj{s}{\sendtype{N}{\sendtype{I}{\recvtype{N}\terminate}}}\tr
   \tj
   {\sendterm{s}{cof}{\sendterm{s}{pin}{\recvterm{s}{rc}{\ign {rc,s} 0}}}}
   {\one}$}
   \UnaryInfC{$ \tj{s}{ServerProto}\tr
   \tj
   {\letin s {\lpair{s,\_}}
   {\sendterm{s}{cof}{\sendterm{s}{pin}{\recvterm{s}{rc}{\ign {rc,s} 0}}}}}
   {\one}$}
   \DisplayProof
  \end{center}
  We abbreviate the process as $BClnt_s$.

  We can combine the server with two clients.
   \begin{center}
    \AxiomC{$\tj{s}{SP}\tr\tj{QClint_s}{\one}$}
    \AxiomC{$\tj{s'}{SP}\tr\tj{BClient_{s'}}{\one}$}
    \BinaryInfC{$\tj{s}{SP},\tj{s'}{SP}\tr
    \tj{{QClint_s}\otimes{BClient_{s'}}}{\one\otimes\one}$}
    \UnaryInfC{$\tj{s}{!SP},\tj{s'}{!SP}\tr
    \tj{\letin{s}{!s}{\letin{s'}{!s'}
    {{QClint_s}\otimes{BClient_{s'}}}}}{\one\otimes\one}$}
    \UnaryInfC{$\tj{s}{!SP}\tr
    \tj{\letin{s}{s@s'}{
    \letin{s}{!s}{\letin{s'}{!s'}
    {{QClint_s}\otimes{BClient_{s'}}}}}}{\one\otimes\one}$}
    \UnaryInfC{$\tr
    \tj{\letin{!Serv}{s@s'}{
    \letin{s}{!s}{\letin{s'}{!s'}
    {{QClint_s}\otimes{BClient_{s'}}}}}}{\one\otimes\one}$}
    \DisplayProof
   \end{center}

  Here is an evaluation of the combined system of the server and the two
  clients.
 \end{example}

\subsection{Wadler}

\citet{wadler2012propositions} gave a type system for a process
calculus based on classical linear logic.
Although the setting is classical, the idea is more or less the same as
\citet{pfenning2010}.
Wadler's type system cannot type the escrowing process above.
Worse, \citet{wadler2012propositions} does not recognize this
\[
 \sendterm x y{\recvterm x a {\recvterm y b {\sendterm x b {\sendterm y
 a 0}}}}
\]
as a process at all.
His grammar requires the output construction to be used in the form
\[
 \sendterm x y {(P\mid Q)}
\]
where $x$ is bound in $Q$ but not in $P$ and $y$ is bound in $P$ but not
in $Q$.
Of course, there is a way to escape the above restriction by making $P$
and $Q$ communicate, but that option is prohibited by the typing rules.

\subsection{Beffara}

\subsection{Categorical Considerations}
One might want to ask whether we can model the logic with
a symmetric monoidal closed category~\citep{blute2004category}
  with identified isomorphisms
$\sigma_{ABCD}\colon (A\limp B)\otimes (C\limp D)\rightarrow (A\limp D) \otimes
 (C\limp B)$, with naturality conditions.
 Before considering equality among morphisms,
 we know there is a non-trivial example.
  \begin{example}[A symmetric monoidal closed category with swaps]
   The preorder formed by objects as integers and morphisms as the usual
   order among integers~$\le$
   forms a symmetric monoidal closed category with swaps
   when we interpret $\otimes$ as addition,
   $m \limp n$ as $n-m$.
  \end{example}
A straightforward reading of evaluation rules gives somewhat complicated
equiality conditions for morphisms.
The condition says the following diagram commutes:
\[
   \begin{CD}
    (A\limp B)\otimes (C\limp D) @>{d_{ABCD}}>> (A\otimes C)\limp(B\otimes D)\\
    @VV{\sigma_{ABCD}}V @VV{id\limp s_{B,D}}V\\
    (A\limp D)\otimes (C\limp B) @>{d_{ADCB}}>> (A\otimes C)\limp (D\otimes B)
   \end{CD}
\]
where $d_{ABCD}$ is induced by adjunction between $\otimes$ and $\limp$
 from a morphism
 $((A\limp B)\otimes (C\limp D))\otimes (A\otimes C)\rightarrow
 (B\otimes D)$, which is provided by symmetric monoidal closed properties.

\section{Discussion}

It is tempting to add modalities to types so that the
modalities show agents and then study the relationship with the
multiparty session types \fix{cite}.

\fix{give rationale for giving up determinacy.. channel inside lambda}

\fix{cite Dale Miller and say MALL with fixed points will be convenient
not as a logic programming paradigm but as typed lambda calculus.}

\section{Conclusion}




